{"model": "google/gemini-flash-1.5", "problem_id": "02196f18-2753-4d5e-b266-046cc2c02b0c", "code": "use anyhow::{anyhow, Result};\nuse chrono::{DateTime, Utc};\nuse futures::lock::Mutex;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse uuid::Uuid;\n\n#[derive(Debug, thiserror::Error)]\npub enum RentalError {\n    #[error(\"Item not found\")]\n    ItemNotFound,\n    #[error(\"Item already rented\")]\n    ItemAlreadyRented,\n    #[error(\"Invalid rental period\")]\n    InvalidRentalPeriod,\n    #[error(\"Other error: {0}\")]\n    Other(String),\n}\n\ntrait Rentable {\n    fn id(&self) -> Uuid;\n    fn name(&self) -> &str;\n    fn is_available(&self) -> bool;\n}\n\ntrait RentalPolicy {\n    fn validate_rental_period(&self, days: i64) -> Result<(), RentalError>;\n}\n\nstruct DefaultRentalPolicy;\n\nimpl RentalPolicy for DefaultRentalPolicy {\n    fn validate_rental_period(&self, days: i64) -> Result<(), RentalError> {\n        if days <= 0 {\n            return Err(RentalError::InvalidRentalPeriod);\n        }\n        Ok(())\n    }\n}\n\n\nstruct Rental<T: Rentable> {\n    item: T,\n    renter: String,\n    start_date: DateTime<Utc>,\n    end_date: DateTime<Utc>,\n}\n\nstruct RentalSystem<T: Rentable + Send + Sync> {\n    items: Arc<Mutex<HashMap<Uuid, T>>>,\n    rentals: Arc<Mutex<Vec<Rental<T>>>>,\n    rental_policy: Box<dyn RentalPolicy + Send + Sync>,\n}\n\nimpl<T: Rentable + Send + Sync> RentalSystem<T> {\n    fn new(rental_policy: Box<dyn RentalPolicy + Send + Sync>) -> Self {\n        RentalSystem {\n            items: Arc::new(Mutex::new(HashMap::new())),\n            rentals: Arc::new(Mutex::new(Vec::new())),\n            rental_policy,\n        }\n    }\n\n    async fn add_item(&self, item: T) {\n        let mut items = self.items.lock().await;\n        items.insert(item.id(), item);\n    }\n\n    async fn rent_item(&self, item_id: Uuid, renter: String, days: i64) -> Result<(), RentalError> {\n        let mut items = self.items.lock().await;\n        let mut rentals = self.rentals.lock().await;\n\n        let item = items.get_mut(&item_id).ok_or(RentalError::ItemNotFound)?;\n        if !item.is_available() {\n            return Err(RentalError::ItemAlreadyRented);\n        }\n        self.rental_policy.validate_rental_period(days)?;\n        let start_date = Utc::now();\n        let end_date = start_date + chrono::Duration::days(days);\n        rentals.push(Rental {\n            item: item.clone(),\n            renter,\n            start_date,\n            end_date,\n        });\n        Ok(())\n    }\n}\n\n\n#[derive(Clone, Debug)]\nstruct Movie {\n    id: Uuid,\n    name: String,\n    available: bool,\n}\n\nimpl Rentable for Movie {\n    fn id(&self) -> Uuid {\n        self.id\n    }\n    fn name(&self) -> &str {\n        &self.name\n    }\n    fn is_available(&self) -> bool {\n        self.available\n    }\n}\n\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let rental_policy = Box::new(DefaultRentalPolicy);\n    let rental_system = RentalSystem::new(rental_policy);\n\n    let movie1 = Movie {\n        id: Uuid::new_v4(),\n        name: \"Movie 1\".to_string(),\n        available: true,\n    };\n\n    rental_system.add_item(movie1.clone()).await;\n\n    rental_system.rent_item(movie1.id(), \"Alice\".to_string(), 5).await?;\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "google/gemini-flash-1.5", "problem_id": "dfcef33d-f032-46a2-a10f-dc810a753508", "code": "use rand::Rng;\n\nfn quicksort<T: Ord + Clone>(arr: &mut [T]) {\n    if arr.len() <= 1 {\n        return;\n    }\n\n    let pivot_index = arr.len() / 2;\n    let pivot = arr[pivot_index].clone();\n\n    let (left, right) = arr.split_at_mut(pivot_index);\n    let (left, middle) = left.split_last_mut().unwrap();\n    let (mut right, _) = right.split_first_mut().unwrap();\n\n    let mut i = 0;\n    let mut j = 0;\n\n    // Partitioning\n    while i < left.len() {\n        if left[i] <= pivot {\n            left.swap(i, j);\n            j += 1;\n        }\n        i += 1;\n    }\n\n    left.swap(j, left.len() -1);\n\n    let mut k = 0;\n    while k < right.len() {\n        if right[k] > pivot {\n            right.swap(k, right.len() -1);\n            break;\n        }\n        k += 1;\n    }\n\n    let mut temp = vec![];\n    temp.extend_from_slice(&left[..j]);\n    temp.push(pivot.clone());\n    temp.extend_from_slice(&right[..k]);\n    temp.extend_from_slice(&left[j..]);\n    temp.extend_from_slice(&right[k..]);\n\n    arr.copy_from_slice(&temp);\n\n    quicksort(&mut arr[..j]);\n    quicksort(&mut arr[j + 1..]);\n}\n\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut numbers: Vec<i32> = (0..10).map(|_| rng.gen_range(1..100)).collect();\n\n    println!(\"Unsorted array: {:?}\", numbers);\n\n    quicksort(&mut numbers);\n\n    println!(\"Sorted array: {:?}\", numbers);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3-5-haiku", "problem_id": "dfcef33d-f032-46a2-a10f-dc810a753508", "code": "fn quicksort<T: Ord>(arr: &mut [T]) {\n    let len = arr.len();\n    if len <= 1 {\n        return;\n    }\n    \n    quicksort_helper(arr, 0, len - 1);\n}\n\nfn quicksort_helper<T: Ord>(arr: &mut [T], low: usize, high: usize) {\n    if low < high {\n        let pivot_index = partition(arr, low, high);\n        \n        // Recursively sort the left and right subarrays\n        if pivot_index > low {\n            quicksort_helper(arr, low, pivot_index - 1);\n        }\n        \n        if pivot_index < high {\n            quicksort_helper(arr, pivot_index + 1, high);\n        }\n    }\n}\n\nfn partition<T: Ord>(arr: &mut [T], low: usize, high: usize) -> usize {\n    // Choose the rightmost element as the pivot\n    let pivot = high;\n    \n    // Index of the smaller element\n    let mut i = low;\n    \n    // Traverse through all elements\n    // Compare each element with the pivot\n    for j in low..high {\n        if arr[j] <= arr[pivot] {\n            // Swap elements if current element is smaller than or equal to pivot\n            arr.swap(i, j);\n            i += 1;\n        }\n    }\n    \n    // Place the pivot in its correct position\n    arr.swap(i, pivot);\n    \n    // Return the index of the pivot\n    i\n}\n\nfn main() {\n    // Example usage\n    let mut numbers = vec![64, 34, 25, 12, 22, 11, 90];\n    \n    println!(\"Original array: {:?}\", numbers);\n    \n    quicksort(&mut numbers);\n    \n    println!(\"Sorted array: {:?}\", numbers);\n    \n    // Another example with different types\n    let mut strings = vec![\"banana\", \"apple\", \"cherry\", \"date\"];\n    \n    println!(\"Original string array: {:?}\", strings);\n    \n    quicksort(&mut strings);\n    \n    println!(\"Sorted string array: {:?}\", strings);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "openai/gpt-4o-mini", "problem_id": "dfcef33d-f032-46a2-a10f-dc810a753508", "code": "fn quicksort(arr: &mut [i32]) {\n    if arr.len() <= 1 {\n        return;\n    }\n\n    let pivot_index = partition(arr);\n    quicksort(&mut arr[0..pivot_index]);\n    quicksort(&mut arr[pivot_index + 1..]);\n}\n\nfn partition(arr: &mut [i32]) -> usize {\n    let pivot_index = arr.len() - 1;\n    let pivot_value = arr[pivot_index];\n    let mut i = 0;\n\n    for j in 0..pivot_index {\n        if arr[j] < pivot_value {\n            arr.swap(i, j);\n            i += 1;\n        }\n    }\n    arr.swap(i, pivot_index);\n    i\n}\n\nfn main() {\n    let mut numbers = [34, 7, 23, 32, 5, 62];\n    println!(\"Unsorted array: {:?}\", numbers);\n    \n    quicksort(&mut numbers);\n    \n    println!(\"Sorted array: {:?}\", numbers);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "qwen/qwen-2.5-coder-32b-instruct", "problem_id": "dfcef33d-f032-46a2-a10f-dc810a753508", "code": "use rand::seq::SliceRandom;\nuse rand::thread_rng;\n\nfn quicksort<T: Ord>(arr: &mut [T]) {\n    if arr.len() <= 1 {\n        return;\n    }\n\n    let pivot_index = partition(arr);\n    let (left, right) = arr.split_at_mut(pivot_index);\n    quicksort(left);\n    quicksort(&mut right[1..]);\n}\n\nfn partition<T: Ord>(arr: &mut [T]) -> usize {\n    let len = arr.len();\n    let pivot_index = len - 1;\n    let pivot = &arr[pivot_index];\n\n    let mut i = 0;\n    for j in 0..pivot_index {\n        if &arr[j] <= pivot {\n            arr.swap(i, j);\n            i += 1;\n        }\n    }\n    arr.swap(i, pivot_index);\n    i\n}\n\nfn main() {\n    // Example array of unordered numbers\n    let mut numbers = [34, 7, 23, 32, 5, 62];\n    println!(\"Unsorted array: {:?}\", numbers);\n\n    // Sort the array using quicksort\n    quicksort(&mut numbers);\n    println!(\"Sorted array: {:?}\", numbers);\n\n    // To demonstrate with a larger random array\n    let mut rng = thread_rng();\n    let mut large_numbers: Vec<i32> = (0..100).collect();\n    large_numbers.shuffle(&mut rng);\n    println!(\"Unsorted large array: {:?}\", &large_numbers[..10]);\n\n    quicksort(&mut large_numbers);\n    println!(\"Sorted large array: {:?}\", &large_numbers[..10]);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "qwen/qwen-2.5-coder-32b-instruct", "problem_id": "02196f18-2753-4d5e-b266-046cc2c02b0c", "code": "use std::sync::{Arc, Mutex};\nuse std::collections::HashMap;\nuse std::iter::Iterator;\nuse std::fmt;\nuse thiserror::Error;\nuse tokio::sync::RwLock;\nuse uuid::Uuid;\n\n#[derive(Debug, Error)]\nenum RentalError {\n    #[error(\"Item not found: {0}\")]\n    ItemNotFound(String),\n    #[error(\"Item already rented: {0}\")]\n    ItemAlreadyRented(String),\n    #[error(\"Item not rented: {0}\")]\n    ItemNotRented(String),\n    #[error(\"Invalid rental policy\")]\n    InvalidRentalPolicy,\n}\n\ntrait Rentable {\n    fn name(&self) -> &str;\n}\n\nstruct Movie {\n    name: String,\n}\n\nimpl Rentable for Movie {\n    fn name(&self) -> &str {\n        &self.name\n    }\n}\n\nstruct RentalItem<T: Rentable> {\n    item: T,\n    is_rented: bool,\n    rental_history: Vec<Uuid>,\n}\n\nimpl<T: Rentable> RentalItem<T> {\n    fn new(item: T) -> Self {\n        RentalItem {\n            item,\n            is_rented: false,\n            rental_history: Vec::new(),\n        }\n    }\n\n    fn rent(&mut self) -> Result<(), RentalError> {\n        if self.is_rented {\n            return Err(RentalError::ItemAlreadyRented(self.item.name().to_string()));\n        }\n        self.is_rented = true;\n        self.rental_history.push(Uuid::new_v4());\n        Ok(())\n    }\n\n    fn return_item(&mut self) -> Result<(), RentalError> {\n        if !self.is_rented {\n            return Err(RentalError::ItemNotRented(self.item.name().to_string()));\n        }\n        self.is_rented = false;\n        Ok(())\n    }\n\n    fn rental_history(&self) -> RentalHistoryIterator {\n        RentalHistoryIterator {\n            history: self.rental_history.clone(),\n            index: 0,\n        }\n    }\n}\n\nstruct RentalHistoryIterator {\n    history: Vec<Uuid>,\n    index: usize,\n}\n\nimpl Iterator for RentalHistoryIterator {\n    type Item = Uuid;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.index < self.history.len() {\n            let item = self.history[self.index];\n            self.index += 1;\n            Some(item)\n        } else {\n            None\n        }\n    }\n}\n\nstruct RentalSystem<T: Rentable> {\n    items: Arc<RwLock<HashMap<String, RentalItem<T>>>>,\n}\n\nimpl<T: Rentable> RentalSystem<T> {\n    fn new() -> Self {\n        RentalSystem {\n            items: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    async fn add_item(&self, item: T) {\n        let mut items = self.items.write().await;\n        items.insert(item.name().to_string(), RentalItem::new(item));\n    }\n\n    async fn rent_item(&self, item_name: &str) -> Result<(), RentalError> {\n        let mut items = self.items.write().await;\n        let item = items.get_mut(item_name).ok_or_else(|| RentalError::ItemNotFound(item_name.to_string()))?;\n        item.rent()?;\n        Ok(())\n    }\n\n    async fn return_item(&self, item_name: &str) -> Result<(), RentalError> {\n        let mut items = self.items.write().await;\n        let item = items.get_mut(item_name).ok_or_else(|| RentalError::ItemNotFound(item_name.to_string()))?;\n        item.return_item()?;\n        Ok(())\n    }\n\n    async fn get_rental_history(&self, item_name: &str) -> Result<RentalHistoryIterator, RentalError> {\n        let items = self.items.read().await;\n        let item = items.get(item_name).ok_or_else(|| RentalError::ItemNotFound(item_name.to_string()))?;\n        Ok(item.rental_history())\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let rental_system = RentalSystem::<Movie>::new();\n\n    let movie1 = Movie { name: \"Inception\".to_string() };\n    let movie2 = Movie { name: \"Interstellar\".to_string() };\n\n    rental_system.add_item(movie1).await;\n    rental_system.add_item(movie2).await;\n\n    rental_system.rent_item(\"Inception\").await.unwrap();\n    rental_system.rent_item(\"Interstellar\").await.unwrap();\n\n    let history = rental_system.get_rental_history(\"Inception\").await.unwrap();\n    for uuid in history {\n        println!(\"Rental UUID: {}\", uuid);\n    }\n\n    rental_system.return_item(\"Inception\").await.unwrap();\n    rental_system.return_item(\"Interstellar\").await.unwrap();\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3.5-sonnet", "problem_id": "dfcef33d-f032-46a2-a10f-dc810a753508", "code": "fn quicksort<T: Ord>(arr: &mut [T]) {\n    let len = arr.len();\n    if len <= 1 {\n        return;\n    }\n    \n    let pivot = partition(arr);\n    quicksort(&mut arr[0..pivot]);\n    quicksort(&mut arr[pivot + 1..]);\n}\n\nfn partition<T: Ord>(arr: &mut [T]) -> usize {\n    let len = arr.len();\n    let pivot = len - 1;\n    let mut i = 0;\n    \n    for j in 0..len - 1 {\n        if arr[j] <= arr[pivot] {\n            arr.swap(i, j);\n            i += 1;\n        }\n    }\n    \n    arr.swap(i, pivot);\n    i\n}\n\nfn main() {\n    // Example usage with different types of number arrays\n    \n    // Integer array\n    let mut numbers = vec![64, 34, 25, 12, 22, 11, 90];\n    println!(\"Original array: {:?}\", numbers);\n    quicksort(&mut numbers);\n    println!(\"Sorted array: {:?}\", numbers);\n    \n    // Floating point array\n    let mut float_numbers = vec![3.14, 1.41, 2.71, 0.58, 1.73];\n    println!(\"\\nOriginal float array: {:?}\", float_numbers);\n    quicksort(&mut float_numbers);\n    println!(\"Sorted float array: {:?}\", float_numbers);\n    \n    // Test with an empty array\n    let mut empty: Vec<i32> = vec![];\n    quicksort(&mut empty);\n    println!(\"\\nSorted empty array: {:?}\", empty);\n    \n    // Test with an array of one element\n    let mut single = vec![1];\n    quicksort(&mut single);\n    println!(\"Sorted single element array: {:?}\", single);\n    \n    // Test with duplicate elements\n    let mut duplicates = vec![3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\n    println!(\"\\nOriginal array with duplicates: {:?}\", duplicates);\n    quicksort(&mut duplicates);\n    println!(\"Sorted array with duplicates: {:?}\", duplicates);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3-5-haiku", "problem_id": "4c69bb31-2ecb-4874-9829-2f12501cd8a8", "code": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse reqwest;\nuse lru::LruCache;\nuse anyhow::{Result, Context};\n\n#[derive(Clone)]\nstruct EncyclopediaService {\n    full_cache: Arc<Mutex<LruCache<String, String>>>,\n    summary_cache: Arc<Mutex<LruCache<String, String>>>,\n    client: reqwest::Client,\n}\n\nimpl EncyclopediaService {\n    fn new(n_full: usize, n_summary: usize) -> Self {\n        Self {\n            full_cache: Arc::new(Mutex::new(LruCache::new(n_full))),\n            summary_cache: Arc::new(Mutex::new(LruCache::new(n_summary))),\n            client: reqwest::Client::new(),\n        }\n    }\n\n    async fn get_summary(&self, title: &str) -> Result<String> {\n        // Check summary cache first\n        {\n            let mut summary_cache = self.summary_cache.lock().await;\n            if let Some(summary) = summary_cache.get(title) {\n                return Ok(summary.clone());\n            }\n        }\n\n        // Check full cache\n        {\n            let full_cache = self.full_cache.lock().await;\n            if let Some(article) = full_cache.peek(title) {\n                // Extract summary from full article if possible\n                return Ok(self.extract_summary(article));\n            }\n        }\n\n        // Fetch from API\n        let summary = self.fetch_summary(title).await?;\n\n        // Store in summary cache\n        {\n            let mut summary_cache = self.summary_cache.lock().await;\n            summary_cache.put(title.to_string(), summary.clone());\n        }\n\n        Ok(summary)\n    }\n\n    async fn get_article(&self, title: &str) -> Result<String> {\n        // Check full cache first\n        {\n            let mut full_cache = self.full_cache.lock().await;\n            if let Some(article) = full_cache.get(title) {\n                return Ok(article.clone());\n            }\n        }\n\n        // Fetch from API\n        let article = self.fetch_article(title).await?;\n\n        // Store in full cache\n        {\n            let mut full_cache = self.full_cache.lock().await;\n            full_cache.put(title.to_string(), article.clone());\n        }\n\n        Ok(article)\n    }\n\n    async fn fetch_summary(&self, title: &str) -> Result<String> {\n        let url = format!(\"https://en.mikipedia.org/api/{}/summary\", title);\n        let response = self.client.get(&url)\n            .send()\n            .await\n            .context(\"Failed to send summary request\")?\n            .text()\n            .await\n            .context(\"Failed to get summary text\")?;\n        Ok(response)\n    }\n\n    async fn fetch_article(&self, title: &str) -> Result<String> {\n        let url = format!(\"https://en.mikipedia.org/api/{}\", title);\n        let response = self.client.get(&url)\n            .send()\n            .await\n            .context(\"Failed to send article request\")?\n            .text()\n            .await\n            .context(\"Failed to get article text\")?;\n        Ok(response)\n    }\n\n    fn extract_summary(&self, article: &str) -> String {\n        // Simple summary extraction (first paragraph)\n        article.split('\\n').next().unwrap_or(\"\").to_string()\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Create encyclopedia service with 10 full article cache and 20 summary cache entries\n    let service = EncyclopediaService::new(10, 20);\n\n    // Example usage\n    let title = \"Rust_programming_language\";\n    \n    // Get summary\n    match service.get_summary(title).await {\n        Ok(summary) => println!(\"Summary: {}\", summary),\n        Err(e) => eprintln!(\"Error fetching summary: {}\", e),\n    }\n\n    // Get full article\n    match service.get_article(title).await {\n        Ok(article) => println!(\"Article: {}\", article),\n        Err(e) => eprintln!(\"Error fetching article: {}\", e),\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "meta-llama/llama-3.1-70b-instruct", "problem_id": "dfcef33d-f032-46a2-a10f-dc810a753508", "code": "fn quicksort(arr: Vec<i32>) -> Vec<i32> {\n    if arr.len() <= 1 {\n        return arr;\n    }\n\n    let pivot = arr[arr.len() / 2];\n    let mut left: Vec<i32> = arr.iter().cloned().filter(|&x| x < pivot).collect();\n    let mut middle: Vec<i32> = arr.iter().cloned().filter(|&x| x == pivot).collect();\n    let mut right: Vec<i32> = arr.iter().cloned().filter(|&x| x > pivot).collect();\n\n    [quicksort(left), middle, quicksort(right)].concat()\n}\n\nfn main() {\n    let numbers = vec![5, 2, 9, 4, 7, 1, 3, 6, 8];\n    let sorted_numbers = quicksort(numbers);\n    println!(\"Sorted numbers: {:?}\", sorted_numbers);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3-5-haiku", "problem_id": "02196f18-2753-4d5e-b266-046cc2c02b0c", "code": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\nuse thiserror::Error;\nuse uuid::Uuid;\nuse chrono::{DateTime, Utc};\nuse futures::future::BoxFuture;\nuse futures::FutureExt;\n\n// Custom Error Type\n#[derive(Error, Debug)]\nenum RentalError {\n    #[error(\"Item is already rented\")]\n    AlreadyRented,\n    #[error(\"Item not found\")]\n    ItemNotFound,\n    #[error(\"Rental policy violation\")]\n    PolicyViolation,\n    #[error(\"Invalid rental duration\")]\n    InvalidDuration,\n}\n\n// Rental Trait defining core rental behaviors\ntrait Rentable: Clone + Send + Sync {\n    fn get_id(&self) -> Uuid;\n    fn get_name(&self) -> String;\n}\n\n// Rental Policy Trait\ntrait RentalPolicy<T: Rentable> {\n    fn can_rent(&self, item: &T) -> Result<(), RentalError>;\n    fn max_rental_duration(&self) -> Duration;\n}\n\n// Rental Record Structure\n#[derive(Clone)]\nstruct RentalRecord<T: Rentable> {\n    item: T,\n    renter_id: Uuid,\n    rental_start: DateTime<Utc>,\n    rental_end: Option<DateTime<Utc>>,\n}\n\n// Rental System\nstruct RentalSystem<T: Rentable> {\n    inventory: Arc<Mutex<HashMap<Uuid, T>>>,\n    rentals: Arc<Mutex<Vec<RentalRecord<T>>>>,\n    policy: Arc<dyn RentalPolicy<T> + Send + Sync>,\n}\n\nimpl<T: Rentable> RentalSystem<T> {\n    fn new(policy: Arc<dyn RentalPolicy<T> + Send + Sync>) -> Self {\n        Self {\n            inventory: Arc::new(Mutex::new(HashMap::new()),\n            rentals: Arc::new(Mutex::new(Vec::new())),\n            policy,\n        }\n    }\n\n    // Async method for renting an item\n    async fn rent_item(&self, item_id: Uuid, renter_id: Uuid) -> Result<(), RentalError> {\n        let mut inventory = self.inventory.lock().map_err(|_| RentalError::PolicyViolation)?;\n        let mut rentals = self.rentals.lock().map_err(|_| RentalError::PolicyViolation)?;\n\n        let item = inventory.get(&item_id).ok_or(RentalError::ItemNotFound)?;\n\n        // Check rental policy\n        self.policy.can_rent(item)?;\n\n        // Create rental record\n        let rental_record = RentalRecord {\n            item: item.clone(),\n            renter_id,\n            rental_start: Utc::now(),\n            rental_end: None,\n        };\n\n        rentals.push(rental_record);\n        Ok(())\n    }\n\n    // Custom Iterator for Rental History\n    fn rental_history(&self) -> impl Iterator<Item = &RentalRecord<T>> {\n        self.rentals.lock().unwrap().iter()\n    }\n}\n\n// Example Movie Implementation\n#[derive(Clone)]\nstruct Movie {\n    id: Uuid,\n    title: String,\n    genre: String,\n}\n\nimpl Rentable for Movie {\n    fn get_id(&self) -> Uuid {\n        self.id\n    }\n\n    fn get_name(&self) -> String {\n        self.title.clone()\n    }\n}\n\n// Example Rental Policy\nstruct StandardRentalPolicy;\n\nimpl RentalPolicy<Movie> for StandardRentalPolicy {\n    fn can_rent(&self, _item: &Movie) -> Result<(), RentalError> {\n        Ok(())\n    }\n\n    fn max_rental_duration(&self) -> Duration {\n        Duration::from_secs(7 * 24 * 60 * 60) // 1 week\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), RentalError> {\n    // Create policy\n    let policy = Arc::new(StandardRentalPolicy);\n\n    // Create rental system\n    let rental_system = RentalSystem::new(policy);\n\n    // Create a movie\n    let movie = Movie {\n        id: Uuid::new_v4(),\n        title: \"Inception\".to_string(),\n        genre: \"Sci-Fi\".to_string(),\n    };\n\n    // Add movie to inventory\n    rental_system.inventory.lock().unwrap().insert(movie.id, movie.clone());\n\n    // Rent the movie\n    rental_system.rent_item(movie.id, Uuid::new_v4()).await?;\n\n    // Print rental history\n    for rental in rental_system.rental_history() {\n        println!(\"Rented: {}\", rental.item.get_name());\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "google/gemini-flash-1.5", "problem_id": "4c69bb31-2ecb-4874-9829-2f12501cd8a8", "code": "use anyhow::{anyhow, Result};\nuse chrono::Utc;\nuse itertools::Itertools;\nuse lru::LruCache;\nuse reqwest::{Client, StatusCode};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse tokio::sync::Mutex;\nuse url::Url;\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Article {\n    title: String,\n    summary: String,\n    full_text: String,\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum MikipediaError {\n    #[error(\"HTTP error: {0}\")]\n    HttpError(#[from] reqwest::Error),\n    #[error(\"JSON error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n    #[error(\"API error: {0}\")]\n    ApiError(String),\n    #[error(\"Invalid URL\")]\n    InvalidUrl,\n}\n\ntype MikipediaResult<T> = Result<T, MikipediaError>;\n\nasync fn fetch_article(client: &Client, title: &str) -> MikipediaResult<Article> {\n    let url = format!(\"https://en.mikipedia.org/api/{}\", title);\n    let resp = client.get(&url).send().await?;\n\n    match resp.status() {\n        StatusCode::OK => {\n            let json: Value = resp.json().await?;\n            let summary = json[\"summary\"].as_str().ok_or_else(|| {\n                anyhow!(\"Missing summary in API response: {:?}\", json)\n            })?.to_string();\n            let full_text = json[\"fulltext\"].as_str().ok_or_else(|| {\n                anyhow!(\"Missing fulltext in API response: {:?}\", json)\n            })?.to_string();\n            Ok(Article {\n                title: title.to_string(),\n                summary,\n                full_text,\n            })\n        }\n        status => Err(MikipediaError::ApiError(format!(\n            \"API request failed with status code: {}\",\n            status\n        ))),\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), MikipediaError> {\n    let client = Client::new();\n    let n_full = 10;\n    let n_summary = 20;\n\n    let full_cache = Mutex::new(LruCache::<String, Article>::new(n_full));\n    let summary_cache = Mutex::new(LruCache::<String, String>::new(n_summary));\n\n    async fn get_summary(\n        title: &str,\n        full_cache: &Mutex<LruCache<String, Article>>,\n        summary_cache: &Mutex<LruCache<String, String>>,\n        client: &Client,\n    ) -> MikipediaResult<String> {\n        let cached_summary = summary_cache.lock().await.get(title);\n        if let Some(summary) = cached_summary {\n            return Ok(summary.clone());\n        }\n\n        let cached_article = full_cache.lock().await.get(title);\n        if let Some(article) = cached_article {\n            summary_cache.lock().await.put(title.to_string(), article.summary.clone());\n            return Ok(article.summary.clone());\n        }\n\n        let article = fetch_article(client, title).await?;\n        full_cache.lock().await.put(title.to_string(), article.clone());\n        summary_cache.lock().await.put(title.to_string(), article.summary.clone());\n        Ok(article.summary)\n    }\n\n    async fn get_article(\n        title: &str,\n        full_cache: &Mutex<LruCache<String, Article>>,\n        client: &Client,\n    ) -> MikipediaResult<String> {\n        let cached_article = full_cache.lock().await.get(title);\n        if let Some(article) = cached_article {\n            return Ok(article.full_text.clone());\n        }\n\n        let article = fetch_article(client, title).await?;\n        full_cache.lock().await.put(title.to_string(), article.clone());\n        Ok(article.full_text)\n    }\n\n\n    let title = \"Rust_programming_language\";\n    let summary = get_summary(title, &full_cache, &summary_cache, &client).await?;\n    println!(\"Summary: {}\", summary);\n\n    let article = get_article(title, &full_cache, &client).await?;\n    println!(\"Article: {}\", article);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "meta-llama/llama-3.1-70b-instruct", "problem_id": "4c69bb31-2ecb-4874-9829-2f12501cd8a8", "code": "use std::collections::{HashMap, VecDeque};\nuse std::sync::{Arc, Mutex};\nuse anyhow::{Context, Result};\nuse rand::Rng;\nuse reqwest::Client;\nuse serde_json::Value;\nuse tokio;\n\ntype Cache = Arc<Mutex<HashMap<String, Value>>>;\ntype Queue = Arc<Mutex<VecDeque<String>>>;\n\nasync fn get_full_article(\n    client: &Client,\n    title: &str,\n) -> Result<Value> {\n    let url = format!(\"https://en.wikipedia.org/api/{title}\");\n    let res = client.get(url).send().await?;\n    let json = res.json::<Value>().await?;\n    Ok(json)\n}\n\nstruct EncyclopediaBackend {\n    n_full: usize,\n    n_summary: usize,\n    full_cache: Cache,\n    full_queue: Queue,\n    summary_cache: Cache,\n    summary_queue: Queue,\n    client: Client,\n}\n\nimpl EncyclopediaBackend {\n    fn new(n_full: usize, n_summary: usize) -> Self {\n        Self {\n            n_full,\n            n_summary,\n            full_cache: Arc::new(Mutex::new(HashMap::new())),\n            full_queue: Arc::new(Mutex::new(VecDeque::new())),\n            summary_cache: Arc::new(Mutex::new(HashMap::new())),\n            summary_queue: Arc::new(Mutex::new(VecDeque::new())),\n            client: Client::new(),\n        }\n    }\n\n    async fn get_summary(&self, title: &str) -> Result<String> {\n        if let Some(article) = self.full_cache.lock().unwrap().get(title) {\n            self.full_queue.lock().unwrap().remove(title);\n            self.full_queue.lock().unwrap().push_back(title.to_string());\n            return Ok(article[\"extract\"].as_str().unwrap().to_string());\n        }\n        if let Some(summary) = self.summary_cache.lock().unwrap().get(title) {\n            self.summary_queue.lock().unwrap().remove(title);\n            self.summary_queue.lock().unwrap().push_back(title.to_string());\n            return Ok(summary[\"extract\"].as_str().unwrap().to_string());\n        }\n        let article = get_full_article(&self.client, title).await?;\n        self.add_to_full_cache(title, &article).await?;\n        self.remove_from_summary_cache(title).await?;\n        Ok(article[\"extract\"].as_str().unwrap().to_string())\n    }\n\n    async fn get_article(&self, title: &str) -> Result<String> {\n        if let Some(article) = self.full_cache.lock().unwrap().get(title) {\n            self.full_queue.lock().unwrap().remove(title);\n            self.full_queue.lock().unwrap().push_back(title.to_string());\n            return Ok(article.to_string());\n        }\n        if let Some(summary) = self.summary_cache.lock().unwrap().get(title) {\n            self.summary_queue.lock().unwrap().remove(title);\n            self.summary_queue.lock().unwrap().push_back(title.to_string());\n            let article = get_full_article(&self.client, title).await?;\n            self.add_to_full_cache(title, &article).await?;\n            self.remove_from_summary_cache(title).await?;\n            return Ok(article.to_string());\n        }\n        let article = get_full_article(&self.client, title).await?;\n        self.add_to_full_cache(title, &article).await?;\n        Ok(article.to_string())\n    }\n\n    async fn add_to_full_cache(&self, title: &str, article: &Value) {\n        self.full_cache.lock().unwrap().insert(title.to_string(), article.clone());\n        self.full_queue.lock().unwrap().push_back(title.to_string());\n        if self.full_queue.lock().unwrap().len() > self.n_full {\n            let title = self.full_queue.lock().unwrap().pop_front().unwrap();\n            self.full_cache.lock().unwrap().remove(&title);\n            self.summary_cache.lock().unwrap().insert(title, article.clone());\n            self.summary_queue.lock().unwrap().push_back(title);\n            if self.summary_queue.lock().unwrap().len() > self.n_summary {\n                self.summary_queue.lock().unwrap().pop_front();\n                self.summary_cache.lock().unwrap().remove(&self.summary_queue.lock().unwrap().pop_front().unwrap());\n            }\n        }\n    }\n\n    async fn remove_from_summary_cache(&self, title: &str) {\n        if self.summary_cache.lock().unwrap().contains_key(title) {\n            self.summary_queue.lock().unwrap().remove(title);\n            self.summary_cache.lock().unwrap().remove(title);\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let backend = EncyclopediaBackend::new(10, 50);\n    println!(\"{:?}\", backend.get_summary(\"Python (programming language)\").await.unwrap());\n    println!(\"{:?}\", backend.get_article(\"Python (programming language)\").await.unwrap());\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "openai/gpt-4o-mini", "problem_id": "4c69bb31-2ecb-4874-9829-2f12501cd8a8", "code": "use anyhow::Result;\nuse reqwest::Client;\nuse serde::Deserialize;\nuse std::collections::{HashMap, VecDeque};\nuse tokio::sync::Mutex;\n\n#[derive(Deserialize)]\nstruct ArticleResponse {\n    summary: String,\n    article: String,\n}\n\nstruct LRUCache {\n    capacity_full: usize,\n    capacity_summary: usize,\n    full_cache: HashMap<String, String>,\n    summary_cache: HashMap<String, String>,\n    full_order: VecDeque<String>,\n    summary_order: VecDeque<String>,\n}\n\nimpl LRUCache {\n    fn new(capacity_full: usize, capacity_summary: usize) -> Self {\n        Self {\n            capacity_full,\n            capacity_summary,\n            full_cache: HashMap::new(),\n            summary_cache: HashMap::new(),\n            full_order: VecDeque::new(),\n            summary_order: VecDeque::new(),\n        }\n    }\n\n    fn get_full(&mut self, title: &str) -> Option<&String> {\n        if let Some(article) = self.full_cache.get(title) {\n            self.update_full_order(title);\n            Some(article)\n        } else {\n            None\n        }\n    }\n\n    fn get_summary(&mut self, title: &str) -> Option<&String> {\n        if let Some(summary) = self.summary_cache.get(title) {\n            self.update_summary_order(title);\n            Some(summary)\n        } else {\n            None\n        }\n    }\n\n    fn put_full(&mut self, title: String, article: String) {\n        if self.full_cache.len() == self.capacity_full {\n            if let Some(oldest) = self.full_order.pop_front() {\n                self.full_cache.remove(&oldest);\n            }\n        }\n        self.full_cache.insert(title.clone(), article);\n        self.full_order.push_back(title);\n    }\n\n    fn put_summary(&mut self, title: String, summary: String) {\n        if self.summary_cache.len() == self.capacity_summary {\n            if let Some(oldest) = self.summary_order.pop_front() {\n                self.summary_cache.remove(&oldest);\n            }\n        }\n        self.summary_cache.insert(title.clone(), summary);\n        self.summary_order.push_back(title);\n    }\n\n    fn update_full_order(&mut self, title: &str) {\n        if let Some(pos) = self.full_order.iter().position(|x| x == title) {\n            self.full_order.remove(pos);\n        }\n        self.full_order.push_back(title.to_string());\n    }\n\n    fn update_summary_order(&mut self, title: &str) {\n        if let Some(pos) = self.summary_order.iter().position(|x| x == title) {\n            self.summary_order.remove(pos);\n        }\n        self.summary_order.push_back(title.to_string());\n    }\n}\n\nstruct EncyclopediaService {\n    client: Client,\n    cache: Mutex<LRUCache>,\n}\n\nimpl EncyclopediaService {\n    fn new(capacity_full: usize, capacity_summary: usize) -> Self {\n        Self {\n            client: Client::new(),\n            cache: Mutex::new(LRUCache::new(capacity_full, capacity_summary)),\n        }\n    }\n\n    async fn fetch_article(&self, title: &str) -> Result<ArticleResponse> {\n        let url = format!(\"https://en.mikipedia.org/api/{}\", title);\n        let response = self.client.get(&url).send().await?.json::<ArticleResponse>().await?;\n        Ok(response)\n    }\n\n    pub async fn get_summary(&self, title: &str) -> Result<String> {\n        let mut cache = self.cache.lock().await;\n\n        if let Some(summary) = cache.get_summary(title) {\n            return Ok(summary.clone());\n        }\n\n        let response = self.fetch_article(title).await?;\n        cache.put_summary(title.to_string(), response.summary.clone());\n        cache.put_full(title.to_string(), response.article.clone());\n\n        Ok(response.summary)\n    }\n\n    pub async fn get_article(&self, title: &str) -> Result<String> {\n        let mut cache = self.cache.lock().await;\n\n        if let Some(article) = cache.get_full(title) {\n            return Ok(article.clone());\n        }\n\n        let response = self.fetch_article(title).await?;\n        cache.put_full(title.to_string(), response.article.clone());\n        cache.put_summary(title.to_string(), response.summary.clone());\n\n        Ok(response.article)\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let service = EncyclopediaService::new(5, 10); // Example capacities\n\n    let title = \"Rust_(programming_language)\";\n\n    // Fetch summary\n    match service.get_summary(title).await {\n        Ok(summary) => println!(\"Summary: {}\", summary),\n        Err(e) => eprintln!(\"Error fetching summary: {}\", e),\n    }\n\n    // Fetch full article\n    match service.get_article(title).await {\n        Ok(article) => println!(\"Article: {}\", article),\n        Err(e) => eprintln!(\"Error fetching article: {}\", e),\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3.5-sonnet", "problem_id": "4c69bb31-2ecb-4874-9829-2f12501cd8a8", "code": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse anyhow::{Result, anyhow};\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Article {\n    title: String,\n    summary: String,\n    full_content: String,\n}\n\n#[derive(Debug, Clone)]\nstruct CacheEntry {\n    article: Article,\n    last_accessed: chrono::DateTime<chrono::Utc>,\n}\n\nstruct EncyclopediaCache {\n    full_cache: HashMap<String, CacheEntry>,\n    summary_cache: HashMap<String, CacheEntry>,\n    n_full: usize,\n    n_summary: usize,\n}\n\nimpl EncyclopediaCache {\n    fn new(n_full: usize, n_summary: usize) -> Self {\n        Self {\n            full_cache: HashMap::new(),\n            summary_cache: HashMap::new(),\n            n_full,\n            n_summary,\n        }\n    }\n\n    fn update_caches(&mut self, article: Article) {\n        let now = chrono::Utc::now();\n        let entry = CacheEntry {\n            article,\n            last_accessed: now,\n        };\n\n        // If full cache is full, move least recently used to summary cache\n        if self.full_cache.len() >= self.n_full {\n            if let Some((title, _)) = self.full_cache\n                .iter()\n                .min_by_key(|(_, entry)| entry.last_accessed) {\n                let title = title.clone();\n                if let Some(entry) = self.full_cache.remove(&title) {\n                    self.summary_cache.insert(title, entry);\n                }\n            }\n        }\n\n        // If summary cache is full, remove least recently used\n        if self.summary_cache.len() >= self.n_summary {\n            if let Some((title, _)) = self.summary_cache\n                .iter()\n                .min_by_key(|(_, entry)| entry.last_accessed) {\n                let title = title.clone();\n                self.summary_cache.remove(&title);\n            }\n        }\n\n        // Add new entry to full cache\n        self.full_cache.insert(entry.article.title.clone(), entry);\n    }\n}\n\nstruct EncyclopediaService {\n    cache: Arc<Mutex<EncyclopediaCache>>,\n    client: reqwest::Client,\n}\n\nimpl EncyclopediaService {\n    fn new(n_full: usize, n_summary: usize) -> Self {\n        let client = reqwest::Client::builder()\n            .timeout(Duration::from_secs(10))\n            .build()\n            .unwrap();\n\n        Self {\n            cache: Arc::new(Mutex::new(EncyclopediaCache::new(n_full, n_summary))),\n            client,\n        }\n    }\n\n    async fn fetch_article(&self, title: &str) -> Result<Article> {\n        let url = format!(\"https://en.mikipedia.org/api/{}\", title);\n        let response = self.client.get(&url).send().await?;\n        \n        if !response.status().is_success() {\n            return Err(anyhow!(\"Failed to fetch article: {}\", response.status()));\n        }\n\n        let article: Article = response.json().await?;\n        Ok(article)\n    }\n\n    async fn get_summary(&self, title: String) -> Result<String> {\n        let mut cache = self.cache.lock().await;\n        \n        // Check full cache first\n        if let Some(entry) = cache.full_cache.get_mut(&title) {\n            entry.last_accessed = chrono::Utc::now();\n            return Ok(entry.article.summary.clone());\n        }\n\n        // Then check summary cache\n        if let Some(entry) = cache.summary_cache.get_mut(&title) {\n            entry.last_accessed = chrono::Utc::now();\n            return Ok(entry.article.summary.clone());\n        }\n\n        // Fetch from API if not in cache\n        let article = self.fetch_article(&title).await?;\n        let summary = article.summary.clone();\n        cache.update_caches(article);\n        \n        Ok(summary)\n    }\n\n    async fn get_article(&self, title: String) -> Result<Article> {\n        let mut cache = self.cache.lock().await;\n        \n        // Check full cache\n        if let Some(entry) = cache.full_cache.get_mut(&title) {\n            entry.last_accessed = chrono::Utc::now();\n            return Ok(entry.article.clone());\n        }\n\n        // Fetch from API if not in full cache\n        let article = self.fetch_article(&title).await?;\n        let result = article.clone();\n        cache.update_caches(article);\n        \n        Ok(result)\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let service = EncyclopediaService::new(100, 1000);\n\n    // Example usage\n    match service.get_summary(\"Rust_(programming_language)\".to_string()).await {\n        Ok(summary) => println!(\"Summary: {}\", summary),\n        Err(e) => println!(\"Error getting summary: {}\", e),\n    }\n\n    match service.get_article(\"Rust_(programming_language)\".to_string()).await {\n        Ok(article) => println!(\"Full article title: {}\", article.title),\n        Err(e) => println!(\"Error getting article: {}\", e),\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "openai/gpt-4o-mini", "problem_id": "02196f18-2753-4d5e-b266-046cc2c02b0c", "code": "use anyhow::{Context, Result};\nuse async_std::sync::{Arc, Mutex};\nuse chrono::{DateTime, Utc};\nuse futures::stream::{self, StreamExt};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse uuid::Uuid;\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct RentalItem {\n    id: Uuid,\n    title: String,\n}\n\n#[derive(Debug)]\nstruct RentalError(String);\n\nimpl fmt::Display for RentalError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"RentalError: {}\", self.0)\n    }\n}\n\nimpl std::error::Error for RentalError {}\n\ntrait Rentable {\n    fn rent(&self) -> Result<()>;\n    fn return_item(&self) -> Result<()>;\n}\n\n#[derive(Debug)]\nstruct RentalPolicy {\n    max_rentals: usize,\n}\n\n#[derive(Debug)]\nstruct RentalHistory {\n    item_id: Uuid,\n    rented_at: DateTime<Utc>,\n}\n\nstruct RentalSystem<T: Rentable + Send + Sync + 'static> {\n    items: Arc<Mutex<HashMap<Uuid, T>>>,\n    rental_history: Arc<Mutex<Vec<RentalHistory>>>,\n    rental_policy: RentalPolicy,\n}\n\nimpl<T: Rentable + Send + Sync + 'static> RentalSystem<T> {\n    fn new(rental_policy: RentalPolicy) -> Self {\n        RentalSystem {\n            items: Arc::new(Mutex::new(HashMap::new())),\n            rental_history: Arc::new(Mutex::new(Vec::new())),\n            rental_policy,\n        }\n    }\n\n    async fn add_item(&self, item: T) {\n        let mut items = self.items.lock().await;\n        items.insert(item.id(), item);\n    }\n\n    async fn rent_item(&self, item_id: Uuid) -> Result<()> {\n        let mut items = self.items.lock().await;\n        let item = items.get_mut(&item_id).context(\"Item not found\")?;\n        item.rent()?;\n        let mut history = self.rental_history.lock().await;\n        history.push(RentalHistory {\n            item_id,\n            rented_at: Utc::now(),\n        });\n        Ok(())\n    }\n\n    async fn return_item(&self, item_id: Uuid) -> Result<()> {\n        let mut items = self.items.lock().await;\n        let item = items.get_mut(&item_id).context(\"Item not found\")?;\n        item.return_item()?;\n        Ok(())\n    }\n\n    async fn rental_history_iter(&self) -> impl Iterator<Item = RentalHistory> {\n        let history = self.rental_history.lock().await;\n        history.clone().into_iter()\n    }\n}\n\n#[derive(Debug)]\nstruct Movie {\n    id: Uuid,\n    title: String,\n    rented: AtomicUsize,\n}\n\nimpl Movie {\n    fn new(title: String) -> Self {\n        Movie {\n            id: Uuid::new_v4(),\n            title,\n            rented: AtomicUsize::new(0),\n        }\n    }\n}\n\nimpl Rentable for Movie {\n    fn rent(&self) -> Result<()> {\n        if self.rented.load(Ordering::SeqCst) >= 1 {\n            return Err(RentalError(\"Item already rented\".to_string()).into());\n        }\n        self.rented.store(1, Ordering::SeqCst);\n        Ok(())\n    }\n\n    fn return_item(&self) -> Result<()> {\n        if self.rented.load(Ordering::SeqCst) == 0 {\n            return Err(RentalError(\"Item was not rented\".to_string()).into());\n        }\n        self.rented.store(0, Ordering::SeqCst);\n        Ok(())\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let rental_policy = RentalPolicy { max_rentals: 1 };\n    let rental_system = RentalSystem::new(rental_policy);\n\n    let movie1 = Movie::new(\"Inception\".to_string());\n    let movie2 = Movie::new(\"The Matrix\".to_string());\n\n    rental_system.add_item(movie1).await;\n    rental_system.add_item(movie2).await;\n\n    let item_id = movie1.id();\n    rental_system.rent_item(item_id).await?;\n    rental_system.return_item(item_id).await?;\n\n    let history = rental_system.rental_history_iter().await;\n    for record in history {\n        println!(\"Rented Item ID: {}, Rented At: {}\", record.item_id, record.rented_at);\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3.5-sonnet", "problem_id": "02196f18-2753-4d5e-b266-046cc2c02b0c", "code": "use std::collections::{HashMap, VecDeque};\nuse std::fmt::Debug;\nuse std::sync::Arc;\nuse thiserror::Error;\nuse tokio::sync::RwLock;\nuse chrono::{DateTime, Utc, Duration};\nuse serde::{Serialize, Deserialize};\nuse uuid::Uuid;\n\n// Custom error types\n#[derive(Error, Debug)]\npub enum RentalError {\n    #[error(\"Item {0} is not available\")]\n    ItemNotAvailable(String),\n    #[error(\"Invalid rental duration\")]\n    InvalidDuration,\n    #[error(\"Rental {0} not found\")]\n    RentalNotFound(Uuid),\n    #[error(\"Item {0} is already returned\")]\n    AlreadyReturned(Uuid),\n}\n\n// Traits\npub trait Rentable: Debug + Send + Sync {\n    fn get_id(&self) -> String;\n    fn get_name(&self) -> String;\n    fn get_daily_rate(&self) -> f64;\n}\n\n// Rental status\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RentalStatus {\n    Active,\n    Returned,\n    Overdue,\n}\n\n// Rental record\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RentalRecord<T: Rentable> {\n    id: Uuid,\n    item: T,\n    rented_at: DateTime<Utc>,\n    due_date: DateTime<Utc>,\n    returned_at: Option<DateTime<Utc>>,\n    status: RentalStatus,\n}\n\n// Rental system\npub struct RentalSystem<T: Rentable> {\n    inventory: Arc<RwLock<HashMap<String, T>>>,\n    rentals: Arc<RwLock<VecDeque<RentalRecord<T>>>>,\n}\n\n// Rental history iterator\npub struct RentalHistoryIterator<T: Rentable> {\n    rentals: VecDeque<RentalRecord<T>>,\n}\n\nimpl<T: Rentable> Iterator for RentalHistoryIterator<T> {\n    type Item = RentalRecord<T>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.rentals.pop_front()\n    }\n}\n\nimpl<T: Rentable + Clone + 'static> RentalSystem<T> {\n    pub fn new() -> Self {\n        RentalSystem {\n            inventory: Arc::new(RwLock::new(HashMap::new())),\n            rentals: Arc::new(RwLock::new(VecDeque::new())),\n        }\n    }\n\n    pub async fn add_item(&self, item: T) {\n        let mut inventory = self.inventory.write().await;\n        inventory.insert(item.get_id(), item);\n    }\n\n    pub async fn rent_item(\n        &self,\n        item_id: &str,\n        duration_days: i64,\n    ) -> Result<Uuid, RentalError> {\n        if duration_days <= 0 {\n            return Err(RentalError::InvalidDuration);\n        }\n\n        let mut inventory = self.inventory.write().await;\n        let item = inventory\n            .remove(item_id)\n            .ok_or_else(|| RentalError::ItemNotAvailable(item_id.to_string()))?;\n\n        let rental_id = Uuid::new_v4();\n        let now = Utc::now();\n        let due_date = now + Duration::days(duration_days);\n\n        let rental = RentalRecord {\n            id: rental_id,\n            item: item.clone(),\n            rented_at: now,\n            due_date,\n            returned_at: None,\n            status: RentalStatus::Active,\n        };\n\n        let mut rentals = self.rentals.write().await;\n        rentals.push_back(rental);\n\n        Ok(rental_id)\n    }\n\n    pub async fn return_item(&self, rental_id: Uuid) -> Result<f64, RentalError> {\n        let mut rentals = self.rentals.write().await;\n        let mut inventory = self.inventory.write().await;\n\n        for rental in rentals.iter_mut() {\n            if rental.id == rental_id {\n                if rental.returned_at.is_some() {\n                    return Err(RentalError::AlreadyReturned(rental_id));\n                }\n\n                let now = Utc::now();\n                rental.returned_at = Some(now);\n                rental.status = RentalStatus::Returned;\n\n                // Return item to inventory\n                inventory.insert(rental.item.get_id(), rental.item.clone());\n\n                // Calculate rental fee\n                let days = (now - rental.rented_at).num_days() as f64;\n                return Ok(days * rental.item.get_daily_rate());\n            }\n        }\n\n        Err(RentalError::RentalNotFound(rental_id))\n    }\n\n    pub async fn get_rental_history(&self) -> RentalHistoryIterator<T> {\n        let rentals = self.rentals.read().await;\n        RentalHistoryIterator {\n            rentals: rentals.clone(),\n        }\n    }\n}\n\n// Example implementation for Movie\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Movie {\n    id: String,\n    title: String,\n    daily_rate: f64,\n}\n\nimpl Rentable for Movie {\n    fn get_id(&self) -> String {\n        self.id.clone()\n    }\n\n    fn get_name(&self) -> String {\n        self.title.clone()\n    }\n\n    fn get_daily_rate(&self) -> f64 {\n        self.daily_rate\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    // Create a new rental system\n    let rental_system = RentalSystem::new();\n\n    // Add some movies\n    let movie1 = Movie {\n        id: \"M001\".to_string(),\n        title: \"The Matrix\".to_string(),\n        daily_rate: 2.99,\n    };\n    let movie2 = Movie {\n        id: \"M002\".to_string(),\n        title: \"Inception\".to_string(),\n        daily_rate: 3.99,\n    };\n\n    rental_system.add_item(movie1).await;\n    rental_system.add_item(movie2).await;\n\n    // Rent a movie\n    match rental_system.rent_item(\"M001\", 3).await {\n        Ok(rental_id) => {\n            println!(\"Successfully rented movie. Rental ID: {}\", rental_id);\n\n            // Return the movie\n            match rental_system.return_item(rental_id).await {\n                Ok(fee) => println!(\"Movie returned. Rental fee: ${:.2}\", fee),\n                Err(e) => println!(\"Error returning movie: {}\", e),\n            }\n        }\n        Err(e) => println!(\"Error renting movie: {}\", e),\n    }\n\n    // Print rental history\n    println!(\"\\nRental History:\");\n    let history = rental_system.get_rental_history().await;\n    for rental in history {\n        println!(\"- {:?}\", rental);\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "meta-llama/llama-3.1-70b-instruct", "problem_id": "02196f18-2753-4d5e-b266-046cc2c02b0c", "code": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::fmt;\n\nuse chrono::{DateTime, Utc};\nuse serde::{Serialize, Deserialize};\nuse serde_json;\nuse anyhow::{Result, Error};\nuse uuid::Uuid;\nuse tokio::sync::RwLock;\nuse futures::stream::StreamExt;\n\n// Custom error types\n#[derive(Debug, thiserror::Error)]\nenum RentalError {\n    #[error(\"Item not found\")]\n    ItemNotFound,\n    #[error(\"Item already rented\")]\n    ItemAlreadyRented,\n    #[error(\"Invalid rental policy\")]\n    InvalidRentalPolicy,\n    #[error(\"Rental period exceeded\")]\n    RentalPeriodExceeded,\n}\n\n// Rentable item trait\ntrait Rentable {\n    fn id(&self) -> Uuid;\n    fn name(&self) -> String;\n    fn rental_policy(&self) -> RentalPolicy;\n}\n\n// Rental policy enum\n#[derive(Debug, Serialize, Deserialize)]\nenum RentalPolicy {\n    Daily,\n    Weekly,\n    Monthly,\n}\n\nimpl RentalPolicy {\n    fn duration(&self) -> i64 {\n        match self {\n            RentalPolicy::Daily => 86400, // 1 day\n            RentalPolicy::Weekly => 604800, // 1 week\n            RentalPolicy::Monthly => 2592000, // 1 month\n        }\n    }\n}\n\n// Rental history entry\n#[derive(Debug, Serialize, Deserialize)]\nstruct RentalHistoryEntry {\n    item_id: Uuid,\n    rental_date: DateTime<Utc>,\n    return_date: DateTime<Utc>,\n}\n\n// Rental system\nstruct RentalSystem {\n    items: Arc<RwLock<HashMap<Uuid, Box<dyn Rentable>>>>,\n    rental_history: Arc<RwLock<Vec<RentalHistoryEntry>>>,\n}\n\nimpl RentalSystem {\n    async fn new() -> Result<Self> {\n        Ok(RentalSystem {\n            items: Arc::new(RwLock::new(HashMap::new())),\n            rental_history: Arc::new(RwLock::new(Vec::new())),\n        })\n    }\n\n    async fn add_item(&self, item: Box<dyn Rentable>) -> Result<()> {\n        self.items.write().await.insert(item.id(), item);\n        Ok(())\n    }\n\n    async fn rent_item(&self, item_id: Uuid) -> Result<()> {\n        let mut items = self.items.write().await;\n        let item = items.get(&item_id).ok_or(RentalError::ItemNotFound)?;\n        if item.rental_policy() == RentalPolicy::Daily {\n            // Check if item is already rented\n            let mut rental_history = self.rental_history.write().await;\n            if rental_history.iter().any(|entry| entry.item_id == item_id) {\n                return Err(RentalError::ItemAlreadyRented);\n            }\n        }\n        // Rent item\n        let rental_date = Utc::now();\n        let return_date = rental_date + chrono::Duration::seconds(item.rental_policy().duration());\n        rental_history.push(RentalHistoryEntry {\n            item_id,\n            rental_date,\n            return_date,\n        });\n        Ok(())\n    }\n\n    async fn return_item(&self, item_id: Uuid) -> Result<()> {\n        let mut rental_history = self.rental_history.write().await;\n        let entry = rental_history.iter_mut().find(|entry| entry.item_id == item_id).ok_or(RentalError::ItemNotFound)?;\n        if Utc::now() > entry.return_date {\n            return Err(RentalError::RentalPeriodExceeded);\n        }\n        // Return item\n        entry.return_date = Utc::now();\n        Ok(())\n    }\n\n    async fn view_rental_history(&self) -> Result<Vec<RentalHistoryEntry>> {\n        let rental_history = self.rental_history.read().await;\n        Ok(rental_history.clone())\n    }\n}\n\n// Example usage\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let rental_system = RentalSystem::new().await?;\n\n    // Create some rentable items\n    let movie = Box::new(Movie {\n        id: Uuid::new_v4(),\n        name: \"The Shawshank Redemption\".to_string(),\n        rental_policy: RentalPolicy::Daily,\n    });\n    let book = Box::new(Book {\n        id: Uuid::new_v4(),\n        name: \"To Kill a Mockingbird\".to_string(),\n        rental_policy: RentalPolicy::Weekly,\n    });\n\n    // Add items to rental system\n    rental_system.add_item(movie).await?;\n    rental_system.add_item(book).await?;\n\n    // Rent items\n    rental_system.rent_item(movie.id()).await?;\n    rental_system.rent_item(book.id()).await?;\n\n    // View rental history\n    let rental_history = rental_system.view_rental_history().await?;\n    for entry in rental_history {\n        println!(\"Item ID: {}, Rental Date: {}, Return Date: {}\", entry.item_id, entry.rental_date, entry.return_date);\n    }\n\n    Ok(())\n}\n\n// Example rentable item types\nstruct Movie {\n    id: Uuid,\n    name: String,\n    rental_policy: RentalPolicy,\n}\n\nimpl Rentable for Movie {\n    fn id(&self) -> Uuid {\n        self.id\n    }\n\n    fn name(&self) -> String {\n        self.name.clone()\n    }\n\n    fn rental_policy(&self) -> RentalPolicy {\n        self.rental_policy\n    }\n}\n\nstruct Book {\n    id: Uuid,\n    name: String,\n    rental_policy: RentalPolicy,\n}\n\nimpl Rentable for Book {\n    fn id(&self) -> Uuid {\n        self.id\n    }\n\n    fn name(&self) -> String {\n        self.name.clone()\n    }\n\n    fn rental_policy(&self) -> RentalPolicy {\n        self.rental_policy\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "qwen/qwen-2.5-coder-32b-instruct", "problem_id": "4c69bb31-2ecb-4874-9829-2f12501cd8a8", "code": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::sync::Mutex;\nuse reqwest::Client;\nuse lru::LruCache;\nuse thiserror::Error;\nuse anyhow::Result;\n\n#[derive(Error, Debug)]\nenum EncyclopediaError {\n    #[error(\"Article not found\")]\n    ArticleNotFound,\n    #[error(\"HTTP request error: {0}\")]\n    HttpError(#[from] reqwest::Error),\n    #[error(\"JSON parsing error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n}\n\n#[derive(Debug, serde::Deserialize)]\nstruct ArticleResponse {\n    summary: String,\n    full_article: String,\n}\n\nstruct Encyclopedia {\n    client: Client,\n    full_cache: Arc<Mutex<LruCache<String, String>>>,\n    summary_cache: Arc<Mutex<LruCache<String, String>>>,\n}\n\nimpl Encyclopedia {\n    fn new(n_full: usize, n_summary: usize) -> Self {\n        Self {\n            client: Client::new(),\n            full_cache: Arc::new(Mutex::new(LruCache::new(n_full))),\n            summary_cache: Arc::new(Mutex::new(LruCache::new(n_summary))),\n        }\n    }\n\n    async fn get_article(&self, title: &str) -> Result<String> {\n        let mut full_cache = self.full_cache.lock().await;\n        if let Some(article) = full_cache.get(title) {\n            return Ok(article.clone());\n        }\n\n        let mut summary_cache = self.summary_cache.lock().await;\n        if let Some(summary) = summary_cache.pop(title) {\n            full_cache.put(title.to_string(), summary.clone());\n            return Ok(summary);\n        }\n\n        let article = self.fetch_article(title).await?;\n        full_cache.put(title.to_string(), article.full_article.clone());\n        summary_cache.put(title.to_string(), article.summary);\n        Ok(article.full_article)\n    }\n\n    async fn get_summary(&self, title: &str) -> Result<String> {\n        let mut summary_cache = self.summary_cache.lock().await;\n        if let Some(summary) = summary_cache.get(title) {\n            return Ok(summary.clone());\n        }\n\n        let mut full_cache = self.full_cache.lock().await;\n        if let Some(article) = full_cache.pop(title) {\n            summary_cache.put(title.to_string(), article.clone());\n            return Ok(article);\n        }\n\n        let article = self.fetch_article(title).await?;\n        summary_cache.put(title.to_string(), article.summary.clone());\n        full_cache.put(title.to_string(), article.full_article);\n        Ok(article.summary)\n    }\n\n    async fn fetch_article(&self, title: &str) -> Result<ArticleResponse> {\n        let url = format!(\"https://en.mikipedia.org/api/{}\", title);\n        let response = self.client.get(&url).send().await?;\n        if response.status().is_success() {\n            let article: ArticleResponse = response.json().await?;\n            Ok(article)\n        } else {\n            Err(EncyclopediaError::ArticleNotFound.into())\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let encyclopedia = Encyclopedia::new(10, 20);\n\n    let title = \"Rust\";\n    let summary = encyclopedia.get_summary(title).await?;\n    println!(\"Summary of '{}': {}\", title, summary);\n\n    let full_article = encyclopedia.get_article(title).await?;\n    println!(\"Full article of '{}': {}\", title, full_article);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "deepseek/deepseek-chat", "problem_id": "dfcef33d-f032-46a2-a10f-dc810a753508", "code": "use rand::Rng;\n\nfn quicksort(arr: &mut [i32]) {\n    if arr.len() <= 1 {\n        return;\n    }\n    let pivot_index = partition(arr);\n    let (left, right) = arr.split_at_mut(pivot_index);\n    quicksort(left);\n    quicksort(&mut right[1..]);\n}\n\nfn partition(arr: &mut [i32]) -> usize {\n    let pivot_index = arr.len() / 2;\n    arr.swap(pivot_index, arr.len() - 1);\n    let mut store_index = 0;\n    for i in 0..arr.len() - 1 {\n        if arr[i] < arr[arr.len() - 1] {\n            arr.swap(i, store_index);\n            store_index += 1;\n        }\n    }\n    arr.swap(store_index, arr.len() - 1);\n    store_index\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut numbers: Vec<i32> = (0..10).map(|_| rng.gen_range(0..100)).collect();\n\n    println!(\"Unsorted array: {:?}\", numbers);\n    quicksort(&mut numbers);\n    println!(\"Sorted array: {:?}\", numbers);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "deepseek/deepseek-chat", "problem_id": "4c69bb31-2ecb-4874-9829-2f12501cd8a8", "code": "use anyhow::Result;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse futures::future::join_all;\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse uuid::Uuid;\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Article {\n    title: String,\n    summary: String,\n    content: String,\n}\n\n#[async_trait]\ntrait Encyclopedia {\n    async fn get_summary(&self, title: &str) -> Result<String>;\n    async fn get_article(&self, title: &str) -> Result<Article>;\n}\n\nstruct EncyclopediaService {\n    client: Client,\n    cache: Arc<Mutex<LruCache>>,\n}\n\nimpl EncyclopediaService {\n    fn new(n_full: usize, n_summary: usize) -> Self {\n        Self {\n            client: Client::new(),\n            cache: Arc::new(Mutex::new(LruCache::new(n_full, n_summary))),\n        }\n    }\n\n    async fn fetch_article(&self, title: &str) -> Result<Article> {\n        let url = format!(\"https://en.mikipedia.org/api/{}\", title);\n        let article: Article = self.client.get(&url).send().await?.json().await?;\n        Ok(article)\n    }\n}\n\n#[async_trait]\nimpl Encyclopedia for EncyclopediaService {\n    async fn get_summary(&self, title: &str) -> Result<String> {\n        let mut cache = self.cache.lock().await;\n        if let Some(summary) = cache.get_summary(title) {\n            return Ok(summary);\n        }\n\n        let article = self.fetch_article(title).await?;\n        cache.insert(title.to_string(), article.clone());\n        Ok(article.summary)\n    }\n\n    async fn get_article(&self, title: &str) -> Result<Article> {\n        let mut cache = self.cache.lock().await;\n        if let Some(article) = cache.get_article(title) {\n            return Ok(article);\n        }\n\n        let article = self.fetch_article(title).await?;\n        cache.insert(title.to_string(), article.clone());\n        Ok(article)\n    }\n}\n\nstruct LruCache {\n    n_full: usize,\n    n_summary: usize,\n    full_cache: HashMap<String, Article>,\n    summary_cache: HashMap<String, String>,\n    access_order: Vec<String>,\n}\n\nimpl LruCache {\n    fn new(n_full: usize, n_summary: usize) -> Self {\n        Self {\n            n_full,\n            n_summary,\n            full_cache: HashMap::new(),\n            summary_cache: HashMap::new(),\n            access_order: Vec::new(),\n        }\n    }\n\n    fn insert(&mut self, title: String, article: Article) {\n        if self.access_order.len() >= self.n_full + self.n_summary {\n            let oldest = self.access_order.remove(0);\n            if self.full_cache.contains_key(&oldest) {\n                self.full_cache.remove(&oldest);\n            } else {\n                self.summary_cache.remove(&oldest);\n            }\n        }\n\n        if self.access_order.len() < self.n_full {\n            self.full_cache.insert(title.clone(), article.clone());\n        } else {\n            self.summary_cache.insert(title.clone(), article.summary.clone());\n        }\n\n        self.access_order.push(title);\n    }\n\n    fn get_summary(&self, title: &str) -> Option<String> {\n        if let Some(summary) = self.summary_cache.get(title) {\n            return Some(summary.clone());\n        }\n        self.full_cache.get(title).map(|a| a.summary.clone())\n    }\n\n    fn get_article(&self, title: &str) -> Option<Article> {\n        self.full_cache.get(title).cloned()\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let service = EncyclopediaService::new(10, 20);\n\n    let titles = vec![\"Rust\", \"Python\", \"JavaScript\", \"C++\"];\n    let futures = titles.into_iter().map(|title| {\n        let service = service.clone();\n        tokio::spawn(async move {\n            let summary = service.get_summary(title).await?;\n            let article = service.get_article(title).await?;\n            println!(\"Summary for {}: {}\", title, summary);\n            println!(\"Article for {}: {:?}\", title, article);\n            Ok::<(), anyhow::Error>(())\n        })\n    });\n\n    join_all(futures).await;\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "deepseek/deepseek-chat", "problem_id": "02196f18-2753-4d5e-b266-046cc2c02b0c", "code": "use chrono::{DateTime, Utc};\nuse itertools::Itertools;\nuse thiserror::Error;\nuse serde::{Serialize, Deserialize};\nuse uuid::Uuid;\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse tokio::sync::RwLock;\nuse rand::Rng;\nuse reqwest::Client;\nuse futures::future::join_all;\nuse url::Url;\n\n#[derive(Debug, Error)]\npub enum RentalError {\n    #[error(\"Item not found\")]\n    ItemNotFound,\n    #[error(\"Item already rented\")]\n    ItemAlreadyRented,\n    #[error(\"Rental period expired\")]\n    RentalPeriodExpired,\n    #[error(\"Invalid rental policy\")]\n    InvalidRentalPolicy,\n    #[error(\"Network error: {0}\")]\n    NetworkError(#[from] reqwest::Error),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct RentalItem {\n    id: Uuid,\n    name: String,\n    rented: bool,\n    rental_start: Option<DateTime<Utc>>,\n    rental_end: Option<DateTime<Utc>>,\n}\n\nimpl RentalItem {\n    pub fn new(name: String) -> Self {\n        Self {\n            id: Uuid::new_v4(),\n            name,\n            rented: false,\n            rental_start: None,\n            rental_end: None,\n        }\n    }\n}\n\npub trait Rentable {\n    fn is_rented(&self) -> bool;\n    fn rent(&mut self, start: DateTime<Utc>, end: DateTime<Utc>) -> Result<(), RentalError>;\n    fn return_item(&mut self) -> Result<(), RentalError>;\n}\n\nimpl Rentable for RentalItem {\n    fn is_rented(&self) -> bool {\n        self.rented\n    }\n\n    fn rent(&mut self, start: DateTime<Utc>, end: DateTime<Utc>) -> Result<(), RentalError> {\n        if self.rented {\n            return Err(RentalError::ItemAlreadyRented);\n        }\n        if end <= start {\n            return Err(RentalError::InvalidRentalPolicy);\n        }\n        self.rented = true;\n        self.rental_start = Some(start);\n        self.rental_end = Some(end);\n        Ok(())\n    }\n\n    fn return_item(&mut self) -> Result<(), RentalError> {\n        if !self.rented {\n            return Err(RentalError::ItemNotFound);\n        }\n        self.rented = false;\n        self.rental_start = None;\n        self.rental_end = None;\n        Ok(())\n    }\n}\n\n#[derive(Debug)]\npub struct RentalSystem<T: Rentable> {\n    items: Arc<RwLock<HashMap<Uuid, T>>>,\n    history: Arc<Mutex<Vec<(Uuid, DateTime<Utc>)>>>,\n}\n\nimpl<T: Rentable + Clone> RentalSystem<T> {\n    pub fn new() -> Self {\n        Self {\n            items: Arc::new(RwLock::new(HashMap::new())),\n            history: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n\n    pub async fn add_item(&self, item: T) {\n        let mut items = self.items.write().await;\n        items.insert(item.id(), item);\n    }\n\n    pub async fn rent_item(&self, id: Uuid, start: DateTime<Utc>, end: DateTime<Utc>) -> Result<(), RentalError> {\n        let mut items = self.items.write().await;\n        let item = items.get_mut(&id).ok_or(RentalError::ItemNotFound)?;\n        item.rent(start, end)?;\n        let mut history = self.history.lock().unwrap();\n        history.push((id, start));\n        Ok(())\n    }\n\n    pub async fn return_item(&self, id: Uuid) -> Result<(), RentalError> {\n        let mut items = self.items.write().await;\n        let item = items.get_mut(&id).ok_or(RentalError::ItemNotFound)?;\n        item.return_item()?;\n        Ok(())\n    }\n\n    pub fn rental_history(&self) -> impl Iterator<Item = (Uuid, DateTime<Utc>)> {\n        let history = self.history.lock().unwrap();\n        history.clone().into_iter()\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), RentalError> {\n    let rental_system = Arc::new(RentalSystem::new());\n\n    let item1 = RentalItem::new(\"Movie 1\".to_string());\n    let item2 = RentalItem::new(\"Movie 2\".to_string());\n\n    rental_system.add_item(item1.clone()).await;\n    rental_system.add_item(item2.clone()).await;\n\n    let start = Utc::now();\n    let end = start + chrono::Duration::days(7);\n\n    rental_system.rent_item(item1.id, start, end).await?;\n    rental_system.return_item(item1.id).await?;\n\n    for (id, time) in rental_system.rental_history() {\n        println!(\"Item {} was rented at {}\", id, time);\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3-5-haiku", "problem_id": "7a8902bd-1e89-4267-a640-31a6d85a2657", "code": "fn main() {\n    let original_string = String::from(\"Hello, World!\");\n    let reversed_string = reverse_string(&original_string);\n    \n    println!(\"Original string: {}\", original_string);\n    println!(\"Reversed string: {}\", reversed_string);\n}\n\nfn reverse_string(input: &str) -> String {\n    input.chars().rev().collect()\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "openai/gpt-4o-mini", "problem_id": "7a8902bd-1e89-4267-a640-31a6d85a2657", "code": "use std::io::{self, Write};\n\nfn reverse_string(input: &str) -> String {\n    input.chars().rev().collect()\n}\n\nfn main() {\n    let mut input = String::new();\n    \n    print!(\"Enter a string to reverse: \");\n    io::stdout().flush().unwrap(); // Ensure the prompt is printed before reading input\n\n    io::stdin()\n        .read_line(&mut input)\n        .expect(\"Failed to read line\");\n\n    // Trim the newline character from the input\n    let input = input.trim();\n    let reversed = reverse_string(input);\n\n    println!(\"Reversed string: {}\", reversed);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "google/gemini-flash-1.5", "problem_id": "34fa31b7-de3c-4fd3-b6d7-06dab4853ad7", "code": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Soldier {\n    id: String,\n    superior_id: Option<String>,\n    name: String,\n    age: u32,\n    city: String,\n}\n\n#[derive(Debug)]\nstruct MilitaryHierarchy {\n    soldiers: HashMap<String, Soldier>,\n}\n\nimpl MilitaryHierarchy {\n    fn from_json(json_data: &str) -> anyhow::Result<Self> {\n        let soldiers: Vec<Soldier> = serde_json::from_str(json_data)?;\n        let mut soldiers_map = HashMap::new();\n        for soldier in soldiers {\n            soldiers_map.insert(soldier.id.clone(), soldier);\n        }\n        Ok(MilitaryHierarchy { soldiers: soldiers_map })\n    }\n\n    fn lowest_common_ancestor(&self, id1: &str, id2: &str) -> Option<String> {\n        let mut path1 = self.get_chain_of_command(id1);\n        let path2 = self.get_chain_of_command(id2);\n\n        path1.reverse();\n        let mut lca = None;\n\n        for (i, id) in path1.iter().enumerate() {\n            if path2.contains(id) {\n                lca = Some(id.clone());\n                break;\n            }\n        }\n        lca\n    }\n\n\n    fn get_chain_of_command(&self, id: &str) -> Vec<String> {\n        let mut chain = Vec::new();\n        let mut current_id = id;\n\n        while let Some(soldier) = self.soldiers.get(current_id) {\n            chain.push(soldier.id.clone());\n            current_id = match &soldier.superior_id {\n                Some(superior_id) => superior_id,\n                None => break,\n            };\n        }\n        chain\n    }\n}\n\nfn main() -> anyhow::Result<()> {\n    let json_data = r#\"[\n        {\n            \"id\": \"001\",\n            \"superior_id\": null,\n            \"name\": \"John Smith\",\n            \"age\": 45,\n            \"city\": \"New York\"\n        },\n        {\n            \"id\": \"002\",\n            \"superior_id\": \"001\",\n            \"name\": \"Jane Doe\",\n            \"age\": 35,\n            \"city\": \"Boston\"\n        },\n        {\n            \"id\": \"003\",\n            \"superior_id\": \"001\",\n            \"name\": \"Peter Jones\",\n            \"age\": 30,\n            \"city\": \"Chicago\"\n        },\n        {\n            \"id\": \"004\",\n            \"superior_id\": \"002\",\n            \"name\": \"Alice Brown\",\n            \"age\": 28,\n            \"city\": \"Los Angeles\"\n        }\n    ]\"#;\n\n    let hierarchy = MilitaryHierarchy::from_json(json_data)?;\n\n    println!(\"Lowest common ancestor of 002 and 003: {:?}\", hierarchy.lowest_common_ancestor(\"002\", \"003\"));\n    println!(\"Lowest common ancestor of 004 and 003: {:?}\", hierarchy.lowest_common_ancestor(\"004\", \"003\"));\n    println!(\"Chain of command for 004: {:?}\", hierarchy.get_chain_of_command(\"004\"));\n    println!(\"Chain of command for 001: {:?}\", hierarchy.get_chain_of_command(\"001\"));\n    println!(\"Chain of command for 005: {:?}\", hierarchy.get_chain_of_command(\"005\"));\n\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3.5-sonnet", "problem_id": "7a8902bd-1e89-4267-a640-31a6d85a2657", "code": "fn main() {\n    // Example string to reverse\n    let input = String::from(\"Hello, World!\");\n    \n    // Call the reverse function and print the result\n    let reversed = reverse_string(&input);\n    println!(\"Original string: {}\", input);\n    println!(\"Reversed string: {}\", reversed);\n}\n\nfn reverse_string(s: &str) -> String {\n    // Convert the string to chars, reverse them, and collect back into a String\n    s.chars().rev().collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_reverse_string() {\n        assert_eq!(reverse_string(\"hello\"), \"olleh\");\n        assert_eq!(reverse_string(\"rust\"), \"tsur\");\n        assert_eq!(reverse_string(\"\"), \"\");\n        assert_eq!(reverse_string(\"a\"), \"a\");\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "qwen/qwen-2.5-coder-32b-instruct", "problem_id": "7a8902bd-1e89-4267-a640-31a6d85a2657", "code": "use anyhow::Result;\nuse std::io::{self, Write};\n\nfn main() -> Result<()> {\n    // Prompt the user for input\n    print!(\"Enter a string to reverse: \");\n    io::stdout().flush()?;\n\n    // Read the input from the user\n    let mut input = String::new();\n    io::stdin().read_line(&mut input)?;\n\n    // Trim the newline character from the input\n    let input = input.trim();\n\n    // Reverse the string\n    let reversed: String = input.chars().rev().collect();\n\n    // Print the reversed string\n    println!(\"Reversed string: {}\", reversed);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "google/gemini-flash-1.5", "problem_id": "7a8902bd-1e89-4267-a640-31a6d85a2657", "code": "use std::io;\n\nfn reverse_string(s: &str) -> String {\n    s.chars().rev().collect()\n}\n\nfn main() {\n    println!(\"Enter a string:\");\n\n    let mut input = String::new();\n    io::stdin()\n        .read_line(&mut input)\n        .expect(\"Failed to read line\");\n\n    let input = input.trim(); //remove trailing newline\n    let reversed_string = reverse_string(input);\n    println!(\"Reversed string: {}\", reversed_string);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "openai/gpt-4o-mini", "problem_id": "34fa31b7-de3c-4fd3-b6d7-06dab4853ad7", "code": "use serde::{Deserialize, Serialize};\nuse serde_json::from_reader;\nuse std::collections::{HashMap, HashSet};\nuse std::fs::File;\n\n#[derive(Debug, Deserialize, Serialize)]\nstruct Soldier {\n    id: String,\n    superior_id: Option<String>,\n    name: String,\n    age: u32,\n    city: String,\n}\n\nstruct Hierarchy {\n    soldiers: HashMap<String, Soldier>,\n    tree: HashMap<String, Vec<String>>,\n}\n\nimpl Hierarchy {\n    fn new(soldiers: Vec<Soldier>) -> Self {\n        let mut soldiers_map = HashMap::new();\n        let mut tree = HashMap::new();\n\n        for soldier in soldiers {\n            soldiers_map.insert(soldier.id.clone(), soldier);\n            if let Some(superior_id) = &soldier.superior_id {\n                tree.entry(superior_id.clone()).or_default().push(soldier.id.clone());\n            }\n        }\n\n        Hierarchy {\n            soldiers: soldiers_map,\n            tree,\n        }\n    }\n\n    fn lowest_common_ancestor(&self, id1: &str, id2: &str) -> Option<String> {\n        let mut ancestors1 = self.get_ancestors(id1);\n        let mut ancestors2 = self.get_ancestors(id2);\n\n        let mut common_ancestors = HashSet::new();\n        for ancestor in ancestors1.iter() {\n            common_ancestors.insert(ancestor);\n        }\n\n        for ancestor in ancestors2.iter() {\n            if common_ancestors.contains(ancestor) {\n                return Some(ancestor.clone());\n            }\n        }\n\n        None\n    }\n\n    fn get_chain_of_command(&self, id: &str) -> Vec<String> {\n        let mut chain = Vec::new();\n        let mut current_id = Some(id.to_string());\n\n        while let Some(id) = current_id {\n            chain.push(id.clone());\n            current_id = self.soldiers.get(&id).and_then(|s| s.superior_id.clone());\n        }\n\n        chain\n    }\n\n    fn get_ancestors(&self, id: &str) -> Vec<String> {\n        let mut ancestors = Vec::new();\n        let mut current_id = Some(id.to_string());\n\n        while let Some(id) = current_id {\n            ancestors.push(id.clone());\n            current_id = self.soldiers.get(&id).and_then(|s| s.superior_id.clone());\n        }\n\n        ancestors\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Load soldiers from a JSON file\n    let file = File::open(\"soldiers.json\")?;\n    let soldiers: Vec<Soldier> = from_reader(file)?;\n\n    let hierarchy = Hierarchy::new(soldiers);\n\n    // Example usage\n    let lca = hierarchy.lowest_common_ancestor(\"002\", \"001\");\n    println!(\"Lowest Common Ancestor of 002 and 001: {:?}\", lca);\n\n    let chain = hierarchy.get_chain_of_command(\"002\");\n    println!(\"Chain of Command for 002: {:?}\", chain);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "meta-llama/llama-3.1-70b-instruct", "problem_id": "7a8902bd-1e89-4267-a640-31a6d85a2657", "code": "use std::io;\n\nfn main() {\n    println!(\"Enter a string to reverse:\");\n    let mut input = String::new();\n\n    io::stdin().read_line(&mut input)\n        .expect(\"Failed to read line\");\n\n    let reversed: String = input.trim().chars().rev().collect();\n\n    println!(\"Reversed string: {}\", reversed);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "google/gemini-flash-1.5", "problem_id": "fb9be66e-eaf4-47c5-b29a-cab2556b89f4", "code": "use chrono::{DateTime, Duration, NaiveDateTime, NaiveTime, TimeZone, Utc};\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\n#[derive(Debug)]\nstruct Meeting {\n    start: DateTime<Utc>,\n    end: DateTime<Utc>,\n    name: String,\n    attendees: i32,\n}\n\n#[derive(Debug)]\nstruct Room {\n    name: String,\n    capacity: i32,\n    maintenance_start: NaiveTime,\n    maintenance_end: NaiveTime,\n}\n\nfn parse_time(time_str: &str) -> Result<NaiveTime, chrono::ParseError> {\n    NaiveTime::parse_from_str(time_str, \"%H:%M\")\n}\n\nfn parse_datetime(datetime_str: &str) -> Result<DateTime<Utc>, chrono::ParseError> {\n    DateTime::parse_from_str(datetime_str, \"%Y-%m-%d %H:%M\")?.with_timezone(&Utc)\n}\n\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let file = File::open(\"input.txt\")?;\n    let reader = BufReader::new(file);\n\n    let mut meetings: Vec<Meeting> = Vec::new();\n    let mut rooms: Vec<Room> = Vec::new();\n\n    let mut section = 0; // 0: meetings, 1: rooms\n\n    for line in reader.lines() {\n        let line = line?;\n        let parts: Vec<&str> = line.split_whitespace().collect();\n\n        if line.starts_with(\"Room\") {\n            section = 1;\n            continue;\n        }\n\n        match section {\n            0 => {\n                let start = parse_datetime(parts[0])?;\n                let end = parse_datetime(parts[1])?;\n                let name = parts[2].to_string();\n                let attendees = parts[3].parse()?;\n                meetings.push(Meeting { start, end, name, attendees });\n            }\n            1 => {\n                let name = parts[0].to_string();\n                let capacity = parts[1].parse()?;\n                let maintenance = parts[2].split('-').collect::<Vec<&str>>();\n                let maintenance_start = parse_time(maintenance[0])?;\n                let maintenance_end = parse_time(maintenance[1])?;\n                rooms.push(Room { name, capacity, maintenance_start, maintenance_end });\n            }\n            _ => unreachable!(),\n        }\n    }\n\n    let mut room_assignments: Vec<(String, Vec<Meeting>)> = Vec::new();\n    let mut unassigned_meetings: Vec<Meeting> = Vec::new();\n\n    for meeting in meetings {\n        let mut assigned = false;\n        for (room_index, (room_name, assigned_meetings)) in room_assignments.iter_mut().enumerate() {\n            let room = rooms.iter().find(|r| r.name == *room_name).unwrap();\n            let mut can_assign = true;\n\n            // Check capacity\n            if meeting.attendees > room.capacity {\n                can_assign = false;\n            }\n\n            // Check for overlaps\n            for assigned_meeting in assigned_meetings {\n                if meeting.start < assigned_meeting.end && meeting.end > assigned_meeting.start {\n                    can_assign = false;\n                }\n            }\n\n            // Check maintenance\n            let meeting_date = meeting.start.date();\n            let meeting_time = meeting.start.time();\n            let maintenance_start = DateTime::<Utc>::from_utc(NaiveDateTime::new(meeting_date.and_hms(room.maintenance_start.hour(), room.maintenance_start.minute(), 0), Utc.fix()), Utc);\n            let maintenance_end = DateTime::<Utc>::from_utc(NaiveDateTime::new(meeting_date.and_hms(room.maintenance_end.hour(), room.maintenance_end.minute(), 0), Utc.fix()), Utc);\n\n            if meeting.start < maintenance_end && meeting.end > maintenance_start {\n                can_assign = false;\n            }\n\n            if can_assign {\n                assigned_meetings.push(meeting.clone());\n                assigned = true;\n                break;\n            }\n        }\n        if !assigned {\n            unassigned_meetings.push(meeting);\n        }\n    }\n\n    println!(\"{}\", room_assignments.len());\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3-5-haiku", "problem_id": "34fa31b7-de3c-4fd3-b6d7-06dab4853ad7", "code": "use serde::{Deserialize, Serialize};\nuse serde_json;\nuse std::collections::{HashMap, HashSet};\nuse std::fs;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\nstruct Soldier {\n    id: String,\n    superior_id: Option<String>,\n    name: String,\n    age: u32,\n    city: String,\n}\n\n#[derive(Debug)]\nstruct MilitaryHierarchy {\n    soldiers: HashMap<String, Soldier>,\n    hierarchy: HashMap<String, Vec<String>>,\n}\n\nimpl MilitaryHierarchy {\n    fn new(soldiers: Vec<Soldier>) -> Self {\n        let mut hierarchy_map: HashMap<String, Vec<String>> = HashMap::new();\n        let mut soldiers_map: HashMap<String, Soldier> = HashMap::new();\n\n        for soldier in soldiers {\n            soldiers_map.insert(soldier.id.clone(), soldier.clone());\n\n            if let Some(superior_id) = &soldier.superior_id {\n                hierarchy_map\n                    .entry(superior_id.clone())\n                    .or_default()\n                    .push(soldier.id.clone());\n            }\n        }\n\n        Self {\n            soldiers: soldiers_map,\n            hierarchy: hierarchy_map,\n        }\n    }\n\n    fn lowest_common_ancestor(&self, id1: &str, id2: &str) -> Option<String> {\n        let chain1 = self.get_chain_of_command(id1);\n        let chain2 = self.get_chain_of_command(id2);\n\n        if chain1.is_empty() || chain2.is_empty() {\n            return None;\n        }\n\n        let chain1_set: HashSet<&String> = chain1.iter().collect();\n        chain2.iter().find(|&id| chain1_set.contains(id)).cloned()\n    }\n\n    fn get_chain_of_command(&self, id: &str) -> Vec<String> {\n        let mut chain = Vec::new();\n        let mut current_id = Some(id.to_string());\n\n        while let Some(soldier_id) = current_id {\n            if let Some(soldier) = self.soldiers.get(&soldier_id) {\n                chain.push(soldier_id.clone());\n                current_id = soldier.superior_id.clone();\n            } else {\n                break;\n            }\n        }\n\n        chain\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Read JSON file\n    let json_content = fs::read_to_string(\"military_hierarchy.json\")?;\n    let soldiers: Vec<Soldier> = serde_json::from_str(&json_content)?;\n\n    let hierarchy = MilitaryHierarchy::new(soldiers);\n\n    // Example usage\n    let lca = hierarchy.lowest_common_ancestor(\"002\", \"003\");\n    println!(\"Lowest Common Ancestor: {:?}\", lca);\n\n    let chain = hierarchy.get_chain_of_command(\"002\");\n    println!(\"Chain of Command: {:?}\", chain);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "openai/gpt-4o-mini", "problem_id": "fb9be66e-eaf4-47c5-b29a-cab2556b89f4", "code": "use chrono::{DateTime, Duration, NaiveDateTime, TimeZone, Utc};\nuse serde::Deserialize;\nuse std::collections::{HashMap, HashSet};\nuse std::fs::File;\nuse std::io::{self, BufRead};\nuse std::path::Path;\n\n#[derive(Debug, Deserialize)]\nstruct Meeting {\n    start: DateTime<Utc>,\n    end: DateTime<Utc>,\n    name: String,\n    attendees: usize,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Room {\n    name: String,\n    capacity: usize,\n    maintenance_start: DateTime<Utc>,\n    maintenance_end: DateTime<Utc>,\n}\n\nfn parse_meeting(line: &str) -> Option<Meeting> {\n    let parts: Vec<&str> = line.split_whitespace().collect();\n    if parts.len() != 5 {\n        return None;\n    }\n    let start = NaiveDateTime::parse_from_str(parts[0], \"%Y-%m-%d %H:%M\")\n        .ok()?\n        .and_utc();\n    let end = NaiveDateTime::parse_from_str(parts[1], \"%Y-%m-%d %H:%M\")\n        .ok()?\n        .and_utc();\n    let name = parts[2].to_string();\n    let attendees = parts[3].parse().ok()?;\n    \n    Some(Meeting { start, end, name, attendees })\n}\n\nfn parse_room(line: &str) -> Option<Room> {\n    let parts: Vec<&str> = line.split_whitespace().collect();\n    if parts.len() != 4 {\n        return None;\n    }\n    let name = parts[0].to_string();\n    let capacity = parts[1].parse().ok()?;\n    \n    let maintenance_times: Vec<&str> = parts[2].split('-').collect();\n    if maintenance_times.len() != 2 {\n        return None;\n    }\n    \n    let maintenance_start = NaiveDateTime::parse_from_str(&format!(\"2023-01-01 {}\", maintenance_times[0]), \"%Y-%m-%d %H:%M\").ok()?.and_utc();\n    let maintenance_end = NaiveDateTime::parse_from_str(&format!(\"2023-01-01 {}\", maintenance_times[1]), \"%Y-%m-%d %H:%M\").ok()?.and_utc();\n    \n    Some(Room { name, capacity, maintenance_start, maintenance_end })\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let path = \"input.txt\"; // Change this to your input file path\n    let file = File::open(path)?;\n    let reader = io::BufReader::new(file);\n    \n    let mut meetings: Vec<Meeting> = Vec::new();\n    let mut rooms: Vec<Room> = Vec::new();\n    let mut is_meeting_section = true;\n\n    for line in reader.lines() {\n        let line = line?;\n        if line.is_empty() {\n            is_meeting_section = false;\n            continue;\n        }\n        \n        if is_meeting_section {\n            if let Some(meeting) = parse_meeting(&line) {\n                meetings.push(meeting);\n            }\n        } else {\n            if let Some(room) = parse_room(&line) {\n                rooms.push(room);\n            }\n        }\n    }\n\n    let mut room_usage: HashMap<String, Vec<(DateTime<Utc>, DateTime<Utc>)>> = HashMap::new();\n\n    for meeting in meetings {\n        for room in &rooms {\n            if room.capacity >= meeting.attendees\n                && !is_overlapping_with_maintenance(&meeting, room)\n                && !is_overlapping_with_meetings(&meeting, &room_usage.get(&room.name).unwrap_or(&vec![])) {\n                room_usage.entry(room.name.clone()).or_default().push((meeting.start, meeting.end));\n                break; // Room found for this meeting\n            }\n        }\n    }\n\n    let required_rooms = room_usage.len();\n    println!(\"{}\", required_rooms);\n    Ok(())\n}\n\nfn is_overlapping_with_maintenance(meeting: &Meeting, room: &Room) -> bool {\n    (meeting.start < room.maintenance_end && meeting.end > room.maintenance_start)\n}\n\nfn is_overlapping_with_meetings(meeting: &Meeting, scheduled: &[(DateTime<Utc>, DateTime<Utc>)]) -> bool {\n    for (start, end) in scheduled {\n        if (meeting.start < *end && meeting.end > *start) {\n            return true;\n        }\n    }\n    false\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3-5-haiku", "problem_id": "fb9be66e-eaf4-47c5-b29a-cab2556b89f4", "code": "use std::fs::File;\nuse std::io::{BufRead, BufReader};\nuse std::collections::{BinaryHeap, HashMap};\nuse chrono::{NaiveDateTime, NaiveTime};\nuse std::cmp::Reverse;\n\n#[derive(Debug, Clone)]\nstruct Meeting {\n    start: NaiveDateTime,\n    end: NaiveDateTime,\n    name: String,\n    attendees: usize,\n}\n\n#[derive(Debug, Clone)]\nstruct Room {\n    name: String,\n    capacity: usize,\n    maintenance_start: NaiveTime,\n    maintenance_end: NaiveTime,\n}\n\nfn parse_input(filename: &str) -> (Vec<Meeting>, Vec<Room>) {\n    let file = File::open(filename).expect(\"Unable to open file\");\n    let reader = BufReader::new(file);\n    let lines: Vec<String> = reader.lines().map(|l| l.unwrap()).collect();\n    \n    let mut meetings = Vec::new();\n    let mut rooms = Vec::new();\n    \n    let mut parsing_meetings = true;\n    \n    for line in lines {\n        if line.is_empty() {\n            parsing_meetings = false;\n            continue;\n        }\n        \n        if parsing_meetings {\n            let parts: Vec<&str> = line.split_whitespace().collect();\n            if parts.len() == 5 {\n                let start = NaiveDateTime::parse_from_str(\n                    &format!(\"{} {}\", parts[0], parts[1]), \n                    \"%Y-%m-%d %H:%M\"\n                ).expect(\"Invalid meeting start time\");\n                \n                let end = NaiveDateTime::parse_from_str(\n                    &format!(\"{} {}\", parts[0], parts[2]), \n                    \"%Y-%m-%d %H:%M\"\n                ).expect(\"Invalid meeting end time\");\n                \n                meetings.push(Meeting {\n                    start,\n                    end,\n                    name: parts[3].to_string(),\n                    attendees: parts[4].parse().expect(\"Invalid attendee count\"),\n                });\n            }\n        } else {\n            let parts: Vec<&str> = line.split_whitespace().collect();\n            if parts.len() == 3 {\n                let maintenance_times: Vec<&str> = parts[2].split('-').collect();\n                \n                rooms.push(Room {\n                    name: parts[0].to_string(),\n                    capacity: parts[1].parse().expect(\"Invalid room capacity\"),\n                    maintenance_start: NaiveTime::parse_from_str(maintenance_times[0], \"%H:%M\")\n                        .expect(\"Invalid maintenance start time\"),\n                    maintenance_end: NaiveTime::parse_from_str(maintenance_times[1], \"%H:%M\")\n                        .expect(\"Invalid maintenance end time\"),\n                });\n            }\n        }\n    }\n    \n    (meetings, rooms)\n}\n\nfn calculate_min_rooms(mut meetings: Vec<Meeting>, rooms: Vec<Room>) -> usize {\n    // Sort meetings by start time\n    meetings.sort_by_key(|m| m.start);\n    \n    // Filter meetings that can be accommodated by rooms\n    let meetings: Vec<Meeting> = meetings.into_iter()\n        .filter(|meeting| \n            rooms.iter().any(|room| \n                room.capacity >= meeting.attendees\n            )\n        )\n        .collect();\n    \n    // Track room usage\n    let mut max_rooms = 0;\n    let mut active_meetings: BinaryHeap<Reverse<NaiveDateTime>> = BinaryHeap::new();\n    \n    for meeting in meetings {\n        // Remove meetings that have ended\n        while let Some(Reverse(end_time)) = active_meetings.peek() {\n            if *end_time <= meeting.start {\n                active_meetings.pop();\n            } else {\n                break;\n            }\n        }\n        \n        // Check if meeting can be scheduled in any room\n        let can_schedule = rooms.iter().any(|room| \n            room.capacity >= meeting.attendees &&\n            !(meeting.start.time() >= room.maintenance_start && \n              meeting.start.time() < room.maintenance_end) &&\n            !(meeting.end.time() > room.maintenance_start && \n              meeting.end.time() <= room.maintenance_end)\n        );\n        \n        if can_schedule {\n            active_meetings.push(Reverse(meeting.end));\n            max_rooms = max_rooms.max(active_meetings.len());\n        }\n    }\n    \n    max_rooms\n}\n\nfn main() {\n    let filename = \"meetings.txt\";  // Assume input is in this file\n    let (meetings, rooms) = parse_input(filename);\n    \n    let min_rooms = calculate_min_rooms(meetings, rooms);\n    println!(\"Minimum rooms required: {}\", min_rooms);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "qwen/qwen-2.5-coder-32b-instruct", "problem_id": "fb9be66e-eaf4-47c5-b29a-cab2556b89f4", "code": "use chrono::{DateTime, Duration, NaiveTime, NaiveDateTime, Utc};\nuse std::collections::{HashMap, BTreeMap};\nuse std::fs::File;\nuse std::io::{self, BufRead, BufReader};\nuse std::cmp::max;\n\n#[derive(Debug)]\nstruct Meeting {\n    start: DateTime<Utc>,\n    end: DateTime<Utc>,\n    name: String,\n    attendees: u32,\n}\n\n#[derive(Debug)]\nstruct Room {\n    name: String,\n    capacity: u32,\n    maintenance_start: NaiveTime,\n    maintenance_end: NaiveTime,\n}\n\nfn parse_time(s: &str) -> NaiveTime {\n    NaiveTime::parse_from_str(s, \"%H:%M\").unwrap()\n}\n\nfn parse_datetime(s: &str) -> DateTime<Utc> {\n    DateTime::<Utc>::from_utc(NaiveDateTime::parse_from_str(s, \"%Y-%m-%d %H:%M\").unwrap(), Utc)\n}\n\nfn parse_meeting(line: &str) -> Meeting {\n    let parts: Vec<&str> = line.split_whitespace().collect();\n    Meeting {\n        start: parse_datetime(&format!(\"{} {}\", parts[0], parts[1])),\n        end: parse_datetime(&format!(\"{} {}\", parts[2], parts[3])),\n        name: parts[4].to_string(),\n        attendees: parts[5].parse().unwrap(),\n    }\n}\n\nfn parse_room(line: &str) -> Room {\n    let parts: Vec<&str> = line.split_whitespace().collect();\n    let maintenance_parts: Vec<&str> = parts[2].split('-').collect();\n    Room {\n        name: parts[0].to_string(),\n        capacity: parts[1].parse().unwrap(),\n        maintenance_start: parse_time(maintenance_parts[0]),\n        maintenance_end: parse_time(maintenance_parts[1]),\n    }\n}\n\nfn is_maintenance_time(room: &Room, time: NaiveTime) -> bool {\n    if room.maintenance_start < room.maintenance_end {\n        time >= room.maintenance_start && time < room.maintenance_end\n    } else {\n        time >= room.maintenance_start || time < room.maintenance_end\n    }\n}\n\nfn can_schedule_room(room: &Room, meeting: &Meeting) -> bool {\n    !is_maintenance_time(room, meeting.start.time())\n        && !is_maintenance_time(room, meeting.end.time())\n        && room.capacity >= meeting.attendees\n}\n\nfn main() -> io::Result<()> {\n    let file = File::open(\"input.txt\")?;\n    let reader = BufReader::new(file);\n\n    let mut meetings = Vec::new();\n    let mut rooms = Vec::new();\n    let mut parsing_rooms = false;\n\n    for line in reader.lines() {\n        let line = line?;\n        if line.is_empty() {\n            parsing_rooms = true;\n            continue;\n        }\n        if parsing_rooms {\n            rooms.push(parse_room(&line));\n        } else {\n            meetings.push(parse_meeting(&line));\n        }\n    }\n\n    // Sort meetings by start time\n    meetings.sort_by(|a, b| a.start.cmp(&b.start));\n\n    // Track room availability\n    let mut room_availability: HashMap<String, DateTime<Utc>> = rooms.iter().map(|r| (r.name.clone(), Utc::now())).collect();\n\n    // Track room usage\n    let mut room_usage: HashMap<String, Vec<Meeting>> = rooms.iter().map(|r| (r.name.clone(), Vec::new())).collect();\n\n    for meeting in meetings {\n        let mut scheduled = false;\n        for room in &rooms {\n            if can_schedule_room(room, &meeting) && room_availability[&room.name] <= meeting.start {\n                room_availability.insert(room.name.clone(), meeting.end);\n                room_usage.get_mut(&room.name).unwrap().push(meeting.clone());\n                scheduled = true;\n                break;\n            }\n        }\n        if !scheduled {\n            // Meeting cannot be scheduled, ignore it\n        }\n    }\n\n    // Calculate the minimum number of rooms required\n    let mut min_rooms = 0;\n    for room in &rooms {\n        let mut timeline = BTreeMap::new();\n        for meeting in room_usage[&room.name].clone() {\n            *timeline.entry(meeting.start).or_insert(0) += 1;\n            *timeline.entry(meeting.end).or_insert(0) -= 1;\n        }\n\n        let mut current_rooms = 0;\n        let mut max_rooms = 0;\n        for &count in timeline.values() {\n            current_rooms += count;\n            max_rooms = max(max_rooms, current_rooms);\n        }\n\n        min_rooms = max(min_rooms, max_rooms);\n    }\n\n    println!(\"{}\", min_rooms);\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3.5-sonnet", "problem_id": "34fa31b7-de3c-4fd3-b6d7-06dab4853ad7", "code": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::BufReader;\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Soldier {\n    id: String,\n    superior_id: Option<String>,\n    name: String,\n    age: u32,\n    city: String,\n}\n\n#[derive(Debug)]\nstruct MilitaryHierarchy {\n    soldiers: HashMap<String, Soldier>,\n}\n\nimpl MilitaryHierarchy {\n    fn new(soldiers: Vec<Soldier>) -> Self {\n        let soldiers_map = soldiers.into_iter().map(|s| (s.id.clone(), s)).collect();\n        MilitaryHierarchy {\n            soldiers: soldiers_map,\n        }\n    }\n\n    fn get_chain_of_command(&self, id: &str) -> Vec<String> {\n        let mut chain = Vec::new();\n        let mut current_id = id.to_string();\n\n        // Check if the initial soldier exists\n        if !self.soldiers.contains_key(&current_id) {\n            return chain;\n        }\n\n        while let Some(soldier) = self.soldiers.get(&current_id) {\n            chain.push(current_id.clone());\n            \n            if let Some(sup_id) = &soldier.superior_id {\n                current_id = sup_id.clone();\n            } else {\n                break;\n            }\n        }\n\n        chain\n    }\n\n    fn lowest_common_ancestor(&self, id1: &str, id2: &str) -> Option<String> {\n        let chain1 = self.get_chain_of_command(id1);\n        let chain2 = self.get_chain_of_command(id2);\n\n        if chain1.is_empty() || chain2.is_empty() {\n            return None;\n        }\n\n        let chain1_set: HashMap<_, _> = chain1.iter().enumerate().collect();\n\n        for (idx, id) in chain2.iter().enumerate() {\n            if let Some(&chain1_idx) = chain1_set.get(id) {\n                // Return the ID that appears in both chains with the highest combined depth\n                if chain1_idx + idx < chain1.len() + chain2.len() {\n                    return Some(id.clone());\n                }\n            }\n        }\n\n        None\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Example JSON data\n    let json_data = r#\"\n    [\n        {\n            \"id\": \"001\",\n            \"superior_id\": null,\n            \"name\": \"John Smith\",\n            \"age\": 45,\n            \"city\": \"New York\"\n        },\n        {\n            \"id\": \"002\",\n            \"superior_id\": \"001\",\n            \"name\": \"Jane Doe\",\n            \"age\": 35,\n            \"city\": \"Boston\"\n        },\n        {\n            \"id\": \"003\",\n            \"superior_id\": \"001\",\n            \"name\": \"Bob Johnson\",\n            \"age\": 40,\n            \"city\": \"Chicago\"\n        },\n        {\n            \"id\": \"004\",\n            \"superior_id\": \"002\",\n            \"name\": \"Alice Brown\",\n            \"age\": 30,\n            \"city\": \"Miami\"\n        }\n    ]\"#;\n\n    // Parse JSON data\n    let soldiers: Vec<Soldier> = serde_json::from_str(json_data)?;\n    let hierarchy = MilitaryHierarchy::new(soldiers);\n\n    // Test chain of command\n    println!(\"Chain of command for soldier 004:\");\n    let chain = hierarchy.get_chain_of_command(\"004\");\n    println!(\"{:?}\", chain);\n\n    // Test lowest common ancestor\n    println!(\"\\nLowest common ancestor for soldiers 003 and 004:\");\n    if let Some(ancestor) = hierarchy.lowest_common_ancestor(\"003\", \"004\") {\n        println!(\"Found ancestor: {}\", ancestor);\n    } else {\n        println!(\"No common ancestor found\");\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "anthropic/claude-3.5-sonnet", "problem_id": "fb9be66e-eaf4-47c5-b29a-cab2556b89f4", "code": "use chrono::{NaiveDateTime, NaiveTime};\nuse std::fs::File;\nuse std::io::{self, BufRead};\nuse std::collections::HashMap;\n\n#[derive(Debug)]\nstruct Meeting {\n    start: NaiveDateTime,\n    end: NaiveDateTime,\n    name: String,\n    attendees: i32,\n}\n\n#[derive(Debug)]\nstruct Room {\n    name: String,\n    capacity: i32,\n    maintenance_start: NaiveTime,\n    maintenance_end: NaiveTime,\n}\n\nfn parse_datetime(date_str: &str, time_str: &str) -> NaiveDateTime {\n    let datetime_str = format!(\"{} {}\", date_str, time_str);\n    NaiveDateTime::parse_from_str(&datetime_str, \"%Y-%m-%d %H:%M\").unwrap()\n}\n\nfn parse_time(time_str: &str) -> NaiveTime {\n    NaiveTime::parse_from_str(time_str, \"%H:%M\").unwrap()\n}\n\nfn is_during_maintenance(meeting: &Meeting, room: &Room) -> bool {\n    let meeting_start_time = meeting.start.time();\n    let meeting_end_time = meeting.end.time();\n    \n    // Check if meeting overlaps with maintenance period\n    if room.maintenance_start < room.maintenance_end {\n        // Maintenance period doesn't cross midnight\n        !(meeting_end_time <= room.maintenance_start || meeting_start_time >= room.maintenance_end)\n    } else {\n        // Maintenance period crosses midnight\n        !(meeting_end_time <= room.maintenance_start && meeting_start_time >= room.maintenance_end)\n    }\n}\n\nfn can_schedule_meeting(meeting: &Meeting, room: &Room, scheduled_meetings: &Vec<Meeting>) -> bool {\n    // Check capacity\n    if meeting.attendees > room.capacity {\n        return false;\n    }\n\n    // Check maintenance period\n    if is_during_maintenance(meeting, room) {\n        return false;\n    }\n\n    // Check overlap with other meetings\n    for scheduled in scheduled_meetings {\n        if meeting.start < scheduled.end && scheduled.start < meeting.end {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn calculate_min_rooms(meetings: Vec<Meeting>, rooms: Vec<Room>) -> i32 {\n    let mut room_schedules: HashMap<String, Vec<Meeting>> = HashMap::new();\n    let mut required_rooms = 0;\n\n    // Sort meetings by start time\n    let mut sorted_meetings = meetings;\n    sorted_meetings.sort_by_key(|m| m.start);\n\n    'meeting_loop: for meeting in sorted_meetings {\n        // Try to schedule in existing rooms\n        for room in &rooms {\n            if let Some(schedule) = room_schedules.get(&room.name) {\n                if can_schedule_meeting(&meeting, room, schedule) {\n                    room_schedules.get_mut(&room.name).unwrap().push(meeting);\n                    continue 'meeting_loop;\n                }\n            } else {\n                // New room\n                if can_schedule_meeting(&meeting, room, &vec![]) {\n                    room_schedules.insert(room.name.clone(), vec![meeting]);\n                    required_rooms += 1;\n                    continue 'meeting_loop;\n                }\n            }\n        }\n    }\n\n    required_rooms\n}\n\nfn main() -> io::Result<()> {\n    let file = File::open(\"meetings.txt\")?;\n    let reader = io::BufReader::new(file);\n    let lines: Vec<String> = reader.lines().collect::<Result<_, _>>()?;\n\n    let mut meetings = Vec::new();\n    let mut rooms = Vec::new();\n    let mut parsing_rooms = false;\n\n    for line in lines {\n        let parts: Vec<&str> = line.split_whitespace().collect();\n        \n        if parts.is_empty() {\n            parsing_rooms = true;\n            continue;\n        }\n\n        if !parsing_rooms {\n            if parts.len() == 6 {\n                meetings.push(Meeting {\n                    start: parse_datetime(parts[0], parts[1]),\n                    end: parse_datetime(parts[2], parts[3]),\n                    name: parts[4].to_string(),\n                    attendees: parts[5].parse().unwrap(),\n                });\n            }\n        } else {\n            if parts.len() == 3 {\n                let maintenance_times: Vec<&str> = parts[2].split('-').collect();\n                rooms.push(Room {\n                    name: parts[0].to_string(),\n                    capacity: parts[1].parse().unwrap(),\n                    maintenance_start: parse_time(maintenance_times[0]),\n                    maintenance_end: parse_time(maintenance_times[1]),\n                });\n            }\n        }\n    }\n\n    let result = calculate_min_rooms(meetings, rooms);\n    println!(\"Minimum number of required rooms: {}\", result);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "meta-llama/llama-3.1-70b-instruct", "problem_id": "34fa31b7-de3c-4fd3-b6d7-06dab4853ad7", "code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::Read;\nuse serde_json::Value;\n\n// Define a struct to represent a soldier\n#[derive(Debug, PartialEq, Eq)]\nstruct Soldier {\n    id: String,\n    superior_id: Option<String>,\n    name: String,\n    age: u32,\n    city: String,\n}\n\n// Define a struct to represent the military hierarchy\n#[derive(Debug)]\nstruct Hierarchy {\n    soldiers: HashMap<String, Soldier>,\n    tree: HashMap<String, Vec<String>>,\n}\n\nimpl Hierarchy {\n    // Create a new hierarchy from a JSON file\n    fn new(file_path: &str) -> Result<Self, std::io::Error> {\n        let mut file = File::open(file_path)?;\n        let mut json = String::new();\n        file.read_to_string(&mut json)?;\n        let json: Value = serde_json::from_str(&json)?;\n        let mut soldiers = HashMap::new();\n        let mut tree = HashMap::new();\n\n        for soldier in json.as_array().unwrap() {\n            let id = soldier[\"id\"].as_str().unwrap().to_string();\n            let superior_id = soldier[\"superior_id\"].as_str().map(|s| s.to_string());\n            let name = soldier[\"name\"].as_str().unwrap().to_string();\n            let age = soldier[\"age\"].as_u64().unwrap() as u32;\n            let city = soldier[\"city\"].as_str().unwrap().to_string();\n\n            soldiers.insert(id.clone(), Soldier {\n                id,\n                superior_id,\n                name,\n                age,\n                city,\n            });\n\n            if let Some(superior_id) = superior_id {\n                tree.entry(superior_id).or_insert(Vec::new()).push(id.clone());\n            }\n        }\n\n        Ok(Hierarchy { soldiers, tree })\n    }\n\n    // Find the lowest common superior in the hierarchy between two given soldiers\n    fn lowest_common_ancestor(&self, id1: &str, id2: &str) -> Option<String> {\n        let mut ancestors1 = self.get_chain_of_command(id1);\n        let mut ancestors2 = self.get_chain_of_command(id2);\n\n        ancestors1.reverse();\n        ancestors2.reverse();\n\n        for (a1, a2) in ancestors1.iter().zip(ancestors2.iter()) {\n            if a1 == a2 {\n                return Some(a1.clone());\n            }\n        }\n\n        None\n    }\n\n    // Return a vector of IDs representing the chain of command from the given soldier up to the top of the hierarchy\n    fn get_chain_of_command(&self, id: &str) -> Vec<String> {\n        let mut chain = Vec::new();\n        let mut current_id = id.to_string();\n\n        while let Some(soldier) = self.soldiers.get(&current_id) {\n            chain.push(current_id.clone());\n            if let Some(superior_id) = &soldier.superior_id {\n                current_id = superior_id.clone();\n            } else {\n                break;\n            }\n        }\n\n        chain\n    }\n}\n\nfn main() -> Result<(), std::io::Error> {\n    let hierarchy = Hierarchy::new(\"hierarchy.json\")?;\n\n    println!(\"Lowest common ancestor of 001 and 002: {:?}\", hierarchy.lowest_common_ancestor(\"001\", \"002\"));\n    println!(\"Chain of command for 002: {:?}\", hierarchy.get_chain_of_command(\"002\"));\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "meta-llama/llama-3.1-70b-instruct", "problem_id": "fb9be66e-eaf4-47c5-b29a-cab2556b89f4", "code": "use std::collections::BTreeMap;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\nuse std::path::Path;\n\nuse chrono::{DateTime, Duration, Local, NaiveDateTime, ParseError};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize)]\nstruct Meeting {\n    start: DateTime<Local>,\n    end: DateTime<Local>,\n    name: String,\n    attendees: u32,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\nstruct Room {\n    name: String,\n    capacity: u32,\n    maintenance: (DateTime<Local>, DateTime<Local>),\n}\n\nfn parse_time(time_str: &str) -> Result<DateTime<Local>, ParseError> {\n    let naive_time = NaiveDateTime::parse_from_str(time_str, \"%Y-%m-%d %H:%M\")?;\n    Ok(DateTime::from_local(naive_time, Local))\n}\n\nfn parse_maintenance(maintenance_str: &str) -> Result<(DateTime<Local>, DateTime<Local>), ParseError> {\n    let mut parts = maintenance_str.split('-');\n    let start_str = parts.next().unwrap();\n    let end_str = parts.next().unwrap();\n    let start = parse_time(start_str)?;\n    let end = parse_time(end_str)?;\n    Ok((start, end))\n}\n\nfn load_input(file_path: &str) -> Result<(Vec<Meeting>, Vec<Room>), std::io::Error> {\n    let file = File::open(file_path)?;\n    let reader = BufReader::new(file);\n    let mut meetings = Vec::new();\n    let mut rooms = Vec::new();\n    let mut section = \"meetings\";\n    for line in reader.lines() {\n        let line = line?;\n        if line.is_empty() {\n            section = \"rooms\";\n            continue;\n        }\n        match section {\n            \"meetings\" => {\n                let mut parts = line.split_whitespace();\n                let start_str = parts.next().unwrap();\n                let end_str = parts.next().unwrap();\n                let name = parts.next().unwrap().to_string();\n                let attendees_str = parts.next().unwrap();\n                let attendees = attendees_str.parse::<u32>().unwrap();\n                let start = parse_time(start_str)?;\n                let end = parse_time(end_str)?;\n                meetings.push(Meeting { start, end, name, attendees });\n            }\n            \"rooms\" => {\n                let mut parts = line.split_whitespace();\n                let name = parts.next().unwrap().to_string();\n                let capacity_str = parts.next().unwrap();\n                let capacity = capacity_str.parse::<u32>().unwrap();\n                let maintenance_str = parts.next().unwrap();\n                let maintenance = parse_maintenance(maintenance_str)?;\n                rooms.push(Room { name, capacity, maintenance });\n            }\n            _ => unreachable!(),\n        }\n    }\n    Ok((meetings, rooms))\n}\n\nfn find_min_rooms(meetings: Vec<Meeting>, rooms: Vec<Room>) -> u32 {\n    let mut room_usage: BTreeMap<DateTime<Local>, u32> = BTreeMap::new();\n    for meeting in meetings {\n        let start = meeting.start;\n        let end = meeting.end;\n        let attendees = meeting.attendees;\n        for room in &rooms {\n            if room.capacity >= attendees {\n                let maintenance_start = room.maintenance.0;\n                let maintenance_end = room.maintenance.1;\n                if start >= maintenance_end || end <= maintenance_start {\n                    let mut current_usage = 0;\n                    for (time, usage) in &room_usage {\n                        if *time >= start && *time < end {\n                            current_usage += usage;\n                        }\n                    }\n                    if current_usage + attendees <= room.capacity {\n                        for time in start..end {\n                            *room_usage.entry(time).or_insert(0) += attendees;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    room_usage.values().max().unwrap_or(&0).clone()\n}\n\nfn main() -> Result<(), std::io::Error> {\n    let (meetings, rooms) = load_input(\"input.txt\")?;\n    let min_rooms = find_min_rooms(meetings, rooms);\n    println!(\"Minimum required meeting rooms: {}\", min_rooms);\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "qwen/qwen-2.5-coder-32b-instruct", "problem_id": "34fa31b7-de3c-4fd3-b6d7-06dab4853ad7", "code": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{self, BufReader};\nuse std::path::Path;\nuse anyhow::Result;\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Soldier {\n    id: String,\n    superior_id: Option<String>,\n    name: String,\n    age: u32,\n    city: String,\n}\n\n#[derive(Debug)]\nstruct TreeNode {\n    soldier: Soldier,\n    children: Vec<TreeNode>,\n}\n\nimpl TreeNode {\n    fn new(soldier: Soldier) -> Self {\n        TreeNode {\n            soldier,\n            children: Vec::new(),\n        }\n    }\n}\n\nfn build_hierarchy(soldiers: Vec<Soldier>) -> Result<TreeNode> {\n    let mut nodes: HashMap<String, TreeNode> = HashMap::new();\n    let mut root_ids = Vec::new();\n\n    for soldier in soldiers {\n        let node = TreeNode::new(soldier.clone());\n        nodes.insert(soldier.id.clone(), node);\n\n        if let Some(superior_id) = soldier.superior_id.clone() {\n            if !nodes.contains_key(&superior_id) {\n                nodes.insert(superior_id.clone(), TreeNode::new(Soldier {\n                    id: superior_id.clone(),\n                    superior_id: None,\n                    name: String::new(),\n                    age: 0,\n                    city: String::new(),\n                }));\n            }\n        } else {\n            root_ids.push(soldier.id.clone());\n        }\n    }\n\n    for soldier in soldiers {\n        if let Some(superior_id) = soldier.superior_id {\n            if let Some(superior_node) = nodes.get_mut(&superior_id) {\n                if let Some(node) = nodes.get(soldier.id.as_str()) {\n                    superior_node.children.push(node.clone());\n                }\n            }\n        }\n    }\n\n    if root_ids.len() != 1 {\n        return Err(anyhow::anyhow!(\"Expected exactly one root soldier, found {}\", root_ids.len()));\n    }\n\n    Ok(nodes.remove(&root_ids[0]).unwrap())\n}\n\nfn find_node_by_id(node: &TreeNode, id: &str) -> Option<&TreeNode> {\n    if node.soldier.id == id {\n        return Some(node);\n    }\n    for child in &node.children {\n        if let Some(found) = find_node_by_id(child, id) {\n            return Some(found);\n        }\n    }\n    None\n}\n\nfn get_chain_of_command(node: &TreeNode, id: &str, chain: &mut Vec<String>) -> bool {\n    if node.soldier.id == id {\n        chain.push(node.soldier.id.clone());\n        return true;\n    }\n    for child in &node.children {\n        if get_chain_of_command(child, id, chain) {\n            chain.push(node.soldier.id.clone());\n            return true;\n        }\n    }\n    false\n}\n\nfn lowest_common_ancestor(root: &TreeNode, id1: &str, id2: &str) -> Option<String> {\n    let mut chain1 = Vec::new();\n    let mut chain2 = Vec::new();\n\n    get_chain_of_command(root, id1, &mut chain1);\n    get_chain_of_command(root, id2, &mut chain2);\n\n    chain1.reverse();\n    chain2.reverse();\n\n    let mut common_ancestor = None;\n    for (a, b) in chain1.iter().zip(chain2.iter()) {\n        if a == b {\n            common_ancestor = Some(a.clone());\n        } else {\n            break;\n        }\n    }\n\n    common_ancestor\n}\n\nfn get_chain_of_command_from_root(root: &TreeNode, id: &str) -> Vec<String> {\n    let mut chain = Vec::new();\n    get_chain_of_command(root, id, &mut chain);\n    chain.reverse();\n    chain\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let path = Path::new(\"soldiers.json\");\n    let file = File::open(&path)?;\n    let reader = BufReader::new(file);\n\n    let soldiers: Vec<Soldier> = serde_json::from_reader(reader)?;\n\n    let root = build_hierarchy(soldiers)?;\n\n    let id1 = \"002\";\n    let id2 = \"003\";\n\n    if let Some(ancestor) = lowest_common_ancestor(&root, id1, id2) {\n        println!(\"Lowest common ancestor of {} and {}: {}\", id1, id2, ancestor);\n    } else {\n        println!(\"No common ancestor found for {} and {}\", id1, id2);\n    }\n\n    let id = \"002\";\n    let chain = get_chain_of_command_from_root(&root, id);\n    if !chain.is_empty() {\n        println!(\"Chain of command for {}: {:?}\", id, chain);\n    } else {\n        println!(\"No chain of command found for ID: {}\", id);\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "deepseek/deepseek-chat", "problem_id": "34fa31b7-de3c-4fd3-b6d7-06dab4853ad7", "code": "use serde::Deserialize;\nuse std::collections::HashMap;\nuse std::fs;\nuse anyhow::{Result, anyhow};\n\n#[derive(Deserialize, Debug)]\nstruct Soldier {\n    id: String,\n    superior_id: Option<String>,\n    name: String,\n    age: u32,\n    city: String,\n}\n\n#[derive(Debug)]\nstruct SoldierNode {\n    soldier: Soldier,\n    subordinates: Vec<String>,\n}\n\nfn build_hierarchy(soldiers: Vec<Soldier>) -> HashMap<String, SoldierNode> {\n    let mut hierarchy: HashMap<String, SoldierNode> = HashMap::new();\n\n    for soldier in soldiers {\n        hierarchy.insert(soldier.id.clone(), SoldierNode {\n            soldier: soldier.clone(),\n            subordinates: Vec::new(),\n        });\n    }\n\n    for soldier in soldiers {\n        if let Some(superior_id) = soldier.superior_id {\n            if let Some(superior) = hierarchy.get_mut(&superior_id) {\n                superior.subordinates.push(soldier.id.clone());\n            }\n        }\n    }\n\n    hierarchy\n}\n\nfn lowest_common_ancestor(hierarchy: &HashMap<String, SoldierNode>, id1: &str, id2: &str) -> Option<String> {\n    let chain1 = get_chain_of_command(hierarchy, id1);\n    let chain2 = get_chain_of_command(hierarchy, id2);\n\n    let mut common_ancestor = None;\n    for (i, id1) in chain1.iter().enumerate() {\n        if chain2.len() > i && chain2[i] == *id1 {\n            common_ancestor = Some(id1.clone());\n        } else {\n            break;\n        }\n    }\n\n    common_ancestor\n}\n\nfn get_chain_of_command(hierarchy: &HashMap<String, SoldierNode>, id: &str) -> Vec<String> {\n    let mut chain = Vec::new();\n    let mut current_id = id;\n\n    while let Some(soldier_node) = hierarchy.get(current_id) {\n        chain.push(soldier_node.soldier.id.clone());\n        if let Some(superior_id) = soldier_node.soldier.superior_id.clone() {\n            current_id = &superior_id;\n        } else {\n            break;\n        }\n    }\n\n    chain\n}\n\nfn main() -> Result<()> {\n    let json_data = fs::read_to_string(\"soldiers.json\")?;\n    let soldiers: Vec<Soldier> = serde_json::from_str(&json_data)?;\n    let hierarchy = build_hierarchy(soldiers);\n\n    let id1 = \"002\";\n    let id2 = \"003\";\n\n    if let Some(common_ancestor) = lowest_common_ancestor(&hierarchy, id1, id2) {\n        println!(\"Lowest common ancestor between {} and {}: {}\", id1, id2, common_ancestor);\n    } else {\n        println!(\"No common ancestor found between {} and {}\", id1, id2);\n    }\n\n    let chain = get_chain_of_command(&hierarchy, id1);\n    println!(\"Chain of command for {}: {:?}\", id1, chain);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "deepseek/deepseek-chat", "problem_id": "7a8902bd-1e89-4267-a640-31a6d85a2657", "code": "fn main() {\n    let input = \"Hello, World!\";\n    let reversed = reverse_string(input);\n    println!(\"Original: {}\", input);\n    println!(\"Reversed: {}\", reversed);\n}\n\nfn reverse_string(s: &str) -> String {\n    s.chars().rev().collect()\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "deepseek/deepseek-chat", "problem_id": "fb9be66e-eaf4-47c5-b29a-cab2556b89f4", "code": "use chrono::{NaiveDateTime, Timelike};\nuse itertools::Itertools;\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{self, BufRead, BufReader};\nuse std::path::Path;\n\n#[derive(Debug)]\nstruct Meeting {\n    start: NaiveDateTime,\n    end: NaiveDateTime,\n    name: String,\n    attendees: usize,\n}\n\n#[derive(Debug)]\nstruct Room {\n    name: String,\n    capacity: usize,\n    maintenance_start: u32,\n    maintenance_end: u32,\n}\n\nfn parse_input<P: AsRef<Path>>(path: P) -> io::Result<(Vec<Meeting>, Vec<Room>)> {\n    let file = File::open(path)?;\n    let reader = BufReader::new(file);\n    let mut meetings = Vec::new();\n    let mut rooms = Vec::new();\n    let mut parsing_meetings = true;\n\n    for line in reader.lines() {\n        let line = line?;\n        if line.is_empty() {\n            parsing_meetings = false;\n            continue;\n        }\n\n        if parsing_meetings {\n            let parts: Vec<_> = line.split_whitespace().collect();\n            let start = NaiveDateTime::parse_from_str(&format!(\"{} {}\", parts[0], parts[1]), \"%Y-%m-%d %H:%M\").unwrap();\n            let end = NaiveDateTime::parse_from_str(&format!(\"{} {}\", parts[2], parts[3]), \"%Y-%m-%d %H:%M\").unwrap();\n            let name = parts[4].to_string();\n            let attendees = parts[5].parse().unwrap();\n            meetings.push(Meeting { start, end, name, attendees });\n        } else {\n            let parts: Vec<_> = line.split_whitespace().collect();\n            let name = parts[0].to_string();\n            let capacity = parts[1].parse().unwrap();\n            let maintenance_period: Vec<_> = parts[2].split('-').collect();\n            let maintenance_start = maintenance_period[0].parse::<u32>().unwrap();\n            let maintenance_end = maintenance_period[1].parse::<u32>().unwrap();\n            rooms.push(Room { name, capacity, maintenance_start, maintenance_end });\n        }\n    }\n\n    Ok((meetings, rooms))\n}\n\nfn is_room_available(room: &Room, meeting: &Meeting) -> bool {\n    let meeting_start_hour = meeting.start.hour();\n    let meeting_end_hour = meeting.end.hour();\n\n    if meeting_start_hour < meeting_end_hour {\n        !(meeting_start_hour < room.maintenance_end && meeting_end_hour > room.maintenance_start)\n    } else {\n        !(meeting_start_hour < room.maintenance_end || meeting_end_hour > room.maintenance_start)\n    }\n}\n\nfn main() -> io::Result<()> {\n    let (meetings, rooms) = parse_input(\"input.txt\")?;\n    let mut room_assignments: HashMap<String, Vec<Meeting>> = HashMap::new();\n\n    for meeting in meetings {\n        let mut assigned = false;\n        for room in &rooms {\n            if room.capacity >= meeting.attendees && is_room_available(room, &meeting) {\n                if let Some(assigned_meetings) = room_assignments.get_mut(&room.name) {\n                    if assigned_meetings.iter().all(|m| m.end <= meeting.start || m.start >= meeting.end) {\n                        assigned_meetings.push(meeting.clone());\n                        assigned = true;\n                        break;\n                    }\n                } else {\n                    room_assignments.insert(room.name.clone(), vec![meeting.clone()]);\n                    assigned = true;\n                    break;\n                }\n            }\n        }\n        if !assigned {\n            println!(\"Meeting {} could not be accommodated\", meeting.name);\n        }\n    }\n\n    let min_rooms_required = room_assignments.len();\n    println!(\"Minimum required meeting rooms: {}\", min_rooms_required);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "openhermes-2.5-mistral-7b.Q3_K_M", "problem_id": "ee9f64a5-643c-42d1-b583-a2001ce9ae01", "code": "use std::io;\n\nfn main() {\n    let mut counter = 100;\n    let mut num = 2;\n    let mut primes: Vec<i32> = Vec::new();\n\n    while counter > 0 {\n        let is_prime = check_prime(num);\n        if is_prime {\n            primes.push(num);\n            counter -= 1;\n            if counter == 1 {\n                println!(\"The first 100 prime numbers are: {:?}\", primes);\n            }\n        }\n        num += 1;\n    }\n}\n\nfn check_prime(num: i32) -> bool {\n    if num == 1 {\n        return false;\n    }\n    for i in 2..=(num as f64).sqrt() as i32 + 1 {\n        if num % i == 0 {\n            return false;\n        }\n    }\n    true\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "openhermes-2.5-mistral-7b.Q3_K_M", "problem_id": "f7261f57-e164-4705-af16-b22d35d5e160", "code": "#[macro_use]\nextern crate serde_derive;\nextern crate serde_json;\n\nuse std::{\n    fs::File,\n    io::{self, Write},\n    path::Path,\n};\n\nfn add_book_to_library(library_id: &str, book: &Book) -> Result<(), Box<dyn std::error::Error>> {\n    // your code goes here\n    Ok(())\n}\n\nfn remove_book_from_library(library_id: &str, book_id: &str) -> Result<(), Box<dyn std::error::Error>> {\n    // your code goes here\n    Ok(())\n}\n\nfn borrow_book(member_id: &str, book_id: &str) -> Result<(), Box<dyn std::error::Error>> {\n    // your code goes here\n    Ok(())\n}\n\nfn return_book(member_id: &str, book_id: &str) -> Result<(), Box<dyn std::error::Error>> {\n    // your code goes here\n    Ok(())\n}\n\nfn add_member(library_id: &str, member: &Member) -> Result<(), Box<dyn std::error::Error>> {\n    // your code goes here\n    Ok(())\n}\n\nfn remove_member(library_id: &str, member_id: &str) -> Result<(), Box<dyn std::error::Error>> {\n    // your code goes here\n    Ok(())\n}\n\nfn list_all_books(library_id: &str) -> Result<(), Box<dyn std::error::Error>> {\n    // your code goes here\n    Ok(())\n}\n\nfn list_books_borrowed_by_member(member_id: &str) -> Result<(), Box<dyn std::error::Error>> {\n    // your code goes here\n    Ok(())\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // your code goes here\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "openhermes-2.5-mistral-7b.Q3_K_M", "problem_id": "9bb5a1fc-e1f1-44f8-9538-ca8f1b7389e5", "code": "use serde::{Serialize, Deserialize};\nuse std::fmt::Display;\n\n// Define the Eater trait\npub trait Eater<F>\nwhere\n    F: Food,\n{\n    fn eat(&self, food: F) -> String;\n}\n\n// Define the Food trait\npub trait Food: Display + Sized + PartialEq + Copy {\n    fn caloric_value() -> u32;\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, Eq)]\npub enum FoodType {\n    Bone,\n    Meat,\n    Seed,\n    Worm,\n    Pizza,\n    Salad,\n}\n\nimpl FoodType {\n    pub fn from_str(s: &str) -> Option<FoodType> {\n        match s {\n            \"Bone\" => Some(FoodType::Bone),\n            \"Meat\" => Some(FoodType::Meat),\n            \"Seed\" => Some(FoodType::Seed),\n            \"Worm\" => Some(FoodType::Worm),\n            \"Pizza\" => Some(FoodType::Pizza),\n            \"Salad\" => Some(FoodType::Salad),\n            _ => None,\n        }\n    }\n}\n\nimpl Display for FoodType {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            FoodType::Bone => write!(f, \"Bone\"),\n            FoodType::Meat => write!(f, \"Meat\"),\n            FoodType::Seed => write!(f, \"Seed\"),\n            FoodType::Worm => write!(f, \"Worm\"),\n            FoodType::Pizza => write!(f, \"Pizza\"),\n            FoodType::Salad => write!(f, \"Salad\"),\n        }\n    }\n}\n\n// Define the Bone struct\n#[derive(PartialEq, Eq, Serialize, Deserialize, Clone)]\npub struct Bone;\n\nimpl Food for Bone {\n    fn caloric_value() -> u32 {\n        50\n    }\n}\n\n// Define the Meat struct\n#[derive(PartialEq, Eq, Serialize, Deserialize, Clone)]\npub struct Meat;\n\nimpl Food for Meat {\n    fn caloric_value() -> u32 {\n        100\n    }\n}\n\n// Define the Seed struct\n#[derive(PartialEq, Eq, Serialize, Deserialize, Clone)]\npub struct Seed;\n\nimpl Food for Seed {\n    fn caloric_value() -> u32 {\n        20\n    }\n}\n\n// Define the Worm struct\n#[derive(PartialEq, Eq, Serialize, Deserialize, Clone)]\npub struct Worm;\n\nimpl Food for Worm {\n    fn caloric_value() -> u32 {\n        15\n    }\n}\n\n// Define the Pizza struct\n#[derive(PartialEq, Eq, Serialize, Deserialize, Clone)]\npub struct Pizza;\n\nimpl Food for Pizza {\n    fn caloric_value() -> u32 {\n        40\n    }\n}\n\n// Define the Salad struct\n#[derive(PartialEq, Eq, Serialize, Deserialize, Clone)]\npub struct Salad;\n\nimpl Food for Salad {\n    fn caloric_value() -> u32 {\n        10\n    }\n}\n\n// Define the Dog struct\n#[derive(PartialEq, Eq, Serialize, Deserialize, Clone)]\npub struct Dog {\n    energy_level: u32,\n}\n\nimpl Dog {\n    pub fn new() -> Dog {\n        Dog { energy_level: 0 }\n    }\n}\n\nimpl Eater<Bone> for Dog {\n    fn eat(&mut self, food: Bone) {\n        self.energy_level += food.caloric_value();\n    }\n}\n\nimpl Eater<Meat> for Dog {\n    fn eat(&mut self, food: Meat) {\n        self.energy_level += food.caloric_value();\n    }\n}\n\nimpl Eater<Seed> for Dog {\n    fn eat(&mut self, food: Seed) {\n        self.energy_level += food.caloric_value();\n    }\n}\n\nimpl Eater<Worm> for Dog {\n    fn eat(&mut self, food: Worm) {\n        self.energy_level += food.caloric_value();\n    }\n}\n\nimpl Eater<Pizza> for Dog {\n    fn eat(&mut self, food: Pizza) {\n        self.energy_level += food.caloric_value();\n    }\n}\n\nimpl Eater<Salad> for Dog {\n    fn eat(&mut self, food: Salad) {\n        self.energy_level += food.caloric_value();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_dog_eats_food() {\n        let mut dog = Dog::new();\n        dog.eat(Bone);\n        dog.eat(Meat);\n        dog.eat(Seed);\n        dog.eat(Worm);\n        dog.eat(Pizza);\n        dog.eat(Salad);\n\n        assert_eq!(dog.energy_level, 225);\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "a4a04d10-7d3d-4f98-91ea-7b86d2627e57", "code": "use std::sync::mpsc::{channel, Sender};\nuse std::thread;\n\ntype Message = String;\ntype UserId = usize;\ntype SenderPair = (UserId, Sender<Message>);\n\nfn main() {\n    let (tx, rx) = channel();\n\n    let mut users = Vec::new();\n\n    thread::spawn(move || loop {\n        if let Ok(message) = rx.recv() {\n            for user in &users {\n                user.1.send(message.clone()).unwrap();\n            }\n        }\n    });\n\n    let mut user_id = 0;\n    loop {\n        user_id += 1;\n        let (tx_user, rx_user) = channel();\n        tx.send(format!(\"User {} joined the chat\", user_id)).unwrap();\n        users.push((user_id, tx_user));\n\n        thread::spawn(move || loop {\n            if let Ok(message) = rx_user.recv() {\n                tx.send(format!(\"User {}: {}\", user_id, message)).unwrap();\n            }\n        });\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "dfcef33d-f032-46a2-a10f-dc810a753508", "code": "fn quicksort(array: &mut [i32]) {\n    let len = array.len();\n    if len < 2 {\n        return;\n    }\n    let pivot = array[len / 2];\n    let mut left = 0;\n    let mut right = len - 1;\n    while left <= right {\n        while array[left] < pivot {\n            left += 1;\n        }\n        while array[right] > pivot {\n            right -= 1;\n        }\n        if left <= right {\n            array.swap(left, right);\n            left += 1;\n            right -= 1;\n        }\n    }\n    if right > 0 {\n        quicksort(&mut array[0..=right]);\n    }\n    if left < len {\n        quicksort(&mut array[left..]);\n    }\n}\n\nfn main() {\n    let mut array = [5, 3, 8, 4, 2, 7, 1, 6];\n    println!(\"Original array: {:?}\", array);\n    quicksort(&mut array);\n    println!(\"Sorted array: {:?}\", array);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "13336111-8997-4a77-aea3-0094f7585c5c", "code": "use std::collections::HashMap;\nuse chrono::prelude::*;\nuse csv::ReaderBuilder;\n\nstruct Movie {\n    id: u64,\n    title: String,\n    genre: String,\n    status: MovieStatus,\n}\n\nenum MovieStatus {\n    Available,\n    Rented,\n}\n\nstruct Customer {\n    id: u64,\n    name: String,\n    rented_movies: Vec<u64>,\n}\n\nstruct Rental {\n    movie_id: u64,\n    customer_id: u64,\n    rental_date: DateTime<Utc>,\n    return_date: Option<DateTime<Utc>>,\n}\n\nstruct MovieRentalSystem {\n    movies: HashMap<u64, Movie>,\n    customers: HashMap<u64, Customer>,\n    rentals: Vec<Rental>,\n}\n\nimpl MovieRentalSystem {\n    // Implement the methods here\n}\n\nfn main() {\n    // Initialize the system and perform operations\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "b717526c-a82c-4b6b-be53-cc87215e7491", "code": "struct Scheduler;\n\nimpl Scheduler {\n    fn run_task<F, T>(&self, task: F) -> T\n    where\n        F: FnOnce() -> T,\n    {\n        task()\n    }\n\n    fn run_chain<F, T>(&self, tasks: Vec<F>) -> Vec<T>\n    where\n        F: Fn(T) -> T,\n    {\n        let mut results = Vec::new();\n        let mut result = self.run_task(|| tasks[0](Default::default()));\n        results.push(result.clone());\n\n        for task in tasks.iter().skip(1) {\n            result = task(result);\n            results.push(result.clone());\n        }\n\n        results\n    }\n\n    fn run_conditional<F, G, T>(&self, task: F, condition: G) -> Option<T>\n    where\n        F: FnOnce() -> T,\n        G: Fn() -> bool,\n    {\n        if condition() {\n            Some(task())\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    let scheduler = Scheduler;\n\n    // Run a single task\n    let result = scheduler.run_task(|| 5);\n    println!(\"Result of single task: {}\", result);\n\n    // Run a sequence of tasks\n    let tasks = vec![|n: i32| n * 2, |n: i32| n + 1];\n    let results = scheduler.run_chain(tasks);\n    println!(\"Results of chained tasks: {:?}\", results);\n\n    // Run a conditional task\n    let result = scheduler.run_conditional(|| 10, || true);\n    println!(\"Result of conditional task: {:?}\", result);\n\n    let result = scheduler.run_conditional(|| 10, || false);\n    println!(\"Result of conditional task: {:?}\", result);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "9ed01fca-89ea-46da-bd9d-fa7dd4ff88e5", "code": "use std::time::Duration;\n\n#[tokio::main]\nasync fn main() {\n    let cache = Cache::new(100, EvictionPolicy::LRU);\n\n    cache.insert(\"key1\", \"value1\", Duration::from_secs(10)).await;\n    cache.insert(\"key2\", \"value2\", Duration::from_secs(5)).await;\n    cache.insert(\"key3\", \"value3\", Duration::from_secs(20)).await;\n\n    let value = cache.get(\"key2\").await.unwrap();\n    println!(\"{}\", value); // Prints: \"value2\"\n\n    // After 6 seconds, \"key2\" is expired\n    tokio::time::sleep(Duration::from_secs(6)).await;\n    assert!(cache.get(\"key2\").await.is_none());\n\n    // Bulk operations\n    cache.insert_bulk(&[(\"key4\", \"value4\", Duration::from_secs(30))]).await;\n    cache.delete_bulk(&[\"key3\", \"key4\"]).await;\n    assert!(cache.get(\"key3\").await.is_none());\n    assert!(cache.get(\"key4\").await.is_none());\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "fdd28d76-b741-4e91-8ed1-1dad92980ce3", "code": "is_there_hot_dog!([\"hamburger\", \"fries\", \"hotdog\", \"soda\"]); // true\nis_there_hot_dog!([\"hamburger\", \"fries\", \"soda\"]); // false\nis_there_hot_dog!([\"hamburger\", \"fries\", \"Hot Dog\", \"soda\"]); // true\nis_there_hot_dog!([]); // false", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "beba4ac5-24d1-4bde-b0e1-1ccdc2fca2be", "code": "use std::time::Duration;\nuse std::collections::HashMap;\n\n#[tokio::main]\nasync fn main() {\n    let mut cache = Cache::new(10, EvictionPolicy::LRU);\n\n    cache.insert(\"key1\", \"value1\", Duration::from_secs(5));\n    cache.insert(\"key2\", \"value2\", Duration::from_secs(10));\n\n    println!(\"{:?}\", cache.get(\"key1\")); // Some(\"value1\")\n    println!(\"{:?}\", cache.get(\"key2\")); // Some(\"value2\")\n\n    cache.bulk_insert(HashMap::from([(\"key3\", (\"value3\", Duration::from_secs(20))), (\"key4\", (\"value4\", Duration::from_secs(30)))]));\n\n    println!(\"{:?}\", cache.get(\"key3\")); // Some(\"value3\")\n    println!(\"{:?}\", cache.get(\"key4\")); // Some(\"value4\")\n\n    tokio::time::sleep(Duration::from_secs(6)).await;\n\n    println!(\"{:?}\", cache.get(\"key1\")); // None\n    println!(\"{:?}\", cache.get(\"key2\")); // Some(\"value2\")\n\n    cache.delete(\"key2\");\n\n    println!(\"{:?}\", cache.get(\"key2\")); // None\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "7f366e56-125a-4cf3-822c-5cfe4295897f", "code": "use std::io;\n\nenum Player {\n    X,\n    O,\n}\n\nstruct Board {\n    cells: [[Option<Player>; 3]; 3],\n}\n\nimpl Board {\n    fn new() -> Self {\n        Board {\n            cells: [[None; 3]; 3],\n        }\n    }\n\n    fn print(&self) {\n        for row in &self.cells {\n            for cell in row {\n                match cell {\n                    Some(Player::X) => print!(\"X\"),\n                    Some(Player::O) => print!(\"O\"),\n                    None => print!(\" \"),\n                }\n                print!(\"|\");\n            }\n            println!();\n            println!(\"-----\");\n        }\n    }\n\n    fn make_move(&mut self, player: Player, row: usize, col: usize) -> Result<(), &'static str> {\n        if self.cells[row][col].is_some() {\n            return Err(\"Cell already occupied\");\n        }\n        self.cells[row][col] = Some(player);\n        Ok(())\n    }\n\n    fn check_win(&self, player: Player) -> bool {\n        for row in &self.cells {\n            if row.iter().all(|cell| cell == &Some(player)) {\n                return true;\n            }\n        }\n\n        for col in 0..3 {\n            if (0..3).all(|row| self.cells[row][col] == Some(player)) {\n                return true;\n            }\n        }\n\n        if (0..3).all(|i| self.cells[i][i] == Some(player)) {\n            return true;\n        }\n\n        if (0..3).all(|i| self.cells[i][2 - i] == Some(player)) {\n            return true;\n        }\n\n        false\n    }\n\n    fn is_full(&self) -> bool {\n        self.cells.iter().all(|row| row.iter().all(|cell| cell.is_some()))\n    }\n}\n\nfn main() {\n    let mut board = Board::new();\n    let mut current_player = Player::X;\n\n    loop {\n        board.print();\n\n        let mut input = String::new();\n        println!(\"Player {:?}, enter your move (row col):\", current_player);\n        io::stdin().read_line(&mut input).unwrap();\n\n        let mut parts = input.split_whitespace();\n        let row: usize = parts.next().unwrap().parse().unwrap();\n        let col: usize = parts.next().unwrap().parse().unwrap();\n\n        if board.make_move(current_player, row, col).is_err() {\n            println!(\"Invalid move, try again\");\n            continue;\n        }\n\n        if board.check_win(current_player) {\n            board.print();\n            println!(\"Player {:?} wins!\", current_player);\n            break;\n        }\n\n        if board.is_full() {\n            board.print();\n            println!(\"It's a draw!\");\n            break;\n        }\n\n        current_player = match current_player {\n            Player::X => Player::O,\n            Player::O => Player::X,\n        };\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "a194d257-5056-4776-a006-037f3769b9fd", "code": "fn make_fibonacci(reset: bool) -> impl FnMut() -> u64 {\n    let mut a = if reset { 0 } else { 1 };\n    let mut b = 1;\n    move || {\n        let next = a + b;\n        a = b;\n        b = next;\n        b\n    }\n}\n\nfn main() {\n    let mut fib = make_fibonacci(true);\n    for _ in 0..10 {\n        println!(\"{}\", fib());  // Prints: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n    }\n    let mut fib = make_fibonacci(false);\n    for _ in 0..10 {\n        println!(\"{}\", fib());  // Prints: 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "53f98ac8-7775-4021-b261-ff142f0de0eb", "code": "use std::fmt;\n\n#[derive(Debug)]\nenum State {\n    Working,\n    Eating,\n    Distracted,\n    Sleeping,\n}\n\nimpl fmt::Display for State {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            State::Working => write!(f, \"Working\"),\n            State::Eating => write!(f, \"Eating\"),\n            State::Distracted => write!(f, \"Distracted\"),\n            State::Sleeping => write!(f, \"Sleeping\"),\n        }\n    }\n}\n\n#[derive(Debug)]\nenum Event {\n    Hunger,\n    Fly,\n    Nighttime,\n}\n\nimpl Programmer {\n    fn transition(&mut self, event: Event) {\n        self.state = match (&self.state, event) {\n            (State::Working, Event::Hunger) => State::Eating,\n            (State::Working | State::Eating | State::Distracted, Event::Fly) => State::Distracted,\n            (_, Event::Nighttime) => State::Sleeping,\n            _ => self.state,\n        };\n    }\n}\n\nfn main() {\n    let mut programmer = Programmer { state: State::Working };\n\n    programmer.transition(Event::Hunger);\n    println!(\"{}\", programmer.state);  // Eating\n\n    programmer.transition(Event::Fly);\n    println!(\"{}\", programmer.state);  // Distracted\n\n    programmer.transition(Event::Nighttime);\n    println!(\"{}\", programmer.state);  // Sleeping\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "ffe50abe-298b-4356-a2c0-5c2ee827bd5f", "code": "extern crate scraper;\nuse scraper::{Html, Selector};\n\n#[derive(Debug)]\nstruct Node {\n    name: String,\n    children: Vec<Node>,\n}\n\nfn parse_html(html: &str) -> Node {\n    let fragment = Html::parse_fragment(html);\n    let selector = Selector::parse(\"*\").unwrap();\n    let root = Node {\n        name: \"root\".to_string(),\n        children: Vec::new(),\n    };\n    build_tree(&fragment, &selector, &root)\n}\n\nfn build_tree<'a>(node: &'a scraper::node::Node<'a>, selector: &Selector, parent: &Node) -> Node {\n    let mut new_node = Node {\n        name: node.value().name().to_string(),\n        children: Vec::new(),\n    };\n    for child in node.select(&selector) {\n        let child_node = build_tree(&child, selector, &new_node);\n        new_node.children.push(child_node);\n    }\n    if new_node.name != parent.name {\n        new_node\n    } else {\n        parent.children.extend(new_node.children);\n        parent.clone()\n    }\n}\n\nfn get_depth(node: &Node) -> usize {\n    if node.children.is_empty() {\n        0\n    } else {\n        1 + node.children.iter().map(get_depth).max().unwrap()\n    }\n}\n\nfn get_tag_count(node: &Node) -> usize {\n    node.children.iter().map(get_tag_count).sum::<usize>() + 1\n}\n\nfn main() {\n    let html = r#\"\n        <div>\n            <p>Hello</p>\n            <span><i>World</i></span>\n        </div>\n    \"#;\n    let tree = parse_html(html);\n    println!(\"{:#?}\", tree);\n    println!(\"Depth: {}\", get_depth(&tree));\n    println!(\"Tag count: {}\", get_tag_count(&tree));\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "1bd19442-39a0-42ca-a3a6-4e1591268ca6", "code": "pub fn complete_circuit(energy: Vec<i32>, burn_rate: Vec<i32>) -> i32 {\n    let n = energy.len();\n    let mut total_energy = energy.iter().sum::<i32>();\n    let mut total_burn_rate = burn_rate.iter().sum::<i32>();\n    let mut current_energy = 0;\n    let mut start_index = 0;\n    let mut max_energy = std::i32::MIN;\n\n    for i in 0..n {\n        current_energy += energy[i] - burn_rate[i];\n        if current_energy < 0 {\n            total_energy += current_energy;\n            current_energy = 0;\n            start_index = (i + 1) % n;\n        }\n        max_energy = max_energy.max(current_energy);\n    }\n\n    if total_energy >= total_burn_rate {\n        start_index as i32\n    } else {\n        -1\n    }\n}\n\nfn main() {\n    let energy = vec![1, 2, 3, 4, 5];\n    let burn_rate = vec![3, 4, 5, 1, 2];\n    println!(\"{}\", complete_circuit(energy, burn_rate));\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "eadad3f4-5e40-4e49-85e8-8a00dceec642", "code": "use std::sync::{Arc, Mutex};\n\n#[derive(Debug)]\nstruct BookStats {\n    times_checked_out: u32,\n    currently_checked_out: bool,\n}\n\nstruct Book {\n    title: String,\n    stats: Arc<Mutex<BookStats>>,\n}\n\nimpl Book {\n    fn new(title: &str) -> Self {\n        Book {\n            title: String::from(title),\n            stats: Arc::new(Mutex::new(BookStats {\n                times_checked_out: 0,\n                currently_checked_out: false,\n            })),\n        }\n    }\n\n    fn checkout(&self) -> Result<(), &'static str> {\n        let mut stats = self.stats.lock().unwrap();\n        if stats.currently_checked_out {\n            Err(\"Book is already checked out\")\n        } else {\n            stats.times_checked_out += 1;\n            stats.currently_checked_out = true;\n            Ok(())\n        }\n    }\n\n    fn return_book(&self) -> Result<(), &'static str> {\n        let mut stats = self.stats.lock().unwrap();\n        if !stats.currently_checked_out {\n            Err(\"Book is not checked out\")\n        } else {\n            stats.currently_checked_out = false;\n            Ok(())\n        }\n    }\n\n    fn get_checkout_count(&self) -> u32 {\n        self.stats.lock().unwrap().times_checked_out\n    }\n\n    fn is_checked_out(&self) -> bool {\n        self.stats.lock().unwrap().currently_checked_out\n    }\n}\n\nfn main() {\n    let book = Book::new(\"The Rust Programming Language\");\n    println!(\"{}\", book.get_checkout_count()); // 0\n    println!(\"{}\", book.is_checked_out()); // false\n    book.checkout().unwrap();\n    println!(\"{}\", book.get_checkout_count()); // 1\n    println!(\"{}\", book.is_checked_out()); // true\n    book.return_book().unwrap();\n    println!(\"{}\", book.get_checkout_count()); // 1\n    println!(\"{}\", book.is_checked_out()); // false\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "136820f1-3c42-44a6-941e-2dbc21d7ef0e", "code": "use std::ops::Add;\n\nstruct Programmer {\n    name: String,\n    skill_points: f32,\n}\n\nimpl Add for Programmer {\n    type Output = Programmer;\n\n    fn add(self, other: Programmer) -> Programmer {\n        let half_name_len = self.name.len() / 2;\n        let name = format!(\"{}{}\", &self.name[..half_name_len], &other.name[half_name_len..]);\n\n        let harmonic_mean = 2.0 * self.skill_points * other.skill_points / (self.skill_points + other.skill_points);\n\n        Programmer {\n            name,\n            skill_points: harmonic_mean,\n        }\n    }\n}\n\nfn find_top_programmer(programmers: Vec<Programmer>) -> Option<Programmer> {\n    programmers.into_iter().max_by(|a, b| a.skill_points.total_cmp(&b.skill_points))\n}\n\nfn main() {\n    let programmer1 = Programmer {\n        name: String::from(\"JohnDoe\"),\n        skill_points: 10.0,\n    };\n\n    let programmer2 = Programmer {\n        name: String::from(\"JaneSmith\"),\n        skill_points: 15.0,\n    };\n\n    let programmer3 = programmer1 + programmer2;\n    println!(\"New programmer: {} with skill points: {}\", programmer3.name, programmer3.skill_points);\n\n    let top_programmer = find_top_programmer(vec![programmer1, programmer2, programmer3]);\n    match top_programmer {\n        Some(programmer) => println!(\"Top programmer: {} with skill points: {}\", programmer.name, programmer.skill_points),\n        None => println!(\"No programmers provided\"),\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "bbccddec-2603-4812-b140-583931cfccbb", "code": "use std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[tokio::main]\nasync fn main() {\n    let cache: Arc<RwLock<LruCache<String, String>>> = Arc::new(RwLock::new(LruCache::new(3)));\n\n    // Inserting items\n    cache.write().await.insert(\"key1\".to_string(), \"value1\".to_string());\n    cache.write().await.insert(\"key2\".to_string(), \"value2\".to_string());\n    cache.write().await.insert(\"key3\".to_string(), \"value3\".to_string());\n\n    // Getting values\n    let value1 = cache.read().await.get(\"key1\");\n    assert_eq!(value1, Some(&\"value1\".to_string()));\n\n    let value4 = cache.read().await.get(\"key4\");\n    assert_eq!(value4, None);\n\n    // Exceeding capacity\n    cache.write().await.insert(\"key4\".to_string(), \"value4\".to_string());\n\n    let value1 = cache.read().await.get(\"key1\");\n    assert_eq!(value1, None); // key1 should be removed as it's the least recently used\n\n    // Updating value\n    cache.write().await.insert(\"key4\".to_string(), \"new_value4\".to_string());\n\n    let value4 = cache.read().await.get(\"key4\");\n    assert_eq!(value4, Some(&\"new_value4\".to_string()));\n\n    // Removing item\n    cache.write().await.remove(\"key2\");\n\n    let value2 = cache.read().await.get(\"key2\");\n    assert_eq!(value2, None);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "7e030eb8-c313-4492-bb20-adbf31eca9a4", "code": "use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "d2accd59-e363-4495-bfd4-9aa981d4deb4", "code": "let mut series = TVSeries::new(\"Breaking Bad\", vec![\"Drama\", \"Crime\", \"Thriller\"]);\nseries.add_actor(\"Bryan Cranston\");\nseries.add_actor(\"Aaron Paul\");\nseries.add_episode(Episode::new(\"Pilot\", 1));\nseries.add_episode(Episode::new(\"Cat's in the Bag...\", 2));\nseries.episode_mut(0).add_review(Review::new(5, \"Great pilot episode!\"));\nseries.episode_mut(1).add_review(Review::new(4, \"Good episode, but not as good as the pilot.\"));", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "b24f0b01-b4e4-4ddd-8e5a-11e69996a676", "code": "fn largest_rectangle(matrix: Vec<Vec<i32>>, x: i32, y: i32) -> i32 {\n    let (n, m) = (matrix.len(), matrix[0].len());\n    let mut dp = vec![vec![0; m]; n];\n    let mut max_area = 0;\n\n    for i in 0..n {\n        for j in 0..m {\n            if matrix[i][j] % x == 0 && matrix[i][j] > y {\n                dp[i][j] = if j > 0 { dp[i][j - 1] + 1 } else { 1 };\n                let mut width = dp[i][j];\n                let mut height = 1;\n                for k in (0..i).rev() {\n                    width = std::cmp::min(width, dp[k][j]);\n                    if width > 0 {\n                        height += 1;\n                        max_area = std::cmp::max(max_area, width * height);\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    max_area\n}\n\nfn main() {\n    let matrix = vec![\n        vec![1, 2, 3, 4, 5],\n        vec![6, 7, 8, 9, 10],\n        vec![11, 12, 13, 14, 15],\n        vec![16, 17, 18, 19, 20],\n    ];\n    let x = 3;\n    let y = 7;\n    println!(\"{}\", largest_rectangle(matrix, x, y));\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "96f397c1-7ac3-4769-a21f-bf59908ea96b", "code": "use std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\nuse anyhow::{Error, Result};\nuse chrono::prelude::*;\nuse uuid::Uuid;\nuse thiserror::Error;\n\n// Define the custom error types for different failure scenarios\n#[derive(Error, Debug)]\npub enum StateError {\n    #[error(\"Invalid state transition\")]\n    InvalidTransition,\n    #[error(\"State change timeout\")]\n    Timeout,\n    #[error(\"Rollback failed\")]\n    RollbackFailed,\n}\n\n// Define the associated data structures for each state\nstruct PendingData { /* ... */ }\nstruct PaymentData { /* ... */ }\nstruct BookingDetails { /* ... */ }\nstruct DisputeReason { /* ... */ }\nstruct RefundAmount { /* ... */ }\nstruct CancellationReason { /* ... */ }\n\n// Define the BookingState enum with associated data for each state\nenum BookingState {\n    Pending(PendingData),\n    PaymentVerifying(PaymentData, Instant),\n    Confirmed(BookingDetails),\n    Disputed(DisputeReason),\n    Refunded(RefundAmount),\n    Cancelled(CancellationReason),\n}\n\n// Define the StateManager struct to handle concurrent state changes and timeouts\nstruct StateManager {\n    state: Arc<Mutex<BookingState>>,\n}\n\nimpl StateManager {\n    // Function to validate business rules and timing constraints for state transitions\n    fn validate_transition(&self, new_state: &BookingState) -> bool {\n        // Implement validation logic here\n        true\n    }\n\n    // Function to handle state changes with timeout-based automatic transitions\n    fn change_state(&self, new_state: BookingState, timeout: Duration) -> Result<()> {\n        let mut state = self.state.lock().unwrap();\n        if !self.validate_transition(&new_state) {\n            return Err(Error::from(StateError::InvalidTransition));\n        }\n\n        let start_time = Instant::now();\n        *state = new_state;\n\n        loop {\n            if let BookingState::PaymentVerifying(_, end_time) = &*state {\n                if start_time.elapsed() > timeout {\n                    return Err(Error::from(StateError::Timeout));\n                }\n                if Instant::now() > *end_time {\n                    break;\n                }\n            } else {\n                break;\n            }\n            std::thread::sleep(Duration::from_millis(100));\n        }\n\n        Ok(())\n    }\n\n    // Function to revert partial state changes and maintain data consistency\n    fn rollback_transaction(&self) -> Result<()> {\n        // Implement rollback logic here\n        Ok(())\n    }\n}\n\nfn main() {\n    // Create a new StateManager instance\n    let state_manager = StateManager {\n        state: Arc::new(Mutex::new(BookingState::Pending(PendingData {}))),\n    };\n\n    // Change the state to PaymentVerifying with a timeout\n    let result = state_manager.change_state(\n        BookingState::PaymentVerifying(PaymentData {}, Instant::now() + Duration::from_secs(5)),\n        Duration::from_secs(10),\n    );\n\n    match result {\n        Ok(_) => println!(\"State changed successfully\"),\n        Err(err) => println!(\"State change failed: {}\", err),\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "53f98ac8-7775-4021-b261-ff142f0de0eb", "code": "use std::fmt;\n\n#[derive(Debug, PartialEq)]\nenum State {\n    Working,\n    Eating,\n    Distracted,\n    Sleeping,\n}\n\nimpl fmt::Display for State {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            State::Working => write!(f, \"Working\"),\n            State::Eating => write!(f, \"Eating\"),\n            State::Distracted => write!(f, \"Distracted\"),\n            State::Sleeping => write!(f, \"Sleeping\"),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq)]\nenum Event {\n    Hunger,\n    Fly,\n    Nighttime,\n}\n\nfn transition(state: State, event: Event) -> State {\n    match (state, event) {\n        (State::Working, Event::Hunger) => State::Eating,\n        (State::Working | State::Eating | State::Distracted, Event::Fly) => State::Distracted,\n        (_, Event::Nighttime) => State::Sleeping,\n        _ => state,\n    }\n}\n\nfn main() {\n    let mut state = State::Working;\n    println!(\"Initial state: {}\", state);\n\n    state = transition(state, Event::Hunger);\n    println!(\"State after getting hungry: {}\", state);\n\n    state = transition(state, Event::Fly);\n    println!(\"State after a fly appears: {}\", state);\n\n    state = transition(state, Event::Nighttime);\n    println!(\"State after nighttime: {}\", state);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "7ada1702-7114-4296-b85e-9a2e0c5fb884", "code": "use std::fmt::Display;\n\n// Traits\ntrait Food {\n    fn get_digestible_calories(&self) -> u32;\n}\n\ntrait Eater<F, D> {\n    fn eat(&mut self, food: F) -> D;\n    fn get_energy(&self) -> u32;\n}\n\n// Enum for Food Types\nenum FoodType {\n    Bone(u32),\n    Meat(u32),\n    Seed(u32),\n    Worm(u32),\n    Pizza(u32),\n    Salad(u32),\n    Soil(u32),\n}\n\nimpl Food for FoodType {\n    fn get_digestible_calories(&self) -> u32 {\n        match self {\n            FoodType::Bone(calories) => *calories,\n            FoodType::Meat(calories) => *calories,\n            FoodType::Seed(calories) => *calories,\n            FoodType::Worm(calories) => *calories,\n            FoodType::Pizza(calories) => *calories,\n            FoodType::Salad(calories) => *calories,\n            FoodType::Soil(calories) => *calories,\n        }\n    }\n}\n\n// Enum for Digestion Results\nenum DigestionResult {\n    Success(String),\n    Failure(String),\n}\n\nimpl Display for DigestionResult {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            DigestionResult::Success(msg) => write!(f, \"Digestion successful: {}\", msg),\n            DigestionResult::Failure(msg) => write!(f, \"Digestion failed: {}\", msg),\n        }\n    }\n}\n\n// Structs for Animals\nstruct Dog {\n    energy: u32,\n}\n\nstruct Bird {\n    energy: u32,\n}\n\nstruct Worm {\n    energy: u32,\n}\n\n// Implement Eater trait for Animals\nimpl Eater<FoodType, DigestionResult> for Dog {\n    fn eat(&mut self, food: FoodType) -> DigestionResult {\n        match food {\n            FoodType::Bone(_) | FoodType::Meat(_) => {\n                self.energy += food.get_digestible_calories();\n                DigestionResult::Success(format!(\"Dog has eaten {:?} and gained {} energy\", food, food.get_digestible_calories()))\n            }\n            _ => DigestionResult::Failure(format!(\"Dog cannot eat {:?}\", food)),\n        }\n    }\n\n    fn get_energy(&self) -> u32 {\n        self.energy\n    }\n}\n\nimpl Eater<FoodType, DigestionResult> for Bird {\n    fn eat(&mut self, food: FoodType) -> DigestionResult {\n        match food {\n            FoodType::Seed(_) | FoodType::Worm(_) => {\n                self.energy += food.get_digestible_calories();\n                DigestionResult::Success(format!(\"Bird has eaten {:?} and gained {} energy\", food, food.get_digestible_calories()))\n            }\n            _ => DigestionResult::Failure(format!(\"Bird cannot eat {:?}\", food)),\n        }\n    }\n\n    fn get_energy(&self) -> u32 {\n        self.energy\n    }\n}\n\nimpl Eater<FoodType, DigestionResult> for Worm {\n    fn eat(&mut self, food: FoodType) -> DigestionResult {\n        match food {\n            FoodType::Soil(_) => {\n                self.energy += food.get_digestible_calories();\n                DigestionResult::Success(format!(\"Worm has eaten {:?} and gained {} energy\", food, food.get_digestible_calories()))\n            }\n            _ => DigestionResult::Failure(format!(\"Worm cannot eat {:?}\", food)),\n        }\n    }\n\n    fn get_energy(&self) -> u32 {\n        self.energy\n    }\n}\n\nfn main() {\n    let mut dog = Dog { energy: 10 };\n    let mut bird = Bird { energy: 5 };\n    let mut worm = Worm { energy: 2 };\n\n    println!(\"{}\", dog.eat(FoodType::Bone(1)));\n    println!(\"{}\", bird.eat(FoodType::Worm(1)));\n    println!(\"{}\", worm.eat(FoodType::Soil(1)));\n    println!(\"{}\", dog.eat(FoodType::Worm(1)));\n    println!(\"{}\", bird.eat(FoodType::Meat(1)));\n    println!(\"{}\", worm.eat(FoodType::Seed(1)));\n\n    println!(\"Dog energy: {}\", dog.get_energy());\n    println!(\"Bird energy: {}\", bird.get_energy());\n    println!(\"Worm energy: {}\", worm.get_energy());\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "1dc0ac25-ee3c-4b9f-a76b-11e9012e8da4", "code": "let tree = tree!(1,\n    tree!(2,\n        tree!(4),\n        tree!(5)\n    ),\n    tree!(3)\n);", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "ee888d19-5869-46fb-a6c4-3259eb90431f", "code": "use std::collections::HashMap;\nuse std::collections::HashSet;\nuse chrono::{DateTime, Utc};\nuse uuid::Uuid;\n\n#[derive(Debug)]\nstruct User {\n    name: String,\n    id: Uuid,\n    birthdate: DateTime<Utc>,\n}\n\n#[derive(Debug, Hash, Eq, PartialEq)]\nstruct Car {\n    id: Uuid,\n    brand: String,\n    model: String,\n}\n\nstruct CarUser {\n    users: HashMap<Uuid, User>,\n    cars: HashMap<Uuid, Car>,\n    user_cars: HashMap<Uuid, HashSet<Uuid>>,\n    car_users: HashMap<Uuid, HashSet<Uuid>>,\n}\n\nimpl CarUser {\n    fn new() -> Self {\n        CarUser {\n            users: HashMap::new(),\n            cars: HashMap::new(),\n            user_cars: HashMap::new(),\n            car_users: HashMap::new(),\n        }\n    }\n\n    fn add_user(&mut self, name: String, birthdate: DateTime<Utc>) {\n        let id = Uuid::new_v4();\n        let user = User { name, id, birthdate };\n        self.users.insert(id, user);\n        self.user_cars.insert(id, HashSet::new());\n    }\n\n    fn add_car(&mut self, brand: String, model: String) {\n        let id = Uuid::new_v4();\n        let car = Car { id, brand, model };\n        self.cars.insert(id, car);\n        self.car_users.insert(id, HashSet::new());\n    }\n\n    fn assign_car_to_user(&mut self, user_id: Uuid, car_id: Uuid) {\n        if let (Some(user), Some(car)) = (self.users.get(&user_id), self.cars.get(&car_id)) {\n            self.user_cars.get_mut(&user_id).unwrap().insert(car_id);\n            self.car_users.get_mut(&car_id).unwrap().insert(user_id);\n        }\n    }\n\n    fn get_cars_assigned_to_user(&self, user_id: Uuid) -> Option<Vec<&Car>> {\n        self.user_cars.get(&user_id).map(|car_ids| {\n            car_ids.iter().filter_map(|&car_id| self.cars.get(&car_id)).collect()\n        })\n    }\n\n    fn get_users_assigned_to_car(&self, car_id: Uuid) -> Option<Vec<&User>> {\n        self.car_users.get(&car_id).map(|user_ids| {\n            user_ids.iter().filter_map(|&user_id| self.users.get(&user_id)).collect()\n        })\n    }\n\n    fn get_youngest_user_assigned_to_car(&self, car_id: Uuid) -> Option<&User> {\n        self.car_users.get(&car_id).and_then(|user_ids| {\n            user_ids.iter().filter_map(|&user_id| self.users.get(&user_id)).min_by_key(|user| user.birthdate)\n        })\n    }\n\n    fn get_users_assigned_to_cars(&self, car_ids: &[Uuid]) -> Vec<&User> {\n        car_ids.iter().flat_map(|&car_id| self.get_users_assigned_to_car(car_id).unwrap_or_default()).collect()\n    }\n}\n\nfn main() {}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "a194d257-5056-4776-a006-037f3769b9fd", "code": "fn make_fibonacci() -> impl FnMut() -> u64 {\n    let mut prev = 0;\n    let mut curr = 1;\n\n    move || {\n        let next = prev + curr;\n        prev = curr;\n        curr = next;\n        curr - prev\n    }\n}\n\nfn main() {\n    let mut fib = make_fibonacci();\n    for _ in 0..10 {\n        println!(\"{}\", fib());  // Prints: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "30ae8422-d34d-4ca3-b110-ec0b6aa72c45", "code": "use anyhow::Result;\nuse reqwest::Client;\nuse serde::Deserialize;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\n#[derive(Deserialize)]\nstruct Article {\n    title: String,\n    summary: String,\n    full_article: String,\n}\n\nstruct Cache {\n    full: LruCache<String, String>,\n    summary: LruCache<String, String>,\n}\n\nimpl Cache {\n    fn new(n_full: usize, n_summary: usize) -> Self {\n        Cache {\n            full: LruCache::new(n_full),\n            summary: LruCache::new(n_summary),\n        }\n    }\n\n    fn get_article(&mut self, title: &str) -> Result<String> {\n        if let Some(article) = self.full.get(title) {\n            return Ok(article.clone());\n        }\n\n        if let Some(summary) = self.summary.get(title) {\n            return Ok(summary.clone());\n        }\n\n        let article = fetch_article(title)?;\n\n        self.summary.insert(article.title.clone(), article.summary.clone());\n        self.full.insert(article.title.clone(), article.full_article.clone());\n\n        Ok(article.full_article)\n    }\n}\n\nasync fn fetch_article(title: &str) -> Result<Article> {\n    let url = format!(\"https://en.mikipedia.org/api/{}\", title);\n    let client = Client::new();\n    let res = client.get(&url).send().await?;\n    let article: Article = res.json().await?;\n    Ok(article)\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let cache = Arc::new(Mutex::new(Cache::new(100, 1000)));\n\n    // example usage\n    let title = \"Rust_programming_language\";\n    let article = cache.lock().await.get_article(title)?;\n    println!(\"Article: {}\", article);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "7c98c28a-2acd-4c7c-a74e-043538947c8e", "code": "use std::error::Error;\nuse std::fs::File;\nuse std::io::Read;\nuse serde::Deserialize;\nuse csv::ReaderBuilder;\n\n#[derive(Debug, Deserialize)]\nstruct Soldier {\n    id: usize,\n    rank: String,\n    given_name: String,\n    family_name: String,\n    primary_weapon: String,\n    years_of_service: u32,\n}\n\ntype Criterion = (String, String, u32);\n\n// Function to parse the CSV file and return a vector of Soldier structs\nfn parse_roster(filename: &str) -> Result<Vec<Soldier>, Box<dyn Error>> {\n    let mut file = File::open(filename)?;\n    let mut content = String::new();\n    file.read_to_string(&mut content)?;\n\n    let mut reader = ReaderBuilder::new().from_reader(content.as_bytes());\n    let mut soldiers = Vec::new();\n\n    for result in reader.deserialize() {\n        let soldier: Soldier = result?;\n        soldiers.push(soldier);\n    }\n\n    Ok(soldiers)\n}\n\n// Function to check if a soldier matches a given criterion\nfn matches_criterion(soldier: &Soldier, criterion: &Criterion) -> bool {\n    let (rank, weapon, min_years) = criterion;\n    soldier.rank == *rank && soldier.primary_weapon == *weapon && soldier.years_of_service >= *min_years\n}\n\n// Function to perform the search and return a vector of matching IDs\nfn search_roster(soldiers: &[Soldier], criteria: &[Criterion]) -> Vec<usize> {\n    let mut ids = Vec::new();\n    let mut i = 0;\n\n    'outer: while i < soldiers.len() {\n        for criterion in criteria {\n            if !matches_criterion(&soldiers[i], criterion) {\n                i += 1;\n                continue 'outer;\n            }\n        }\n\n        ids.push(soldiers[i].id);\n        i += 1;\n    }\n\n    ids\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let roster = parse_roster(\"roster.csv\")?;\n    let criteria = vec![(\"Squire\".to_string(), \"Sword\".to_string(), 10), (\"Knight\".to_string(), \"Sword\".to_string(), 5)];\n\n    let ids = search_roster(&roster, &criteria);\n    println!(\"Matching IDs: {:?}\", ids);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "53f98ac8-7775-4021-b261-ff142f0de0eb", "code": "use std::fmt;\n\n#[derive(Debug, PartialEq)]\nenum State {\n    Working,\n    Eating,\n    Distracted,\n    Sleeping,\n}\n\n#[derive(Debug, PartialEq)]\nenum Event {\n    Hunger,\n    Fly,\n    Nighttime,\n}\n\nimpl fmt::Display for State {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            State::Working => write!(f, \"Working\"),\n            State::Eating => write!(f, \"Eating\"),\n            State::Distracted => write!(f, \"Distracted\"),\n            State::Sleeping => write!(f, \"Sleeping\"),\n        }\n    }\n}\n\nfn transition(state: State, event: Event) -> State {\n    match (state, event) {\n        (State::Working, Event::Hunger) => State::Eating,\n        (State::Working | State::Eating | State::Distracted, Event::Fly) => State::Distracted,\n        (_ , Event::Nighttime) => State::Sleeping,\n        (state, _) => state,\n    }\n}\n\nfn main() {\n    let events = vec![\n        Event::Hunger,\n        Event::Fly,\n        Event::Nighttime,\n        Event::Hunger,\n        Event::Fly,\n    ];\n\n    let mut current_state = State::Working;\n\n    for event in events {\n        current_state = transition(current_state, event);\n        println!(\"Event: {:?}, State: {}\", event, current_state);\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "a4a04d10-7d3d-4f98-91ea-7b86d2627e57", "code": "use std::collections::HashMap;\nuse std::io::{BufRead, Write};\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::sync::mpsc;\nuse std::time::Duration;\nuse uuid::Uuid;\n\nfn handle_client(stream: TcpStream, client_id: Uuid, tx: mpsc::Sender<(Uuid, String)>) {\n    let mut stream = stream.try_clone().expect(\"Failed to clone stream\");\n    let mut buf_reader = std::io::BufReader::new(&mut stream);\n    let mut line = String::new();\n\n    loop {\n        if buf_reader.read_line(&mut line).unwrap() == 0 {\n            break;\n        }\n\n        let message = line.trim().to_string();\n        let _ = tx.send((client_id, message));\n\n        line.clear();\n    }\n}\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:8080\").expect(\"Failed to bind to address\");\n    let clients: Arc<Mutex<HashMap<Uuid, TcpStream>>> = Arc::new(Mutex::new(HashMap::new()));\n    let (tx, rx) = mpsc::channel();\n\n    // Spawn a thread to handle broadcasting messages to all clients\n    let clients_for_broadcast = Arc::clone(&clients);\n    thread::spawn(move || {\n        for (client_id, message) in rx.iter() {\n            let formatted_message = format!(\"{}: {}\", client_id, message);\n            println!(\"{}\", formatted_message);\n\n            let mut guard = clients_for_broadcast.lock().unwrap();\n            for (id, stream) in guard.iter_mut() {\n                if *id != client_id {\n                    let _ = stream.write_all(formatted_message.as_bytes());\n                    let _ = stream.write_all(b\"\\n\");\n                }\n            }\n        }\n    });\n\n    for stream in listener.incoming() {\n        let stream = stream.expect(\"Failed to establish a connection\");\n        let client_id = Uuid::new_v4();\n        let tx_for_client = tx.clone();\n\n        {\n            let mut guard = clients.lock().unwrap();\n            guard.insert(client_id, stream.try_clone().expect(\"Failed to clone stream\"));\n        }\n\n        thread::spawn(move || {\n            handle_client(stream, client_id, tx_for_client);\n        });\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "1bd19442-39a0-42ca-a3a6-4e1591268ca6", "code": "fn can_complete_circuit(energy: Vec<i32>, burn_rate: Vec<i32>) -> i32 {\n    let n = energy.len();\n    let mut total_energy = 0;\n    let mut current_energy = 0;\n    let mut start = 0;\n\n    for i in 0..n {\n        total_energy += energy[i] - burn_rate[i];\n        current_energy += energy[i] - burn_rate[i];\n\n        if current_energy < 0 {\n            current_energy = 0;\n            start = i + 1;\n        }\n    }\n\n    if total_energy >= 0 {\n        start as i32\n    } else {\n        -1\n    }\n}\n\nfn main() {\n    let energy = vec![1, 2, 3, 4, 5];\n    let burn_rate = vec![3, 4, 5, 1, 2];\n    let result = can_complete_circuit(energy, burn_rate);\n    println!(\"Starting index: {}\", result);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "a194d257-5056-4776-a006-037f3769b9fd", "code": "fn make_fibonacci() -> impl FnMut() -> u64 {\n    let mut a = 1;\n    let mut b = 1;\n    move || {\n        let next = a + b;\n        a = b;\n        b = next;\n        a\n    }\n}\n\nfn main() {\n    let mut fib = make_fibonacci();\n    for _ in 0..10 {\n        println!(\"{}\", fib());\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "724c6816-9190-4329-9cc3-0440c3b04fd0", "code": "use std::fmt::Display;\n\n// Define food types\nenum Food {\n    Bones(u32),\n    Meat(u32),\n    Seeds(u32),\n    Worms(u32),\n    Pizza(u32),\n    Salad(u32),\n}\n\n// Implement Display trait for Food\nimpl Display for Food {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            Food::Bones(_) => write!(f, \"bones\"),\n            Food::Meat(_) => write!(f, \"meat\"),\n            Food::Seeds(_) => write!(f, \"seeds\"),\n            Food::Worms(_) => write!(f, \"worms\"),\n            Food::Pizza(_) => write!(f, \"pizza\"),\n            Food::Salad(_) => write!(f, \"salad\"),\n        }\n    }\n}\n\n// Define Eater trait\ntrait Eater {\n    type Food;\n\n    fn eat(&mut self, food: Self::Food) -> String;\n}\n\n// Define animal types\nstruct Dog {\n    energy: u32,\n}\n\nstruct Bird {\n    energy: u32,\n}\n\nstruct Human {\n    energy: u32,\n}\n\nstruct Programmer {\n    energy: u32,\n}\n\n// Implement Eater trait for each animal type\nimpl Eater for Dog {\n    type Food = Food;\n\n    fn eat(&mut self, food: Food) -> String {\n        let calories = match food {\n            Food::Bones(calories) => calories,\n            Food::Meat(calories) => calories,\n            _ => 0,\n        };\n\n        self.energy += calories;\n        format!(\"The dog ate {} and gained {} energy\", food, calories)\n    }\n}\n\nimpl Eater for Bird {\n    type Food = Food;\n\n    fn eat(&mut self, food: Food) -> String {\n        let calories = match food {\n            Food::Seeds(calories) => calories,\n            Food::Worms(calories) => calories,\n            _ => 0,\n        };\n\n        self.energy += calories;\n        format!(\"The bird ate {} and gained {} energy\", food, calories)\n    }\n}\n\nimpl Eater for Human {\n    type Food = Food;\n\n    fn eat(&mut self, food: Food) -> String {\n        let calories = match food {\n            Food::Pizza(calories) => calories,\n            Food::Salad(calories) => calories,\n            _ => 0,\n        };\n\n        self.energy += calories;\n        format!(\"The human ate {} and gained {} energy\", food, calories)\n    }\n}\n\nimpl Eater for Programmer {\n    type Food = Food;\n\n    fn eat(&mut self, food: Food) -> String {\n        let calories = match food {\n            Food::Pizza(calories) | Food::Worms(calories) => calories,\n            _ => 0,\n        };\n\n        self.energy += calories;\n        format!(\"The programmer ate {} and gained {} energy\", food, calories)\n    }\n}\n\nfn main() {\n    let mut dog = Dog { energy: 10 };\n    let mut bird = Bird { energy: 5 };\n    let mut human = Human { energy: 20 };\n    let mut programmer = Programmer { energy: 30 };\n\n    println!(\"{}\", dog.eat(Food::Bones(5)));\n    println!(\"{}\", bird.eat(Food::Seeds(3)));\n    println!(\"{}\", human.eat(Food::Salad(4)));\n    println!(\"{}\", programmer.eat(Food::Worms(6)));\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "dca7facc-f805-4660-a291-10ef35f8f900", "code": "use serde::Deserialize;\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::BufReader;\nuse anyhow::Result;\n\n#[derive(Debug, Deserialize)]\nstruct Student {\n    name: String,\n    age: u8,\n    courses: Vec<String>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Course {\n    name: String,\n    teacher: String,\n}\n\nfn process_json_file<T: for<'de> Deserialize<'de>>(path: &str) -> Result<Vec<T>> {\n    let file = File::open(path)?;\n    let reader = BufReader::new(file);\n    let data = serde_json::from_reader(reader)?;\n    Ok(data)\n}\n\nfn do_they_share_teacher(\n    student_name_1: &str,\n    student_name_2: &str,\n    students: &[Student],\n    courses: &[Course],\n) -> bool {\n    let mut teacher_courses: HashMap<String, Vec<String>> = HashMap::new();\n\n    for course in courses {\n        teacher_courses\n            .entry(course.teacher.clone())\n            .or_insert_with(Vec::new)\n            .push(course.name.clone());\n    }\n\n    let student1_courses = students\n        .iter()\n        .find(|student| student.name == student_name_1)\n        .map(|student| &student.courses)\n        .unwrap_or(&vec![]);\n\n    let student2_courses = students\n        .iter()\n        .find(|student| student.name == student_name_2)\n        .map(|student| &student.courses)\n        .unwrap_or(&vec![]);\n\n    for (teacher, courses) in &teacher_courses {\n        if courses.iter().any(|course| student1_courses.contains(course))\n            && courses.iter().any(|course| student2_courses.contains(course))\n        {\n            return true;\n        }\n    }\n\n    false\n}\n\nfn main() -> Result<()> {\n    let students: Vec<Student> = process_json_file(\"students.json\")?;\n    let courses: Vec<Course> = process_json_file(\"courses.json\")?;\n\n    println!(\n        \"Do they share a teacher? {}\",\n        do_they_share_teacher(\"John Doe\", \"Jane Smith\", &students, &courses)\n    );\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "b717526c-a82c-4b6b-be53-cc87215e7491", "code": "use scheduler::Scheduler;\n\nfn main() {\n    let scheduler = Scheduler::new();\n\n    // Run a single task\n    let result: i32 = scheduler.run_task(|| 42);\n    assert_eq!(result, 42);\n\n    // Chain dependent tasks\n    let result: i32 = scheduler.run_chain(vec![\n        |x: i32| x * 2,\n        |x| x + 1,\n    ])(42);\n    assert_eq!(result, 85);\n\n    // Conditional execution\n    let result: Option<i32> = scheduler.run_conditional(|| 42, || true);\n    assert_eq!(result, Some(42));\n\n    let result: Option<i32> = scheduler.run_conditional(|| 42, || false);\n    assert_eq!(result, None);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "70d951aa-be03-4890-9afe-4cf7db11c9b1", "code": "use std::fmt;\n\n// Define the Collectible trait\ntrait Collectible {}\n\n// Define the Collector trait with an associated type\ntrait Collector {\n    type Item: Collectible;\n    fn add_item(&mut self, item: Self::Item);\n    fn remove_item(&mut self, item: &Self::Item);\n}\n\n// Define the GameObject trait\ntrait GameObject {\n    fn render(&self) -> String;\n    fn update(&mut self, dt: f64);\n}\n\n// Define the Sword struct that implements GameObject and Collectible\nstruct Sword {\n    damage: u32,\n}\n\nimpl GameObject for Sword {\n    fn render(&self) -> String {\n        format!(\"Sword with {} damage\", self.damage)\n    }\n    fn update(&mut self, dt: f64) {\n        // Update sword logic here\n    }\n}\n\nimpl Collectible for Sword {}\n\nimpl Sword {\n    fn new(damage: u32) -> Self {\n        Self { damage }\n    }\n    fn damage(&self) -> u32 {\n        self.damage\n    }\n}\n\n// Define the Chest struct that implements GameObject and Collectible\nstruct Chest {\n    swords: Vec<Sword>,\n}\n\nimpl GameObject for Chest {\n    fn render(&self) -> String {\n        format!(\"Chest with {} swords\", self.swords.len())\n    }\n    fn update(&mut self, dt: f64) {\n        // Update chest logic here\n    }\n}\n\nimpl Collectible for Chest {}\n\nimpl Chest {\n    fn new() -> Self {\n        Self { swords: Vec::new() }\n    }\n    fn add_sword(&mut self, sword: Sword) {\n        self.swords.push(sword);\n    }\n    fn remove_sword(&mut self, sword: &Sword) {\n        self.swords.retain(|s| !std::ptr::eq(s, sword));\n    }\n    fn swords(&self) -> &Vec<Sword> {\n        &self.swords\n    }\n}\n\n// Define the Player struct that implements GameObject and Collector\nstruct Player {\n    chests: Vec<Chest>,\n}\n\nimpl GameObject for Player {\n    fn render(&self) -> String {\n        format!(\"Player with {} chests\", self.chests.len())\n    }\n    fn update(&mut self, dt: f64) {\n        // Update player logic here\n    }\n}\n\nimpl Collector for Player {\n    type Item = Chest;\n    fn add_item(&mut self, chest: Chest) {\n        self.chests.push(chest);\n    }\n    fn remove_item(&mut self, chest: &Chest) {\n        self.chests.retain(|c| !std::ptr::eq(c, chest));\n    }\n}\n\nimpl Player {\n    fn new() -> Self {\n        Self { chests: Vec::new() }\n    }\n    fn chests(&self) -> &Vec<Chest> {\n        &self.chests\n    }\n    fn swords(&self) -> Vec<&Sword> {\n        self.chests()\n            .iter()\n            .flat_map(|chest| chest.swords().iter())\n            .collect()\n    }\n}\n\nfn main() {\n    let mut player = Player::new();\n    let chest = Chest::new();\n    let sword1 = Sword::new(10);\n    let sword2 = Sword::new(20);\n\n    chest.add_sword(sword1);\n    chest.add_sword(sword2);\n    player.add_item(chest);\n\n    println!(\"Player has {} chests\", player.chests().len());\n    println!(\"Player has {} swords\", player.swords().len());\n\n    player.remove_item(&chest);\n\n    println!(\"Player has {} chests\", player.chests().len());\n    println!(\"Player has {} swords\", player.swords().len());\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "bbccddec-2603-4812-b140-583931cfccbb", "code": "use chrono::{DateTime, Utc};\nuse itertools::Itertools;\nuse serde::{Deserialize, Serialize};\nuse serde_json;\nuse std::collections::{HashMap, VecDeque};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum CacheError {\n    #[error(\"JSON serialization error\")]\n    SerializeError(#[from] serde_json::Error),\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct CacheItem<T> {\n    value: T,\n    last_access: DateTime<Utc>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LRUCache<T> {\n    capacity: usize,\n    map: HashMap<String, CacheItem<T>>,\n    queue: VecDeque<String>,\n}\n\nimpl<T: Clone> LRUCache<T> {\n    pub fn new(capacity: usize) -> Self {\n        LRUCache {\n            capacity,\n            map: HashMap::new(),\n            queue: VecDeque::new(),\n        }\n    }\n\n    pub fn get(&mut self, key: &str) -> Option<&T> {\n        if let Some(cache_item) = self.map.get_mut(key) {\n            cache_item.last_access = Utc::now();\n            if let Some(pos) = self.queue.iter().position(|k| k == key) {\n                self.queue.remove(pos);\n            }\n            self.queue.push_back(key.to_string());\n            Some(&cache_item.value)\n        } else {\n            None\n        }\n    }\n\n    pub fn put(&mut self, key: String, value: T) {\n        if self.map.contains_key(&key) {\n            self.get(&key);\n        } else {\n            if self.queue.len() >= self.capacity {\n                let evicted_key = self.queue.pop_front().unwrap();\n                self.map.remove(&evicted_key);\n            }\n            self.queue.push_back(key.clone());\n        }\n        self.map.insert(\n            key,\n            CacheItem {\n                value,\n                last_access: Utc::now(),\n            },\n        );\n    }\n\n    pub fn to_json(&self) -> Result<String, CacheError> {\n        Ok(serde_json::to_string(self)?)\n    }\n\n    pub fn from_json(json: &str) -> Result<Self, CacheError> {\n        Ok(serde_json::from_str(json)?)\n    }\n}\n\nfn main() {\n    let mut cache = LRUCache::new(2);\n    cache.put(\"one\".to_string(), 1);\n    cache.put(\"two\".to_string(), 2);\n    assert_eq!(cache.get(\"one\"), Some(&1));\n    cache.put(\"three\".to_string(), 3);\n    assert_eq!(cache.get(\"two\"), None);\n    assert_eq!(cache.get(\"three\"), Some(&3));\n    cache.put(\"four\".to_string(), 4);\n    assert_eq!(cache.get(\"one\"), None);\n    assert_eq!(cache.get(\"three\"), Some(&3));\n    assert_eq!(cache.get(\"four\"), Some(&4));\n    let json = cache.to_json().unwrap();\n    let deserialized_cache = LRUCache::from_json(&json).unwrap();\n    assert_eq!(deserialized_cache.get(\"three\"), Some(&3));\n    assert_eq!(deserialized_cache.get(\"four\"), Some(&4));\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "13336111-8997-4a77-aea3-0094f7585c5c", "code": "// Movie Struct\nstruct Movie {\n    // Fields here\n}\n\n// Rental Struct\nstruct Rental {\n    // Fields here\n}\n\n// Customer Struct\nstruct Customer {\n    // Fields here\n}\n\n// Store Struct\nstruct Store {\n    // Fields here\n}\n\n// Implement methods on Store Struct\nimpl Store {\n    // Methods here\n}\n\n// Implement methods on Customer Struct\nimpl Customer {\n    // Methods here\n}\n\n// Implement methods on Rental Struct\nimpl Rental {\n    // Methods here\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new store\n    let mut store = Store::new();\n\n    // Add some movies to the store\n    // Create some customers\n    // Simulate renting and returning movies\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "b24f0b01-b4e4-4ddd-8e5a-11e69996a676", "code": "use std::cmp::max;\nuse std::collections::VecDeque;\n\nfn max_rectangle(matrix: &Vec<Vec<i32>>, x: i32, y: i32) -> i32 {\n    let rows = matrix.len();\n    if rows == 0 {\n        return 0;\n    }\n    let cols = matrix[0].len();\n\n    let mut heights = vec![0; cols];\n    let mut max_area = 0;\n\n    for i in 0..rows {\n        for j in 0..cols {\n            if matrix[i][j] % x == 0 && matrix[i][j] > y {\n                heights[j] += 1;\n            } else {\n                heights[j] = 0;\n            }\n        }\n\n        let mut stack = VecDeque::new();\n        for j in 0..cols {\n            while !stack.is_empty() && heights[*stack.back().unwrap()] >= heights[j] {\n                let height = heights[stack.pop_back().unwrap()];\n                let width = if stack.is_empty() {\n                    j as i32\n                } else {\n                    j as i32 - stack.back().unwrap() - 1\n                };\n                max_area = max(max_area, height * width);\n            }\n            stack.push_back(j);\n        }\n\n        while !stack.is_empty() {\n            let height = heights[stack.pop_back().unwrap()];\n            let width = if stack.is_empty() {\n                cols as i32\n            } else {\n                cols as i32 - stack.back().unwrap() - 1\n            };\n            max_area = max(max_area, height * width);\n        }\n    }\n\n    max_area\n}\n\nfn main() {\n    let matrix = vec![\n        vec![2, 4, 6, 8],\n        vec![10, 12, 14, 16],\n        vec![18, 20, 22, 24],\n    ];\n    let x = 2;\n    let y = 5;\n    println!(\"The area of the largest rectangle is: {}\", max_rectangle(&matrix, x, y));\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "d36db659-cb5f-4b8c-88df-97f5750d2176", "code": "use std::fs::File;\nuse std::io::{self, BufRead};\nuse std::cmp::Ordering;\n\nfn main() -> io::Result<()> {\n    let file = File::open(\"meetings.txt\")?;\n    let mut meetings: Vec<(i64, i64)> = Vec::new();\n\n    for line in io::BufReader::new(file).lines() {\n        let line = line?;\n        let mut iter = line.split_whitespace();\n        let start_time = iter.next().unwrap().parse::<i64>().unwrap();\n        let end_time = iter.next().unwrap().parse::<i64>().unwrap();\n        meetings.push((start_time, end_time));\n    }\n\n    meetings.sort_by(|a, b| a.0.cmp(&b.0));\n\n    let mut rooms = 0;\n    let mut end_times: Vec<i64> = Vec::new();\n\n    for meeting in meetings {\n        match end_times.binary_search(&meeting.0) {\n            Ok(index) => {\n                end_times[index] = meeting.1;\n            }\n            Err(index) => {\n                if index < rooms {\n                    end_times[index] = meeting.1;\n                } else {\n                    end_times.push(meeting.1);\n                    rooms += 1;\n                }\n            }\n        }\n    }\n\n    println!(\"{}\", rooms);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "4b9b2197-5938-4af0-aaaf-e95cda7be2ec", "code": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse tokio::sync::RwLock;\nuse thiserror::Error;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum TaskState {\n    Todo,\n    InProgress,\n    Completed,\n    Blocked,\n}\n\n#[derive(Error, Debug)]\nenum TaskError {\n    #[error(\"Task not found\")]\n    NotFound,\n    #[error(\"Invalid state transition\")]\n    InvalidTransition,\n    #[error(\"Concurrent modification\")]\n    ConcurrentModification,\n}\n\nstruct Task {\n    state: Arc<RwLock<TaskState>>,\n}\n\nstruct TaskManager {\n    tasks: Arc<Mutex<HashMap<usize, Task>>>,\n}\n\nimpl TaskManager {\n    fn new() -> Self {\n        TaskManager {\n            tasks: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    async fn update_state(\n        &self,\n        task_id: usize,\n        new_state: TaskState,\n    ) -> Result<TaskState, TaskError> {\n        let tasks = self.tasks.lock().unwrap();\n        let task = tasks.get(&task_id).ok_or(TaskError::NotFound)?;\n\n        let mut state = task.state.write().await;\n        let old_state = state.clone();\n\n        if !is_valid_transition(&old_state, &new_state) {\n            return Err(TaskError::InvalidTransition);\n        }\n\n        *state = new_state;\n        Ok(old_state)\n    }\n\n    async fn get_state(&self, task_id: usize) -> Result<TaskState, TaskError> {\n        let tasks = self.tasks.lock().unwrap();\n        let task = tasks.get(&task_id).ok_or(TaskError::NotFound)?;\n\n        let state = task.state.read().await;\n        Ok(state.clone())\n    }\n\n    async fn add_task(&self, task_id: usize, initial_state: TaskState) -> Result<(), TaskError> {\n        let mut tasks = self.tasks.lock().unwrap();\n\n        if tasks.contains_key(&task_id) {\n            return Err(TaskError::ConcurrentModification);\n        }\n\n        let task = Task {\n            state: Arc::new(RwLock::new(initial_state)),\n        };\n\n        tasks.insert(task_id, task);\n        Ok(())\n    }\n}\n\nfn is_valid_transition(old_state: &TaskState, new_state: &TaskState) -> bool {\n    match (old_state, new_state) {\n        (TaskState::Todo, TaskState::InProgress)\n        | (TaskState::InProgress, TaskState::Completed)\n        | (TaskState::InProgress, TaskState::Blocked)\n        | (TaskState::Blocked, TaskState::InProgress) => true,\n        _ => false,\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let task_manager = TaskManager::new();\n    task_manager.add_task(1, TaskState::Todo).await.unwrap();\n\n    let updated_state = task_manager\n        .update_state(1, TaskState::InProgress)\n        .await\n        .unwrap();\n\n    assert_eq!(updated_state, TaskState::Todo);\n\n    let current_state = task_manager.get_state(1).await.unwrap();\n    assert_eq!(current_state, TaskState::InProgress);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "1dc0ac25-ee3c-4b9f-a76b-11e9012e8da4", "code": "// Example usage\nfn main() {\n    let tree = tree!(\"root\",\n        tree!(\"child1\",\n            tree!(\"grandchild1\"),\n            tree!(\"grandchild2\")\n        ),\n        tree!(\"child2\")\n    );\n    println!(\"{:?}\", tree);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "a4a04d10-7d3d-4f98-91ea-7b86d2627e57", "code": "use std::io::{self, BufRead, Write};\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::mpsc;\nuse std::sync::Mutex;\nuse std::thread;\n\nstruct Message {\n    id: usize,\n    text: String,\n}\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:8080\").expect(\"Failed to bind\");\n    println!(\"Server listening on port 8080\");\n\n    let (tx, rx) = mpsc::channel();\n    let messages = Mutex::new(Vec::new());\n\n    // Spawn a thread to handle incoming connections\n    thread::spawn(move || {\n        for stream in listener.incoming() {\n            let stream = stream.unwrap();\n            let tx = tx.clone();\n            let messages = messages.clone();\n\n            thread::spawn(move || {\n                handle_client(stream, tx, messages);\n            });\n        }\n    });\n\n    // In the main thread, listen for messages and broadcast them to all clients\n    for message in rx {\n        let mut messages = messages.lock().unwrap();\n        messages.push(message);\n\n        println!(\"New message: {}\", message.text);\n\n        // Broadcast the message to all clients\n        for message in messages.iter() {\n            // Send the message to each client (not implemented)\n        }\n    }\n}\n\nfn handle_client(mut stream: TcpStream, tx: mpsc::Sender<Message>, messages: Mutex<Vec<Message>>) {\n    let mut buffer = String::new();\n    let reader = stream.by_ref().take(1024);\n\n    // Send all previous messages to the new client\n    let messages = messages.lock().unwrap();\n    for message in messages.iter() {\n        writeln!(stream, \"{}: {}\", message.id, message.text).expect(\"Failed to write to stream\");\n    }\n\n    // Listen for new messages from the client\n    for line in reader.lines() {\n        let line = line.expect(\"Failed to read line\");\n\n        let message = Message {\n            id: 0, // Placeholder, you can generate unique IDs here\n            text: line,\n        };\n\n        tx.send(message).expect(\"Failed to send message\");\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "1dc0ac25-ee3c-4b9f-a76b-11e9012e8da4", "code": "#[macro_use]\nmod tree_macro {\n    macro_rules! tree {\n        ($val:expr) => {\n            Tree::Leaf($val)\n        };\n        ($val:expr, $($child:expr),*) => {\n            Tree::Node($val, vec![$(tree!($child)),*])\n        };\n    }\n\n    #[derive(Clone)]\n    pub enum Tree<T> {\n        Leaf(T),\n        Node(T, Vec<Tree<T>>),\n    }\n\n    pub fn create_tree<T: Clone>(value: T, children: Vec<Tree<T>>) -> Tree<T> {\n        Tree::Node(value, children)\n    }\n\n    pub fn print_tree<T: std::fmt::Display>(tree: &Tree<T>) {\n        fn print_node<T: std::fmt::Display>(tree: &Tree<T>, depth: usize) {\n            let indent = \"    \".repeat(depth);\n            match tree {\n                Tree::Leaf(val) => println!(\"{}{}\", indent, val),\n                Tree::Node(val, children) => {\n                    println!(\"{}{}\", indent, val);\n                    for child in children {\n                        print_node(child, depth + 1);\n                    }\n                }\n            }\n        }\n        print_node(tree, 0);\n    }\n}\n\nfn main() {\n    let tree = tree!(\"A\", \"B\", tree!(\"C\", \"D\", \"E\"), \"F\");\n    tree_macro::print_tree(&tree);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "9ed01fca-89ea-46da-bd9d-fa7dd4ff88e5", "code": "use chrono::{DateTime, Duration, Utc};\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\ntype Key = Uuid;\ntype Value = String;\n\n// This is just a simple example of a custom eviction policy. You can create your own.\nenum EvictionPolicy {\n    LRU,\n    FIFO,\n    Custom(Box<dyn FnMut(&Key, &Value, &DateTime<Utc>) -> bool>),\n}\n\nstruct CacheEntry {\n    value: Value,\n    expiration_time: DateTime<Utc>,\n}\n\nstruct Cache {\n    capacity: usize,\n    entries: Arc<Mutex<HashMap<Key, CacheEntry>>>,\n    eviction_policy: EvictionPolicy,\n    // Add any other fields needed for implementing the eviction policies.\n}\n\nimpl Cache {\n    fn new(capacity: usize, eviction_policy: EvictionPolicy) -> Self {\n        // Implement the constructor.\n    }\n\n    fn get(&self, key: &Key) -> Option<&Value> {\n        // Implement the get method.\n    }\n\n    fn put(&self, key: Key, value: Value, ttl: Duration) {\n        // Implement the put method.\n    }\n\n    fn remove(&self, key: &Key) {\n        // Implement the remove method.\n    }\n\n    fn bulk_put(&self, entries: Vec<(Key, Value, Duration)>) {\n        // Implement the bulk_put method.\n    }\n\n    fn bulk_remove(&self, keys: Vec<Key>) {\n        // Implement the bulk_remove method.\n    }\n\n    // Implement any other methods needed for implementing the eviction policies.\n}\n\n#[derive(Serialize, Deserialize)]\nstruct SerializedCache {\n    capacity: usize,\n    entries: HashMap<Key, CacheEntry>,\n    eviction_policy: EvictionPolicy,\n}\n\nimpl Cache {\n    fn serialize(&self) -> String {\n        // Implement the serialize method.\n    }\n\n    fn deserialize(serialized_cache: &str) -> Result<Self, anyhow::Error> {\n        // Implement the deserialize method.\n    }\n}\n\nfn main() {\n    // Implement the main function.\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "eadad3f4-5e40-4e49-85e8-8a00dceec642", "code": "use std::sync::{Arc, Mutex};\n\n#[derive(Debug)]\nstruct BookStats {\n    times_checked_out: u32,\n    currently_checked_out: bool,\n}\n\nstruct Book {\n    title: String,\n    stats: Arc<Mutex<BookStats>>,\n}\n\nimpl Book {\n    fn new(title: String) -> Self {\n        Book {\n            title,\n            stats: Arc::new(Mutex::new(BookStats {\n                times_checked_out: 0,\n                currently_checked_out: false,\n            })),\n        }\n    }\n\n    fn checkout(&mut self) -> Result<(), &'static str> {\n        let mut stats = self.stats.lock().unwrap();\n        if stats.currently_checked_out {\n            Err(\"Book is already checked out\")\n        } else {\n            stats.times_checked_out += 1;\n            stats.currently_checked_out = true;\n            Ok(())\n        }\n    }\n\n    fn return_book(&mut self) -> Result<(), &'static str> {\n        let mut stats = self.stats.lock().unwrap();\n        if stats.currently_checked_out {\n            stats.currently_checked_out = false;\n            Ok(())\n        } else {\n            Err(\"Book is not checked out\")\n        }\n    }\n\n    fn get_checkout_count(&self) -> u32 {\n        let stats = self.stats.lock().unwrap();\n        stats.times_checked_out\n    }\n\n    fn is_checked_out(&self) -> bool {\n        let stats = self.stats.lock().unwrap();\n        stats.currently_checked_out\n    }\n}\n\nfn main() {\n    let mut book = Book::new(\"War and Peace\".to_string());\n    book.checkout().unwrap();\n    book.checkout().unwrap_err();\n    assert_eq!(book.get_checkout_count(), 1);\n    assert!(book.is_checked_out());\n    book.return_book().unwrap();\n    book.return_book().unwrap_err();\n    assert_eq!(book.get_checkout_count(), 1);\n    assert!(!book.is_checked_out());\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "7557bbb4-c20e-4bed-9912-e807ed9dd7a3", "code": "#[derive(Debug, Clone, Copy, PartialEq)]\nenum CatState {\n    Resting,\n    Playing,\n    Hunting,\n    Grooming,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\nenum CatEvent {\n    BellSound,\n    BirdSpotted,\n    Sunshine,\n}\n\nimpl CatState {\n    fn transition(&self, event: CatEvent) -> CatState {\n        match (self, event) {\n            (CatState::Resting | CatState::Grooming, CatEvent::BellSound) => CatState::Playing,\n            (CatState::Playing | CatState::Resting, CatEvent::BirdSpotted) => CatState::Hunting,\n            (_, CatEvent::Sunshine) => CatState::Grooming,\n            _ => *self,\n        }\n    }\n}\n\nfn main() {\n    let mut cat_state = CatState::Resting;\n\n    cat_state = cat_state.transition(CatEvent::BellSound);\n    println!(\"After bell sound: {:?}\", cat_state);\n\n    cat_state = cat_state.transition(CatEvent::BirdSpotted);\n    println!(\"After bird spotted: {:?}\", cat_state);\n\n    cat_state = cat_state.transition(CatEvent::Sunshine);\n    println!(\"After sunshine: {:?}\", cat_state);\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "7c98c28a-2acd-4c7c-a74e-043538947c8e", "code": "use std::collections::HashSet;\n\n// Define the Soldier struct with the given fields\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\nstruct Soldier {\n    id: u32,\n    rank: String,\n    given_name: String,\n    family_name: String,\n    weapon: String,\n    years_of_service: u32,\n}\n\n// Define the search criterion tuple\ntype SearchCriterion = (String, String, u32);\n\n// Define the function to find the shortest contiguous sequence of IDs\nfn find_shortest_sequence(roster: &[Soldier], search_criteria: &[SearchCriterion]) -> Option<Vec<u32>> {\n    let mut min_sequence = None;\n\n    // Iterate over all possible starting and ending indices of the sequence\n    for start in 0..roster.len() {\n        for end in start..roster.len() {\n            // Extract the sequence of soldiers between the starting and ending indices\n            let sequence: HashSet<_> = roster[start..=end].iter().map(|s| (s.id, &s.rank, &s.weapon, s.years_of_service)).collect();\n\n            // Check if the sequence matches all the search criteria\n            if search_criteria.iter().all(|(rank, weapon, years_of_service)| {\n                sequence.iter().any(|(id, &r, &w, y)| r == *rank && w == *weapon && y >= *years_of_service)\n            }) {\n                // Update the minimum sequence if necessary\n                if min_sequence.as_ref().map_or(true, |s| sequence.len() < s.len()) {\n                    min_sequence = Some(sequence.iter().map(|(id, _, _, _)| *id).collect());\n                }\n            }\n        }\n    }\n\n    min_sequence\n}\n\nfn main() {\n    // Define the roster of soldiers\n    let roster = vec![\n        Soldier { id: 1, rank: \"Squire\".to_string(), given_name: \"Ivan\".to_string(), family_name: \"Ironfist\".to_string(), weapon: \"Sword\".to_string(), years_of_service: 5 },\n        // ... (other soldiers)\n    ];\n\n    // Define the search criteria\n    let search_criteria = vec![\n        (\"Knight\".to_string(), \"Sword\".to_string(), 5),\n        (\"Squire\".to_string(), \"Spear\".to_string(), 10),\n        (\"Captain\".to_string(), \"Bow\".to_string(), 15),\n    ];\n\n    // Find the shortest contiguous sequence of IDs\n    if let Some(sequence) = find_shortest_sequence(&roster, &search_criteria) {\n        println!(\"Shortest contiguous sequence of IDs: {:?}\", sequence);\n    } else {\n        println!(\"No sequence found that matches all the search criteria.\");\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "34fa31b7-de3c-4fd3-b6d7-06dab4853ad7", "code": "use std::collections::HashMap;\nuse std::fs;\nuse serde::Deserialize;\nuse serde_json::Value;\n\n#[derive(Deserialize)]\nstruct Soldier {\n    id: String,\n    superior_id: Option<String>,\n    name: String,\n    age: u8,\n    city: String,\n}\n\nfn build_hierarchy(soldiers: Vec<Soldier>) -> HashMap<String, Vec<String>> {\n    let mut hierarchy: HashMap<String, Vec<String>> = HashMap::new();\n    for soldier in soldiers {\n        if let Some(superior_id) = soldier.superior_id {\n            hierarchy.entry(superior_id).or_default().push(soldier.id);\n        }\n        hierarchy.entry(soldier.id).or_default();\n    }\n    hierarchy\n}\n\nfn lowest_common_ancestor(id1: &str, id2: &str, hierarchy: &HashMap<String, Vec<String>>) -> Option<String> {\n    let mut ancestors1 = vec![];\n    let mut current_id = Some(id1);\n    while let Some(id) = current_id {\n        ancestors1.push(id);\n        current_id = hierarchy.get(id).and_then(|subordinates| subordinates.first()).cloned();\n    }\n\n    let mut current_id = Some(id2);\n    while let Some(id) = current_id {\n        if ancestors1.contains(&id) {\n            return Some(id.to_string());\n        }\n        current_id = hierarchy.get(id).and_then(|subordinates| subordinates.first()).cloned();\n    }\n\n    None\n}\n\nfn get_chain_of_command(id: &str, hierarchy: &HashMap<String, Vec<String>>) -> Vec<String> {\n    let mut chain = vec![];\n    let mut current_id = Some(id);\n    while let Some(id) = current_id {\n        chain.push(id.to_string());\n        current_id = hierarchy.get(id).and_then(|subordinates| subordinates.first()).cloned();\n    }\n    chain.reverse();\n    chain\n}\n\nfn get_soldiers_in_city(city: &str, soldiers: &[Soldier]) -> Vec<String> {\n    soldiers.iter().filter(|soldier| soldier.city == city).map(|soldier| soldier.id.clone()).collect()\n}\n\nfn get_soldiers_with_age_range(min_age: u8, max_age: u8, soldiers: &[Soldier]) -> Vec<String> {\n    soldiers.iter().filter(|soldier| soldier.age >= min_age && soldier.age <= max_age).map(|soldier| soldier.id.clone()).collect()\n}\n\nfn main() {\n    let file = fs::File::open(\"soldiers.json\").expect(\"Unable to open file\");\n    let soldiers: Vec<Soldier> = serde_json::from_reader(file).expect(\"Unable to parse JSON\");\n    let hierarchy = build_hierarchy(soldiers);\n\n    println!(\"Lowest common ancestor of '3' and '4': {:?}\", lowest_common_ancestor(\"3\", \"4\", &hierarchy));\n    println!(\"Chain of command for '2': {:?}\", get_chain_of_command(\"2\", &hierarchy));\n    println!(\"Soldiers in city 'A': {:?}\", get_soldiers_in_city(\"A\", &soldiers));\n    println!(\"Soldiers with age between 20 and 30: {:?}\", get_soldiers_with_age_range(20, 30, &soldiers));\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "6bbd409d-594c-4bb0-91f6-d60b157e01a1", "code": "use std::collections::HashMap;\nuse uuid::Uuid;\n\n#[derive(Clone, Debug, Default)]\npub struct KeyValueStore {\n    store: HashMap<Uuid, String>,\n}\n\nimpl KeyValueStore {\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    pub fn put(&mut self, key: Uuid, value: String) {\n        self.store.insert(key, value);\n    }\n\n    pub fn get(&self, key: &Uuid) -> Option<&String> {\n        self.store.get(key)\n    }\n\n    pub fn delete(&mut self, key: &Uuid) -> Option<String> {\n        self.store.remove(key)\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "722c1da2-8f2e-4806-839c-78aacb3f5f5d", "code": "pub struct Queue<T> {\n    elements: Vec<T>,\n}\n\nimpl<T> Queue<T> {\n    pub fn new() -> Self {\n        Queue { elements: Vec::new() }\n    }\n\n    pub fn push(&mut self, item: T) {\n        self.elements.push(item);\n    }\n\n    pub fn pop(&mut self) -> Option<T> {\n        self.elements.pop()\n    }\n\n    pub fn peek(&self) -> Option<&T> {\n        self.elements.last()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.elements.is_empty()\n    }\n\n    pub fn len(&self) -> usize {\n        self.elements.len()\n    }\n}\n\nfn main() {\n    let mut queue: Queue<i32> = Queue::new();\n\n    queue.push(1);\n    queue.push(2);\n    queue.push(3);\n\n    println!(\"Peek: {:?}\", queue.peek());\n    println!(\"Pop: {:?}\", queue.pop());\n    println!(\"Peek: {:?}\", queue.peek());\n    println!(\"Is empty: {}\", queue.is_empty());\n    println!(\"Length: {}\", queue.len());\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "56e0e937-1f8b-49b1-b72e-116b1d49b95a", "code": "use std::collections::HashMap;\nuse std::net::SocketAddr;\nuse std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\n\nuse futures::stream::{Stream, StreamExt};\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Client, Method, Request, Response, Server, StatusCode};\nuse tokio::sync::oneshot;\nuse tokio::time::interval;\n\n#[derive(Clone)]\nstruct ClientInfo {\n    ip: SocketAddr,\n    token_bucket: Arc<Mutex<TokenBucket>>,\n}\n\nstruct TokenBucket {\n    capacity: usize,\n    refill_rate: usize,\n    tokens: usize,\n    last_refill_time: Instant,\n}\n\nimpl TokenBucket {\n    fn new(capacity: usize, refill_rate: usize) -> Self {\n        Self {\n            capacity,\n            refill_rate,\n            tokens: capacity,\n            last_refill_time: Instant::now(),\n        }\n    }\n\n    fn consume_token(&mut self) -> bool {\n        self.refill_tokens();\n        if self.tokens > 0 {\n            self.tokens -= 1;\n            true\n        } else {\n            false\n        }\n    }\n\n    fn refill_tokens(&mut self) {\n        let now = Instant::now();\n        let elapsed_time = now.duration_since(self.last_refill_time).as_secs() as usize;\n        let tokens_to_add = elapsed_time * self.refill_rate;\n        self.tokens = std::cmp::min(self.capacity, self.tokens + tokens_to_add);\n        self.last_refill_time = now;\n    }\n}\n\nasync fn handle_request(\n    req: Request<Body>,\n    client_info: ClientInfo,\n    client: Client<hyper::client::HttpConnector>,\n) -> Result<Response<Body>, hyper::Error> {\n    let mut token_bucket = client_info.token_bucket.lock().unwrap();\n    if token_bucket.consume_token() {\n        let res = client.request(req).await?;\n        Ok(res)\n    } else {\n        Ok(Response::builder()\n            .status(StatusCode::TOO_MANY_REQUESTS)\n            .body(Body::from(\"Too many requests\"))\n            .unwrap())\n    }\n}\n\nasync fn refresh_token_bucket(client_info: Arc<ClientInfo>) {\n    let mut interval = interval(Duration::from_secs(1));\n    loop {\n        interval.tick().await;\n        let mut token_bucket = client_info.token_bucket.lock().unwrap();\n        token_bucket.refill_tokens();\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));\n    let client = Client::new();\n    let mut clients_info: HashMap<SocketAddr, Arc<ClientInfo>> = HashMap::new();\n\n    let make_service = make_service_fn(|_conn| {\n        let client_info = {\n            let client_addr = _conn.remote_addr();\n            clients_info\n                .entry(client_addr)\n                .or_insert_with(|| {\n                    Arc::new(ClientInfo {\n                        token_bucket: Arc::new(Mutex::new(TokenBucket::new(10, 1))),\n                    })\n                })\n                .clone()\n        };\n        let client = client.clone();\n\n        let service = service_fn(move |req| {\n            let client_info = client_info.clone();\n            let client = client.clone();\n            async move {\n                let response = handle_request(req, (*client_info).clone(), client).await?;\n                Ok::<_, Infallible>(response)\n            }\n        });\n\n        let client_info = client_info.clone();\n        tokio::spawn(async move {\n            refresh_token_bucket(client_info).await;\n        });\n\n        async { Ok::<_, Infallible>(service) }\n    });\n\n    let server = Server::bind(&addr).serve(make_service);\n\n    println!(\"Listening on http://{}\", addr);\n\n    if let Err(e) = server.await {\n        eprintln!(\"server error: {}\", e);\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "bbc7e7a8-9aaf-4da2-8225-8ef8be731f6a", "code": "fn main() {\n    let mut exchange_rate_calculator = ExchangeRateCalculator::new();\n    exchange_rate_calculator.add_exchange_rate(\"USD\", \"EUR\", 0.85);\n    println!(\"1 USD is {} EUR\", exchange_rate_calculator.get_exchange_rate(\"USD\", \"EUR\").unwrap());\n    println!(\"1 EUR is {} USD\", exchange_rate_calculator.get_exchange_rate(\"EUR\", \"USD\").unwrap());\n    println!(\"10 USD is {} EUR\", exchange_rate_calculator.convert(\"USD\", \"EUR\", 10.0).unwrap());\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "ee888d19-5869-46fb-a6c4-3259eb90431f", "code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io;\nuse chrono::{DateTime, Local, NaiveDate};\nuse csv::Writer;\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct User {\n    id: Uuid,\n    name: String,\n    birthdate: NaiveDate,\n    cars: Vec<Uuid>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Car {\n    id: Uuid,\n    brand: String,\n    model: String,\n    users: Vec<Uuid>,\n}\n\nstruct CarUserTracker {\n    users: HashMap<Uuid, User>,\n    cars: HashMap<Uuid, Car>,\n}\n\nimpl CarUserTracker {\n    fn new() -> Self {\n        CarUserTracker {\n            users: HashMap::new(),\n            cars: HashMap::new(),\n        }\n    }\n\n    fn add_user(&mut self, name: String, birthdate: NaiveDate) {\n        let id = Uuid::new_v4();\n        let user = User {\n            id,\n            name,\n            birthdate,\n            cars: Vec::new(),\n        };\n        self.users.insert(id, user);\n    }\n\n    fn add_car(&mut self, brand: String, model: String) {\n        let id = Uuid::new_v4();\n        let car = Car {\n            id,\n            brand,\n            model,\n            users: Vec::new(),\n        };\n        self.cars.insert(id, car);\n    }\n\n    fn assign_car_to_user(&mut self, user_id: Uuid, car_id: Uuid) {\n        if let (Some(user), Some(car)) = (self.users.get_mut(&user_id), self.cars.get_mut(&car_id)) {\n            user.cars.push(car_id);\n            car.users.push(user_id);\n        }\n    }\n\n    // Implement the remaining methods...\n}\n\nfn main() {\n    let mut tracker = CarUserTracker::new();\n    // Add some users and cars for testing...\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "6bbd409d-594c-4bb0-91f6-d60b157e01a1", "code": "use std::collections::HashMap;\nuse std::sync::{Arc, RwLock};\nuse tokio::net::TcpListener;\nuse tokio::sync::mpsc;\n\n// Define your data structures here (e.g., KeyValueStore, Operation, etc.).\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Parse command-line arguments or configuration to determine the node's address and its peers.\n\n    let store = Arc::new(RwLock::new(HashMap::new()));\n    let (tx, mut rx) = mpsc::channel(100);\n\n    // Spawn tasks for handling incoming TCP connections and processing operations.\n\n    // Implement gossip protocol to propagate updates to peers.\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "81432bcc-0ac3-4806-97ec-147fee390413", "code": "use std::collections::{HashMap, HashSet, VecDeque};\n\n#[derive(Debug)]\nstruct User {\n    username: String,\n    name: String,\n    age: u32,\n    friends: HashSet<String>,\n}\n\nstruct SocialNetwork {\n    users: HashMap<String, User>,\n}\n\nimpl SocialNetwork {\n    fn new() -> Self {\n        SocialNetwork {\n            users: HashMap::new(),\n        }\n    }\n\n    fn add_user(&mut self, username: String, name: String, age: u32) {\n        let user = User {\n            username: username.clone(),\n            name,\n            age,\n            friends: HashSet::new(),\n        };\n        self.users.insert(username, user);\n    }\n\n    fn remove_user(&mut self, username: &str) {\n        if let Some(user) = self.users.remove(username) {\n            for friend in &user.friends {\n                if let Some(friend_user) = self.users.get_mut(friend) {\n                    friend_user.friends.remove(username);\n                }\n            }\n        }\n    }\n\n    fn add_friendship(&mut self, username1: &str, username2: &str) {\n        if let Some(user1) = self.users.get_mut(username1) {\n            if let Some(user2) = self.users.get_mut(username2) {\n                user1.friends.insert(username2.to_string());\n                user2.friends.insert(username1.to_string());\n            }\n        }\n    }\n\n    fn get_friends(&self, username: &str) -> Option<&HashSet<String>> {\n        self.users.get(username).map(|user| &user.friends)\n    }\n\n    fn remove_friendship(&mut self, username1: &str, username2: &str) {\n        if let Some(user1) = self.users.get_mut(username1) {\n            if let Some(user2) = self.users.get_mut(username2) {\n                user1.friends.remove(username2);\n                user2.friends.remove(username1);\n            }\n        }\n    }\n\n    fn shortest_path(&self, start: &str, end: &str) -> Option<Vec<String>> {\n        let mut visited = HashSet::new();\n        let mut queue = VecDeque::new();\n        let mut path = HashMap::new();\n\n        visited.insert(start.to_string());\n        queue.push_back(start.to_string());\n\n        while let Some(current) = queue.pop_front() {\n            if current == end {\n                let mut result = vec![];\n                let mut current = current.clone();\n                while let Some(prev) = path.get(&current) {\n                    result.push(current);\n                    current = prev.clone();\n                }\n                result.push(start.to_string());\n                result.reverse();\n                return Some(result);\n            }\n\n            if let Some(user) = self.users.get(&current) {\n                for friend in &user.friends {\n                    if !visited.contains(friend) {\n                        visited.insert(friend.clone());\n                        queue.push_back(friend.clone());\n                        path.insert(friend.clone(), current.clone());\n                    }\n                }\n            }\n        }\n\n        None\n    }\n}\n\nfn main() {\n    let mut social_network = SocialNetwork::new();\n\n    social_network.add_user(\"alice\", \"Alice\", 25);\n    social_network.add_user(\"bob\", \"Bob\", 30);\n    social_network.add_user(\"charlie\", \"Charlie\", 35);\n    social_network.add_user(\"david\", \"David\", 40);\n\n    social_network.add_friendship(\"alice\", \"bob\");\n    social_network.add_friendship(\"bob\", \"charlie\");\n    social_network.add_friendship(\"charlie\", \"david\");\n\n    println!(\"Friends of Alice: {:?}\", social_network.get_friends(\"alice\"));\n    println!(\"Shortest path from Alice to David: {:?}\", social_network.shortest_path(\"alice\", \"david\"));\n\n    social_network.remove_friendship(\"bob\", \"charlie\");\n    println!(\"Friends of Bob after removing friendship with Charlie: {:?}\", social_network.get_friends(\"bob\"));\n\n    social_network.remove_user(\"charlie\");\n    println!(\"Friends of Bob after removing Charlie from the network: {:?}\", social_network.get_friends(\"bob\"));\n}\n\n\n+++++ src/main.rs\nstruct User {\n    username: String,\n    name: String,\n    age: u8,\n    friends: Vec<String>,\n}\n\nimpl User {\n    fn new(username: &str, name: &str, age: u8) -> User {\n        User {\n            username: username.to_string(),\n            name: name.to_string(),\n            age,\n            friends: Vec::new(),\n        }\n    }\n\n    fn add_friend(&mut self, friend: &str) {\n        self.friends.push(friend.to_string());\n    }\n\n    fn remove_friend(&mut self, friend: &str) {\n        if let Some(pos) = self.friends.iter().position(|f| f == friend) {\n            self.friends.remove(pos);\n        }\n    }\n}\n\nstruct SocialNetwork {\n    users: Vec<User>,\n}\n\nimpl SocialNetwork {\n    fn new() -> SocialNetwork {\n        SocialNetwork { users: Vec::new() }\n    }\n\n    fn add_user(&mut self, username: &str, name: &str, age: u8) {\n        let user = User::new(username, name, age);\n        self.users.push(user);\n    }\n\n    fn remove_user(&mut self, username: &str) {\n        if let Some(pos) = self.users.iter().position(|u| u.username == username) {\n            self.users.remove(pos);\n        }\n    }\n\n    fn add_friendship(&mut self, username1: &str, username2: &str) {\n        if let (Some(user1), Some(user2)) = (\n            self.users.iter_mut().find(|u| u.username == username1),\n            self.users.iter_mut().find(|u| u.username == username2),\n        ) {\n            user1.add_friend(username2);\n            user2.add_friend(username1);\n        }\n    }\n\n    fn remove_friendship(&mut self, username1: &str, username2: &str) {\n        if let (Some(user1), Some(user2)) = (\n            self.users.iter_mut().find(|u| u.username == username1),\n            self.users.iter_mut().find(|u| u.username == username2),\n        ) {\n            user1.remove_friend(username2);\n            user2.remove_friend(username1);\n        }\n    }\n\n    fn get_friends(&self, username: &str) -> Option<&Vec<String>> {\n        self.users.iter().find(|u| u.username == username).map(|u| &u.friends)\n    }\n}\n\nfn main() {\n    let mut network = SocialNetwork::new();\n\n    network.add_user(\"alice\", \"Alice Smith\", 30);\n    network.add_user(\"bob\", \"Bob Johnson\", 35);\n    network.add_user(\"charlie\", \"Charlie Brown\", 25);\n\n    network.add_friendship(\"alice\", \"bob\");\n    network.add_friendship(\"alice\", \"charlie\");\n    network.add_friendship(\"bob\", \"charlie\");\n\n    println!(\"Alice's friends: {:?}\", network.get_friends(\"alice\"));\n    println!(\"Bob's friends: {:?}\", network.get_friends(\"bob\"));\n    println!(\"Charlie's friends: {:?}\", network.get_friends(\"charlie\"));\n\n    network.remove_friendship(\"alice\", \"bob\");\n\n    println!(\"Alice's friends after removing Bob: {:?}\", network.get_friends(\"alice\"));\n\n    network.remove_user(\"bob\");\n\n    println!(\"Alice's friends after removing Bob from the network: {:?}\", network.get_friends(\"alice\"));\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "8bae7a18-692e-4bbe-b8eb-9369b09cb70e", "code": "extern crate chrono;\nextern crate serde;\nextern crate serde_json;\nextern crate tokio;\nextern crate reqwest;\nextern crate url;\n\nuse std::collections::{HashMap, BinaryHeap};\nuse std::cmp::Ordering;\nuse std::sync::{Arc, Mutex};\nuse chrono::Utc;\nuse url::Url;\nuse tokio::sync::RwLock;\nuse reqwest::Client;\nuse serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\nstruct Article {\n    extract: String,\n    content: String,\n}\n\nstruct CacheEntry<T> {\n    value: T,\n    frequency: usize,\n    last_accessed: chrono::DateTime<Utc>,\n}\n\nstruct LFUCache<T> {\n    capacity: usize,\n    entries: HashMap<String, CacheEntry<T>>,\n    min_heap: BinaryHeap<(usize, String, chrono::DateTime<Utc>)>,\n}\n\nimpl<T> LFUCache<T> {\n    fn new(capacity: usize) -> Self {\n        LFUCache {\n            capacity,\n            entries: HashMap::new(),\n            min_heap: BinaryHeap::new(),\n        }\n    }\n\n    fn get(&mut self, key: &str) -> Option<&T> {\n        if let Some(entry) = self.entries.get_mut(key) {\n            entry.frequency += 1;\n            entry.last_accessed = Utc::now();\n            self.min_heap.push((entry.frequency, key.to_string(), entry.last_accessed));\n            Some(&entry.value)\n        } else {\n            None\n        }\n    }\n\n    fn put(&mut self, key: String, value: T) {\n        if self.entries.len() >= self.capacity {\n            if let Some((_, k, _)) = self.min_heap.pop() {\n                self.entries.remove(&k);\n            }\n        }\n\n        let entry = CacheEntry {\n            value,\n            frequency: 1,\n            last_accessed: Utc::now(),\n        };\n        self.entries.insert(key.clone(), entry);\n        self.min_heap.push((1, key, Utc::now()));\n    }\n}\n\nstruct Encyclopedia {\n    full_cache: LFUCache<Article>,\n    summary_cache: LFUCache<String>,\n    client: Client,\n}\n\nimpl Encyclopedia {\n    async fn get_article(&self, title: &str) -> Result<Article, reqwest::Error> {\n        let url = Url::parse_with_params(\n            \"https://en.wikipedia.org/w/api.php\",\n            &[\n                (\"action\", \"query\"),\n                (\"prop\", \"extracts\"),\n                (\"explaintext\", \"1\"),\n                (\"titles\", title),\n                (\"format\", \"json\"),\n            ],\n        )\n        .unwrap();\n\n        let response = self.client.get(url).send().await?;\n        let json: HashMap<String, HashMap<String, Article>> = response.json().await?;\n\n        if let Some(pages) = json.get(\"query\").and_then(|q| q.get(\"pages\")) {\n            if let Some(article) = pages.values().next() {\n                return Ok(article.clone());\n            }\n        }\n\n        Err(reqwest::Error::new(reqwest::Error::new(std::io::Error::new(std::io::ErrorKind::Other, \"Article not found\"))))\n    }\n\n    async fn get_summary(&self, title: &str) -> Result<String, reqwest::Error> {\n        let article = self.get_article(title).await?;\n        Ok(article.extract)\n    }\n\n    async fn get_full_article(&self, title: &str) -> Result<String, reqwest::Error> {\n        let article = self.get_article(title).await?;\n        Ok(article.content)\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), reqwest::Error> {\n    let encyclopedia = Arc::new(Encyclopedia {\n        full_cache: LFUCache::new(100),\n        summary_cache: LFUCache::new(200),\n        client: Client::new(),\n    });\n\n    // Example usage\n    let title = \"Rust programming language\";\n    let summary = encyclopedia.get_summary(title).await?;\n    let full_article = encyclopedia.get_full_article(title).await?;\n\n    println!(\"Summary: {}\", summary);\n    println!(\"Full article: {}\", full_article);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "eadad3f4-5e40-4e49-85e8-8a00dceec642", "code": "use std::collections::HashMap;\n\n#[derive(Debug)]\nstruct BookStats {\n    times_checked_out: u32,\n    currently_checked_out: bool,\n}\n\n#[derive(Debug)]\nstruct Book {\n    title: String,\n    stats: BookStats,\n}\n\nimpl Book {\n    fn new(title: &str) -> Book {\n        Book {\n            title: title.to_string(),\n            stats: BookStats {\n                times_checked_out: 0,\n                currently_checked_out: false,\n            },\n        }\n    }\n\n    fn checkout(&mut self) -> Result<(), &'static str> {\n        if self.stats.currently_checked_out {\n            Err(\"Book is already checked out\")\n        } else {\n            self.stats.times_checked_out += 1;\n            self.stats.currently_checked_out = true;\n            Ok(())\n        }\n    }\n\n    fn return_book(&mut self) -> Result<(), &'static str> {\n        if !self.stats.currently_checked_out {\n            Err(\"Book is not checked out\")\n        } else {\n            self.stats.currently_checked_out = false;\n            Ok(())\n        }\n    }\n\n    fn get_checkout_count(&self) -> u32 {\n        self.stats.times_checked_out\n    }\n\n    fn is_checked_out(&self) -> bool {\n        self.stats.currently_checked_out\n    }\n}\n\n#[derive(Debug)]\nstruct Library {\n    books: HashMap<String, Book>,\n}\n\nimpl Library {\n    fn new() -> Library {\n        Library {\n            books: HashMap::new(),\n        }\n    }\n\n    fn add_book(&mut self, book: Book) {\n        self.books.insert(book.title.clone(), book);\n    }\n\n    fn checkout_book(&mut self, title: &str) -> Result<(), &'static str> {\n        if let Some(book) = self.books.get_mut(title) {\n            book.checkout()\n        } else {\n            Err(\"Book not found in library\")\n        }\n    }\n\n    fn return_book(&mut self, title: &str) -> Result<(), &'static str> {\n        if let Some(book) = self.books.get_mut(title) {\n            book.return_book()\n        } else {\n            Err(\"Book not found in library\")\n        }\n    }\n}\n\nfn main() {\n    let mut library = Library::new();\n\n    let mut book1 = Book::new(\"Book 1\");\n    let mut book2 = Book::new(\"Book 2\");\n\n    library.add_book(book1);\n    library.add_book(book2);\n\n    library.checkout_book(\"Book 1\").unwrap();\n    library.checkout_book(\"Book 2\").unwrap();\n\n    library.return_book(\"Book 1\").unwrap();\n\n    book1 = library.books.remove(\"Book 1\").unwrap();\n    book2 = library.books.remove(\"Book 2\").unwrap();\n\n    println!(\"Book 1: Checkout count: {}, Checked out: {}\", book1.get_checkout_count(), book1.is_checked_out());\n    println!(\"Book 2: Checkout count: {}, Checked out: {}\", book2.get_checkout_count(), book2.is_checked_out());\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "bb93c1ce-fe63-46c8-9199-856da8afcdfc", "code": "use anyhow::Result;\nuse chrono::{DateTime, Duration, Utc};\nuse serde::Deserialize;\nuse serde_json;\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::BufReader;\n\n#[derive(Deserialize)]\nstruct EventLog {\n    logs: Vec<Event>,\n}\n\n#[derive(Deserialize)]\nstruct Event {\n    event_type: String,\n    timestamp: DateTime<Utc>,\n    severity: String,\n    metadata: HashMap<String, String>,\n}\n\nfn main() -> Result<()> {\n    let file = File::open(\"logs.json\")?;\n    let reader = BufReader::new(file);\n    let log_data: EventLog = serde_json::from_reader(reader)?;\n\n    let mut event_counts: HashMap<String, HashMap<String, u32>> = HashMap::new();\n    let mut last_timestamp: Option<DateTime<Utc>> = None;\n    let mut longest_gap: Duration = Duration::zero();\n    let mut invalid_timestamps: Vec<String> = Vec::new();\n\n    for event in log_data.logs {\n        if let Some(last) = last_timestamp {\n            let gap = event.timestamp - last;\n            if gap > longest_gap {\n                longest_gap = gap;\n            }\n        }\n\n        *event_counts.entry(event.event_type).or_default()\n            .entry(event.severity)\n            .or_insert(0) += 1;\n\n        last_timestamp = Some(event.timestamp);\n    }\n\n    println!(\"Event counts:\");\n    for (event_type, severity_counts) in &event_counts {\n        println!(\n            \"- {}: info={}, error={}\",\n            event_type,\n            severity_counts.get(\"info\").unwrap_or(&0),\n            severity_counts.get(\"error\").unwrap_or(&0)\n        );\n    }\n\n    println!(\"Longest time gap between events: {} seconds\", longest_gap.num_seconds());\n\n    if invalid_timestamps.is_empty() {\n        println!(\"Invalid timestamps: None\");\n    } else {\n        println!(\"Invalid timestamps:\");\n        for timestamp in &invalid_timestamps {\n            println!(\"- {}\", timestamp);\n        }\n    }\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "4c69bb31-2ecb-4874-9829-2f12501cd8a8", "code": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\nstruct Cache {\n    full: LruCache<String, String>,\n    summary: LruCache<String, String>,\n}\n\nimpl Cache {\n    async fn get_summary(&self, title: &str) -> Option<String> {\n        todo!()\n    }\n\n    async fn get_article(&self, title: &str) -> Option<String> {\n        todo!()\n    }\n\n    async fn fetch_article(&self, title: &str) -> Result<String, Error> {\n        todo!()\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    // ...\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "eeaffe71-c76a-4333-b9a8-88e0a0f9a2ce", "code": "use std::fs;\nuse std::io::{self, Write};\nuse serde::{Deserialize, Serialize};\nuse serde_json;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Episode {\n    name: String,\n    number: u32,\n    rating: f64,\n    reviews: Vec<String>,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Series {\n    name: String,\n    genres: Vec<String>,\n    actors: Vec<String>,\n    episodes: Vec<Episode>,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Database {\n    series: Vec<Series>,\n}\n\nimpl Database {\n    fn new() -> Self {\n        Database { series: Vec::new() }\n    }\n\n    fn add_series(&mut self, series: Series) {\n        self.series.push(series);\n    }\n\n    fn add_episode(&mut self, series_name: &str, episode: Episode) -> Result<(), &'static str> {\n        if let Some(series) = self.series.iter_mut().find(|s| s.name == series_name) {\n            series.episodes.push(episode);\n            Ok(())\n        } else {\n            Err(\"Series not found\")\n        }\n    }\n\n    fn add_review(&mut self, series_name: &str, episode_number: u32, review: String) -> Result<(), &'static str> {\n        if let Some(series) = self.series.iter_mut().find(|s| s.name == series_name) {\n            if let Some(episode) = series.episodes.iter_mut().find(|e| e.number == episode_number) {\n                episode.reviews.push(review);\n                Ok(())\n            } else {\n                Err(\"Episode not found\")\n            }\n        } else {\n            Err(\"Series not found\")\n        }\n    }\n\n    fn get_series_rating(&self, series_name: &str) -> Option<f64> {\n        if let Some(series) = self.series.iter().find(|s| s.name == series_name) {\n            let total_rating: f64 = series.episodes.iter().map(|e| e.rating).sum();\n            let count = series.episodes.len() as f64;\n            Some(total_rating / count)\n        } else {\n            None\n        }\n    }\n\n    fn get_episode_rating(&self, series_name: &str, episode_number: u32) -> Option<f64> {\n        if let Some(series) = self.series.iter().find(|s| s.name == series_name) {\n            if let Some(episode) = series.episodes.iter().find(|e| e.number == episode_number) {\n                Some(episode.rating)\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }\n\n    fn get_series_by_actor(&self, actor_name: &str) -> Vec<&Series> {\n        self.series.iter().filter(|s| s.actors.contains(&actor_name.to_string())).collect()\n    }\n\n    fn get_series_by_genre(&self, genre: &str) -> Vec<&Series> {\n        self.series.iter().filter(|s| s.genres.contains(&genre.to_string())).collect()\n    }\n}\n\nfn save_to_file(database: &Database) -> io::Result<()> {\n    let json = serde_json::to_string(database).unwrap();\n    fs::write(\"database.json\", json)\n}\n\nfn load_from_file() -> io::Result<Database> {\n    let json = fs::read_to_string(\"database.json\")?;\n    let database: Database = serde_json::from_str(&json).unwrap();\n    Ok(database)\n}\n\nfn main() {\n    let mut database = Database::new();\n\n    loop {\n        println!(\"1. Add series\");\n        println!(\"2. Add episode to series\");\n        println!(\"3. Get series rating\");\n        println!(\"4. Get episode rating\");\n        println!(\"5. Get series by actor\");\n        println!(\"6. Get series by genre\");\n        println!(\"7. Save to file\");\n        println!(\"8. Load from file\");\n        println!(\"9. Exit\");\n\n        let mut input = String::new();\n        std::io::stdin().read_line(&mut input).unwrap();\n        let choice: u32 = input.trim().parse().unwrap();\n\n        match choice {\n            1 => {\n                print!(\"Enter series name: \");\n                let _ = std::io::stdout().flush();\n                let mut name = String::new();\n                std::io::stdin().read_line(&mut name).unwrap();\n                let name = name.trim().to_string();\n\n                print!(\"Enter series genres (comma separated): \");\n                let _ = std::io::stdout().flush();\n                let mut genres = String::new();\n                std::io::stdin().read_line(&mut genres).unwrap();\n                let genres: Vec<String> = genres.trim().split(',').map(|s| s.trim().to_string()).collect();\n\n                print!(\"Enter series actors (comma separated): \");\n                let _ = std::io::stdout().flush();\n                let mut actors = String::new();\n                std::io::stdin().read_line(&mut actors).unwrap();\n                let actors: Vec<String> = actors.trim().split(',').map(|s| s.trim().to_string()).collect();\n\n                database.add_series(name, genres, actors);\n                println!(\"Series added.\");\n            }\n            2 => {\n                print!(\"Enter series name: \");\n                let _ = std::io::stdout().flush();\n                let mut name = String::new();\n                std::io::stdin().read_line(&mut name).unwrap();\n                let name = name.trim().to_string();\n\n                print!(\"Enter episode name: \");\n                let _ = std::io::stdout().flush();\n                let mut episode_name = String::new();\n                std::io::stdin().read_line(&mut episode_name).unwrap();\n                let episode_name = episode_name.trim().to_string();\n\n                print!(\"Enter episode rating: \");\n                let _ = std::io::stdout().flush();\n                let mut rating = String::new();\n                std::io::stdin().read_line(&mut rating).unwrap();\n                let rating: f32 = rating.trim().parse().unwrap();\n\n                if let Some(series) = database.get_series_mut(&name) {\n                    series.add_episode(episode_name, rating);\n                    println!(\"Episode added to series.\");\n                } else {\n                    println!(\"Series not found.\");\n                }\n            }\n            3 => {\n                print!(\"Enter series name: \");\n                let _ = std::io::stdout().flush();\n                let mut name = String::new();\n                std::io::stdin().read_line(&mut name).unwrap();\n                let name = name.trim().to_string();\n\n                if let Some(series) = database.get_series(&name) {\n                    println!(\"Series rating: {}\", series.get_rating());\n                } else {\n                    println!(\"Series not found.\");\n                }\n            }\n            4 => {\n                print!(\"Enter series name: \");\n                let _ = std::io::stdout().flush();\n                let mut series_name = String::new();\n                std::io::stdin().read_line(&mut series_name).unwrap();\n                let series_name = series_name.trim().to_string();\n\n                print!(\"Enter episode name: \");\n                let _ = std::io::stdout().flush();\n                let mut episode_name = String::new();\n                std::io::stdin().read_line(&mut episode_name).unwrap();\n                let episode_name = episode_name.trim().to_string();\n\n                if let Some(series) = database.get_series(&series_name) {\n                    if let Some(episode) = series.get_episode(&episode_name) {\n                        println!(\"Episode rating: {}\", episode.get_rating());\n                    } else {\n                        println!(\"Episode not found in series.\");\n                    }\n                } else {\n                    println!(\"Series not found.\");\n                }\n            }\n            5 => {\n                break;\n            }\n            _ => {\n                println!(\"Invalid option. Please try again.\");\n            }\n        }\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "d36db659-cb5f-4b8c-88df-97f5750d2176", "code": "use std::fs::File;\nuse std::io::{BufRead, BufReader};\nuse std::cmp::max;\n\nfn main() -> std::io::Result<()> {\n    let file = File::open(\"meetings.txt\")?;\n    let reader = BufReader::new(file);\n\n    let mut meetings: Vec<(i64, i64)> = Vec::new();\n\n    for line in reader.lines() {\n        let line = line?;\n        let mut parts = line.split_whitespace();\n        let start = parts.next().unwrap().parse::<i64>().unwrap();\n        let end = parts.next().unwrap().parse::<i64>().unwrap();\n        meetings.push((start, end));\n    }\n\n    meetings.sort_by(|a, b| a.0.cmp(&b.0));\n\n    let mut rooms = 0;\n    let mut end_times: Vec<i64> = Vec::new();\n\n    for (start, end) in meetings {\n        if let Some(&last_end) = end_times.last() {\n            if start < last_end {\n                rooms += 1;\n                end_times.push(end);\n            } else {\n                end_times[end_times.len() - 1] = end;\n            }\n        } else {\n            rooms += 1;\n            end_times.push(end);\n        }\n    }\n\n    println!(\"Minimum number of meeting rooms required: {}\", rooms);\n\n    Ok(())\n}", "error_message": "", "success": true, "retry_on_error": true}
{"model": "Codestral-22B-v0.1-Q8_0.gguf", "problem_id": "0bc9a485-d0bf-4a14-af6c-b2b88c2f4e6d", "code": "// User struct\n#[derive(Debug, Clone)]\nstruct User {\n    id: Uuid,\n    username: String,\n    name: String,\n    age: u8,\n    friends: Vec<Uuid>,\n    posts: Vec<Uuid>,\n}\n\n// Post struct\n#[derive(Debug, Clone)]\nstruct Post {\n    id: Uuid,\n    user_id: Uuid,\n    content: String,\n    timestamp: DateTime<Utc>,\n}\n\n// SocialNetwork struct\n#[derive(Default)]\nstruct SocialNetwork {\n    users: HashMap<Uuid, User>,\n    posts: HashMap<Uuid, Post>,\n}\n\n// Implement methods for SocialNetwork\nimpl SocialNetwork {\n    // Add a user to the network\n    fn add_user(&mut self, username: String, name: String, age: u8) -> Result<Uuid> {\n        // ...\n    }\n\n    // Remove a user from the network\n    fn remove_user(&mut self, user_id: Uuid) -> Result<()> {\n        // ...\n    }\n\n    // Add a friendship\n    fn add_friendship(&mut self, user_id1: Uuid, user_id2: Uuid) -> Result<()> {\n        // ...\n    }\n\n    // Get the friends of a user\n    fn get_friends(&self, user_id: Uuid) -> Result<Vec<Uuid>> {\n        // ...\n    }\n\n    // Remove a friendship\n    fn remove_friendship(&mut self, user_id1: Uuid, user_id2: Uuid) -> Result<()> {\n        // ...\n    }\n\n    // Find the shortest path between two users\n    fn find_shortest_path(&self, user_id1: Uuid, user_id2: Uuid) -> Result<Option<Vec<Uuid>>> {\n        // ...\n    }\n\n    // Make a post\n    fn make_post(&mut self, user_id: Uuid, content: String) -> Result<Uuid> {\n        // ...\n    }\n\n    // Get the posts of a user\n    fn get_posts(&self, user_id: Uuid) -> Result<Vec<Uuid>> {\n        // ...\n    }\n\n    // Get the posts of a user in a specific time range\n    fn get_posts_in_time_range(\n        &self,\n        user_id: Uuid,\n        start: DateTime<Utc>,\n        end: DateTime<Utc>,\n    ) -> Result<Vec<Uuid>> {\n        // ...\n    }\n\n    // Remove a post\n    fn remove_post(&mut self, post_id: Uuid) -> Result<()> {\n        // ...\n    }\n}", "error_message": "", "success": true, "retry_on_error": true}
