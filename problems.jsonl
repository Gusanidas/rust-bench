{"id": "7a8902bd-1e89-4267-a640-31a6d85a2657", "problem_statement": "Give me a rust programm that gets a string and returns the string reversed"}
{"id": "dfcef33d-f032-46a2-a10f-dc810a753508", "problem_statement": "Write a Rust program that takes an array of unordered numbers and returns the array sorted in ascending order.\nUse the quicksort algorithm to sort the array."}
{"id": "345ad3cc-ee5c-4af1-aa3d-20b4c0b87773", "problem_statement": "Write a Rust program to model a parking lot. There should be a `ParkingLot` struct that has a `capacity` field and a `vehicles` field that is a vector of `Vehicle` structs. The `Vehicle` struct should have a `license_plate` field and a `color` field.\nThe `ParkingLot` struct should have a method `park` that takes a `Vehicle` and adds it to the `vehicles` vector if the parking lot is not full. The `ParkingLot` struct should also have a method `unpark` that takes a `license_plate` and removes the vehicle with that `license_plate` from the `vehicles` vector.\nThe `ParkingLot` struct should have a method `is_full` that returns true if the parking lot is full and false otherwise.\nThe `ParkingLot` struct should have a method `get_vehicle` that takes a `license_plate` and returns the vehicle with that `license_plate` if it is in the `vehicles` vector.\nThe `ParkingLot` struct should have a method `get_vehicles_by_color` that takes a `color` and returns a vector of vehicles with that `color`.\nThe `Vehicle` struct should have a method `get_license_plate` that returns the `license_plate` of the vehicle. The `Vehicle` struct should have a method `get_color` that returns the `color` of the vehicle."}
{"id": "a9f5bb7f-db26-4e8f-ac72-40c5ef86a7e4", "problem_statement": "Create a Rust parking lot system with capacity and vehicles. Each vehicle has a license plate and color.\nRequired functionality:\n\nPark vehicles with timestamp if space available\nUnpark by license plate and timestamp, calculating fee\nCheck if lot is full\nLook up vehicle by license plate\nFind vehicles by color\nCalculate revenue between timestamps\n\nParking rates per minute:\nFirst hour: $3\nSecond hour: $2\nRemaining time: $1"}
{"id": "a2029754-b1ee-404e-a0ca-6d100c1ddd79", "problem_statement": "Help me create a Rust program to keep track of users and their cars.\nA user can have multiple cars, and a car can have multiple users.\nA user has:\n- A name\n- An ID (unique)\n- A birthdate\n- A list of cars\nA car has:\n- An ID (unique)\n- A brand\n- A model\n- Horsepower\nThe program should have the following features:\n- Add a user\n- Add a car\n- Assign a car to a user\n- Get all cars assigned to a user\n- Get all users assigned to a car\n- Get car with the most horsepower for a user\n- Get youngest user assigned to a car"}
{"id": "ee888d19-5869-46fb-a6c4-3259eb90431f", "problem_statement": "Help me create a Rust program to keep track of users and their cars.\nA user can have multiple cars, and a car can have multiple users.\nA user has:\n- A name\n- An ID (unique)\n- A birthdate\n- A list of cars\nA car has:\n- An ID (unique)\n- A brand\n- A model\nThe program should have the following features:\n- Add a user\n- Add a car\n- Assign a car to a user\n- Get all cars assigned to a user\n- Get all users assigned to a car\n- Get youngest user assigned to a car\n- Remove a user\n- Get all users that share a car with a given user.\n- Get all cars that share a user with a given car. (Given the Id)"}
{"id": "c91470e1-5c32-43ff-a8c9-1e490c17f19f", "problem_statement": "Create a Rust program to manage events and their participants.\nA participant can attend multiple events, and an event can have multiple participants.\n\nEntities:\n\nParticipant:\n\n-name\n-unique ID\n-phone number\n-list of event IDs\n\nEvent:\n\n-unique ID\n-name\n-date\n-list of participant IDs\n\nFeatures to implement:\n\nAdd a participant.\nAdd an event.\nAssign a participant to an event.\nGet all events for a participant.\nGet all participants for an event.\nFind the event with the most participants.\nRemove a participant (update all related events).\nGet participants attending the same events as a given participant.\nFind events that share participants with a given event.\nGet participants attending events on a specific date."}
{"id": "fa9b54ba-a10b-4e07-892f-c45a1ffe3a90", "problem_statement": "Create a Rust program to manage events and two types of entities: participants and organizers. Both types share some common properties but also have unique features.\n\nEntities:\n\nBase Entity (trait):\n\n-id (unique)\n-name\n\nParticipant (implements Entity trait):\n\n-phone number\n-list of event IDs\n\nOrganizer (implements Entity trait):\n\n-email address\n-managed event IDs\n\nEvent:\n\n-unique ID\n-name\n-date\n-list of participant IDs\n-organizer ID\n\nFeatures:\n\nAdd a participant.\nAdd an organizer.\nAdd an event.\nAssign a participant to an event.\nAssign an organizer to an event.\nGet all events for a participant.\nGet all participants for an event.\nGet the organizer of an event.\nFind the event with the most participants.\nRemove a participant (update all related events).\nGet participants attending the same events as a given participant.\nGet all events managed by a specific organizer."}
{"id": "0aa47a6c-eac7-4a1a-aad2-dcd3e7805ea8", "problem_statement": "Create a Rust program to manage events and two types of entities: participants and organizers. Both types share some common properties but also have unique features.\n\nEntities:\nBase Entity (trait):\n-id (unique)\n-name\n-reputation score (increases with successful event participation/management)\n\nParticipant (implements Entity trait):\n-phone number\n-list of event IDs\n-skills/interests (vector of strings)\n-waitlist status for events\n\nOrganizer (implements Entity trait):\n-email address\n-managed event IDs\n-specialization categories\n-performance rating\n\nEvent:\n-unique ID\n-name\n-date\n-category (Conference, Workshop, Social, etc.)\n-maximum capacity\n-current participant count\n-waitlist (ordered vector of participant IDs)\n-list of participant IDs\n-organizer ID\n-minimum required reputation score\n-required skills/interests\n\nFeatures:\nAdd a participant.\nAdd an organizer.\nAdd an event.\nAssign a participant to an event (respect capacity limits and waitlist).\nAssign an organizer to an event (must have matching category specialization).\nGet all events for a participant (including waitlisted).\nGet all participants for an event (including waitlist status).\nGet the organizer of an event.\nFind the event with the most participants.\nRemove a participant (update all related events and waitlists).\nGet participants attending the same events as a given participant.\nGet all events managed by a specific organizer.\nCalculate participant-event compatibility score based on skills/interests.\nPromote waitlisted participants when spots become available.\nGenerate event recommendations for participants based on their interests.\nTrack and update reputation scores after events."}
{"id": "b717526c-a82c-4b6b-be53-cc87215e7491", "problem_statement": "Your goal is to implement a scheduler using closures. The scheduler should:\n\nExecute a single task: Run a closure that takes no arguments and returns a value.\nChain dependent tasks: Execute a sequence of closures where each task depends on the result of the previous one.\nConditional execution: Execute a closure only if a certain condition is met (defined as another closure returning a boolean).\n\nImplement the scheduler in the Scheduler struct.\nThe struct should have methods:\nrun_task<F>(&self, task: F) -> T where F is a closure with signature FnOnce() -> T.\nrun_chain<F, T>(&self, tasks: Vec<F>) -> Vec<T> where F is a closure with signature Fn(T) -> T, and the tasks are run in sequence, passing the result of one task as input to the next.\nrun_conditional<F, G>(&self, task: F, condition: G) -> Option<T> where F is a closure with signature FnOnce() -> T and G is a closure with signature Fn() -> bool."}
{"id": "a194d257-5056-4776-a006-037f3769b9fd", "problem_statement": "Your goal is to create a function that returns a closure that prints the fibonacci numbers.\n\nThe function signature should be similar to the following:\nfn make_fibonacci() -> impl FnMut() -> u64 {\n\nAnd the main function similar to the following:\nfn main() {\n    let mut fib = make_fibonacci();\n    for _ in 0..10 {\n        println!(\"{}\", fib());  // Prints: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n    }\n}"}
{"id": "060ced54-6fdb-4cc4-a291-1a988fc35c72", "problem_statement": "Implement a segment tree in rust."}
{"id": "5477800d-cdf1-4310-afcb-a1dd6d7e6a21", "problem_statement": "You are going to be given a list of soldiers.\nEach soldier has:\n- a unique ID\n- a rank\n- a name\n\nSoldiers may have the same name, but they will always have a unique ID.\nIf the list is N soldiers long, the IDs are always 1 to N, with no gaps.\n\nYou are going to be given a list of names and ranks, and you have to give the sortest list of conitguous IDS that contains all the names and ranks."}
{"id": "7c98c28a-2acd-4c7c-a74e-043538947c8e", "problem_statement": "You are given a list of medieval soldiers in a castle's guard roster.\nEach soldier has:\n\na unique ID number\na rank (Squire, Knight, Captain, or Commander)\na given name\na family name\ntheir primary weapon (Sword, Spear, Bow, or Mace)\nyears of service (1-30)\n\nThe IDs are sequential from 1 to N (where N is the total number of soldiers), with no gaps.\nMultiple soldiers may share the same given name, family name, rank, weapon, or years of service, but each ID is unique.\nYou must write a function that takes:\n\nThe complete roster of soldiers\nA list of search criteria, where each criterion is a tuple of:\n(rank, weapon, minimum_years_service)\n\nYour function must return the shortest contiguous sequence of IDs that contains at least one soldier matching EACH criterion in the search list. If multiple such sequences exist, return the one with the lowest starting ID.\nIf no such sequence exists, return None.\nExample criterion: (Knight, Sword, 5) matches any Knight with a Sword who has served 5 or more years."}
{"id": "bb93c1ce-fe63-46c8-9199-856da8afcdfc", "problem_statement": "Create a Rust program that processes server event logs stored in JSON format. Each log entry contains an event type, timestamp, severity level, and associated metadata. The program should:\n\nRead and parse the JSON log file\nCount events by type and severity\nFind the longest time gap between consecutive events\nIdentify any events with invalid timestamps\n\nExample JSON format:\n\n{\n  \"logs\": [\n    {\n      \"event_type\": \"server_start\",\n      \"timestamp\": \"2024-04-15T08:00:00Z\",\n      \"severity\": \"info\",\n      \"metadata\": {\n        \"server_id\": \"srv-001\",\n        \"version\": \"1.2.7\"\n      }\n    },\n    {\n      \"event_type\": \"connection_error\",\n      \"timestamp\": \"2024-04-15T08:05:30Z\", \n      \"severity\": \"error\",\n      \"metadata\": {\n        \"client_ip\": \"192.168.1.100\",\n        \"error_code\": \"E1001\"\n      }\n    }\n  ]\n}"}
{"id": "28dfe3f7-88b6-470d-b47b-8eff42798c81", "problem_statement": "Given a matrix of integers, of size n x m, where n is the number of rows and m is the number of columns, return the sum of the elements in the matrix."}
{"id": "b24f0b01-b4e4-4ddd-8e5a-11e69996a676", "problem_statement": "Given a matrix of integers, of size n x m, where n is the number of rows and m is the number of columns, find the largest rectangle containing only numbers that are divisible by some argument x and larger than another argument y.\nReturn the area of the rectangle."}
{"id": "722c1da2-8f2e-4806-839c-78aacb3f5f5d", "problem_statement": "Implement a queue in Rust. The queue should have the following methods:\n- push: Add an element to the back of the queue.\n- pop: Remove and return the element at the front of the queue.\n- peek: Return the element at the front of the queue without removing it.\n- is_empty: Return true if the queue is empty, false otherwise."}
{"id": "81432bcc-0ac3-4806-97ec-147fee390413", "problem_statement": "\nWrite the rust code for a social network website.\n\nWe will need to be able to:\n\n- Add a user to the network.\n  A user has:\n  - A unique username.\n  - A list of friends. (Initially empty)\n  - Name\n  - Age\n- Remove a user from the network.\n- Add a friendship. A friendship is a mutual relationship between two users. If user A is friends with user B, then user B is friends with user A.\n- Get the friends of a user.\n- Remove a friendship.\n- Given two users, find the shortest path between them. The path should be a list of users starting with the first user and ending with the second user. If there is no path, return None.\n"}
{"id": "0bc9a485-d0bf-4a14-af6c-b2b88c2f4e6d", "problem_statement": "\nWrite the rust code for a social network website.\n\nWe will need to be able to:\n\n- Add a user to the network.\n  A user has:\n  - A unique username.\n  - A list of friends. (Initially empty)\n  - A list of posts. (Initially empty)\n  - Name\n  - Age\n- Remove a user from the network.\n- Add a friendship. A friendship is a mutual relationship between two users. If user A is friends with user B, then user B is friends with user A.\n- Get the friends of a user.\n- Remove a friendship.\n- Given two users, find the shortest path between them. The path should be a list of users starting with the first user and ending with the second user. If there is no path, return None.\n- Make a post. A post has:\n  - A unique id.\n  - The user who made the post.\n  - The content of the post.\n  - The time the post was made.\n- Get the posts of a user.\n- Get the posts of a user's friends.\n- Get the posts of a user's friends of friends.\n- Get the posts of a user's friends for a given time period.\n"}
{"id": "b0085ed6-c498-4c65-ada8-066fd6eb7b14", "problem_statement": "Implement a sorted set in rust"}
{"id": "d2accd59-e363-4495-bfd4-9aa981d4deb4", "problem_statement": "\nWrite the rust code for a tv show rating website. Similar to Imdb but simpler.\n\nWe will have TV series. Each series will have a name, a list of genres, a list of actors, and a list of episodes.\n\nAn episode will have a name, a number, a rating, and a list of reviews.\nThe rating of a show is the average rating of all its episodes.\n\nWe want to be able to:\n- Add a new series\n- Add a new episode to a series\n- Add a review to an episode\n- Get the average rating of a series\n- Get the average rating of an episode\n- Get a descdeing list of all series by rating\n- Get a descdeing list of all episodes by rating, for a given series.\n"}
{"id": "eeaffe71-c76a-4333-b9a8-88e0a0f9a2ce", "problem_statement": "\nWrite the rust code for a tv show rating website. Similar to Imdb but simpler.\n\nWe will have TV series. Each series will have a name, a list of genres, a list of actors, and a list of episodes.\n\nAn episode will have a name, a number, a rating, and a list of reviews.\nThe rating of a show is the average rating of all its episodes.\n\nWe want to be able to:\n- Add a new series\n- Add a new episode to a series\n- Add a review to an episode\n- Get the average rating of a series\n- Get the average rating of an episode\n- Get a descdeing list of all series by rating\n- Get a descdeing list of all episodes by rating, for a given series.\n- Given an actor, get a list of all series they are in.\n"}
{"id": "f7261f57-e164-4705-af16-b22d35d5e160", "problem_statement": "\nWe want to model a library system using rust.\nWe will have the following entities:\n\n- Library\n  - id (unique)\n  - name\n  - collection of books\n\n- Book\n  - id (unique)\n  - title\n  - author\n  - original_library\n\n- Member\n  - id (unique)\n  - name\n  - borrowed_books (collection)\n\nWe want to implement the following functions:\n\n- Add a book to the library\n- Remove a book from the library\n- Borrow a book\n- Return a book\n- Add a member\n- Remove a member\n- List all books in the library (those that are not borrowed)\n- List all books borrowed by a member\n"}
{"id": "fec9e424-5b9f-4e1c-a85c-8eacccd0f76c", "problem_statement": "Flight Booking State Management System\n\nDesign a system to manage flight booking states using Rust enums. Each booking can be in one of these states:\n- Pending: Initial booking, awaiting confirmation\n- Confirmed: Payment processed, booking active\n- Cancelled: Booking cancelled by user or system\n- Completed: Flight taken, booking fulfilled\n- Failed: Booking failed (payment/system error)\n\nValid state transitions:\n- Pending \u2192 Confirmed, Failed, or Cancelled\n- Confirmed \u2192 Cancelled or Completed\n- Failed \u2192 Cancelled or Pending (retry)\n- Cancelled \u2192 No further transitions allowed\n- Completed \u2192 No further transitions allowed\n\nRequired Functions:\n1. change_state(current: BookingState, new: BookingState) -> Result<BookingState, Error>\n   - Changes booking state if transition is valid\n   - Returns error if transition is invalid\n\n2. current_state(state: &BookingState) -> String\n   - Returns string representation of current state\n\n3. is_transition_valid(from: &BookingState, to: &BookingState) -> bool\n   - Checks if state transition is allowed\n\nRequirements:\n- Use Rust enum for state representation\n- Handle invalid transitions with descriptive error messages\n- Ensure thread-safety for concurrent operations"}
{"id": "96f397c1-7ac3-4769-a21f-bf59908ea96b", "problem_statement": "Flight Booking State Management System\n\nDesign a thread-safe state management system using Rust enums that handles complex booking transitions with rollback capability.\n\nStates (each with associated failure reasons and timestamps):\n- Pending(PendingData)\n- PaymentVerifying(PaymentData)\n- Confirmed(BookingDetails)\n- Disputed(DisputeReason)\n- Refunded(RefundAmount)\n- Cancelled(CancellationReason)\n\nKey Features:\n1. Concurrent State Handling:\n   - Multiple systems can attempt state transitions simultaneously\n   - Implement optimistic locking for state changes\n   - Handle race conditions gracefully\n\n2. Transactional State Changes:\n   - All state transitions must be atomic\n   - Support rollback to previous state if any part fails\n   - Maintain a minimal but complete state history\n\n3. Time-Bound Transitions:\n   - States can have maximum duration (e.g., PaymentVerifying times out after 15 minutes)\n   - Automatic transitions on timeout\n   - Handle stuck states\n\nRequired Functions:\n1. async change_state(current: BookingState, new: BookingState) -> Result<BookingState, StateError>\n   - Performs atomic state transition\n   - Handles timeouts and rollbacks\n   - Returns custom error types for different failure scenarios\n\n2. validate_transition(from: &BookingState, to: &BookingState) -> bool\n   - Validates business rules and timing constraints\n   - Checks state-specific data requirements\n\n3. rollback_transaction(state: &BookingState) -> Result<BookingState, StateError>\n   - Reverts partial state changes\n   - Maintains data consistency\n   - Handles failed rollbacks\n\nRequirements:\n- Use Rust enum with associated data for state representation\n- Implement proper error handling with custom error types\n- Ensure thread-safety without deadlocks\n- Handle partial failures during state transitions\n- Support timeout-based automatic transitions"}
{"id": "4b9b2197-5938-4af0-aaaf-e95cda7be2ec", "problem_statement": "Concurrent Task Manager\n\nCreate a thread-safe task management system in Rust that handles multiple tasks with concurrent state updates.\n\nStates:\n\nTodo\nInProgress\nCompleted\nBlocked\nKey Features:\n\nConcurrent State Updates:\n\nAllow multiple threads to update task states simultaneously.\nEnsure data integrity using synchronization primitives.\nAtomic Transitions:\n\nState changes must be atomic to prevent race conditions.\nImplement rollback if a state transition fails.\nState Validation:\n\nEnforce valid state transitions (e.g., Todo \u2192 InProgress \u2192 Completed).\nReject invalid transitions with appropriate errors.\nRequired Functions:\n\nasync update_state(task_id: usize, new_state: TaskState) -> Result<TaskState, TaskError>\n\nAtomically updates the task state.\nHandles concurrent modifications and potential rollbacks.\nget_state(task_id: usize) -> TaskState\n\nRetrieves the current state of a task.\nRequirements:\n\nUse Rust enums with associated data to represent task states.\nEnsure thread safety using mutexes or other synchronization mechanisms.\nImplement comprehensive error handling for invalid transitions and concurrency issues.\nWrite unit tests to demonstrate correct concurrent behavior."}
{"id": "fdd28d76-b741-4e91-8ed1-1dad92980ce3", "problem_statement": "Create a Rust declarative macro named \"is_there_hot_dog\" that takes a list of elements and returns a boolean value indicating whether the list contains one or more elements that are equal to \"hot dog\". The macro should be case-insensitive."}
{"id": "7b9c5232-ee24-4304-9fa8-1fb69b680df0", "problem_statement": "\nRust Declarative Macro Challenge: Config Builder\n\nWrite a declarative macro config! that generates a strongly-typed configuration system. Given a set of fields with types and optional default values, the macro should generate:\n\nA Config struct with the specified fields.\nA ConfigBuilder struct with methods for setting fields and building a Config instance.\nError handling for missing required fields during the build process.\nExample Input:\n\nrust\nCopy code\nconfig! {\n    host: String = \"localhost\",\n    port: u16 = 8080,\n    use_ssl: bool = false,\n    timeout: Option<u32>,\n}\nGenerated Code:\n\nConfig struct with fields host, port, use_ssl, and timeout.\nConfigBuilder struct with methods like .host(), .port(), etc.\nA .build() method that applies defaults and validates required fields.\nConstraints:\n\nUse declarative macros only (macro_rules!).\nHandle any number of fields with various types.\nProvide ergonomic, chainable APIs for setting fields.\nThis task tests macro expertise, type safety, and Rust idioms.\n"}
{"id": "1bd19442-39a0-42ca-a3a6-4e1591268ca6", "problem_statement": "\nSolve using rust:\n\nThere are n rest stops along a circular running track, where each stop has energy[i] chocolate snacks. You are a runner planning to complete one full lap of the track. At each rest stop, you can pick up the available chocolate snacks for energy.\nRunning between stops requires energy \u2013 specifically, it takes burnRate[i] units of energy to run from rest stop i to the next stop (i + 1). You start your run with no chocolate snacks eaten (0 energy).\nGiven two arrays:\n\nenergy: number of chocolate snacks at each rest stop\nburnRate: energy required to run to the next stop\n\nReturn the index of the rest stop where you should start your run if you can complete one full lap, or return -1 if it's impossible from any starting point. If a solution exists, it will be the only valid starting point.\n"}
{"id": "7b9c9702-9f93-4f1d-b592-d72df807eebd", "problem_statement": "\n# Advanced Cat State Machine\n\nA house cat can be in six states: Resting, Playing, Hunting, Grooming, Eating, and Sleeping.\nEach state has an associated energy level that must be tracked:\n- Resting: Gains 2 energy per transition\n- Playing: Consumes 1 energy per transition\n- Hunting: Consumes 2 energy per transition\n- Grooming: Maintains current energy\n- Eating: Gains 3 energy per transition\n- Sleeping: Gains 4 energy per transition\n\nThe cat experiences these events:\n1. bell_sound: A bell rings\n2. bird_spotted: A bird appears\n3. sunshine: Sun comes through window\n4. food_served: Food is placed in bowl\n5. darkness: Lights go out\n\nState transition rules:\n1. From Resting:\n   - bell_sound \u2192 Playing (if energy \u2265 2)\n   - bird_spotted \u2192 Hunting (if energy \u2265 4)\n   - food_served \u2192 Eating\n   - darkness \u2192 Sleeping\n\n2. From Playing:\n   - bird_spotted \u2192 Hunting (if energy \u2265 4)\n   - energy < 2 \u2192 Resting (forced transition)\n   - sunshine \u2192 Grooming\n\n3. From Hunting:\n   - energy < 4 \u2192 Eating (forced transition)\n   - successful catch (25% chance) \u2192 Eating\n   - failed catch (75% chance) \u2192 Resting\n\n4. From Grooming:\n   - bell_sound \u2192 Playing (if energy \u2265 2)\n   - food_served \u2192 Eating\n   - darkness \u2192 Sleeping\n\n5. From Eating:\n   - After 2 transitions \u2192 Grooming\n   - darkness \u2192 Sleeping\n\n6. From Sleeping:\n   - After 4 transitions \u2192 Resting\n   - Only sunshine can interrupt sleep \u2192 Grooming\n\nAdditional requirements:\n1. Energy levels must stay between 0 and 10\n2. Use Rust's type system to enforce valid state transitions\n3. Implement error handling for invalid transitions\n4. Track time spent in each state\n5. Implement a probability system for hunting success\n6. Create a custom Debug implementation that shows the cat's current state and energy level\n7. Use interior mutability pattern for energy level management\n8. Implement the display trait to show a text representation of the cat's current state\n\nModel this via the Rust type system. Make the state transitions as concise as possible while maintaining type safety. Bonus points for implementing property-based testing to verify state machine properties.\n"}
{"id": "7f366e56-125a-4cf3-822c-5cfe4295897f", "problem_statement": "\nUsing rust model a Tic-Tac-Toe game.\n\nThe game should be played by two players, one using 'X' and the other using 'O'.\nThe game should be played on a 3x3 grid.\nThe game should be able to detect when a player has won, and declare the winner.\nThe game should be able to detect when the game is a draw.\n\n"}
{"id": "e23a0b87-e023-408d-a014-623a0d9fcb6c", "problem_statement": "\nUsing rust model a Tic-Tac-Toe game.\n\nThe game should be played by two players, one using 'X' and the other using 'O'.\nThe game should be played on a 3x3 grid.\nThe game should be able to detect when a player has won, and declare the winner.\nThe game should be able to detect when the game is a draw.\n\nAnd code a min max algorithm to play against the computer.\n"}
{"id": "bbccddec-2603-4812-b140-583931cfccbb", "problem_statement": "\nImplement a LRU (Least Recently Used) cache in Rust.\n"}
{"id": "145444e9-e131-4508-bfb8-2ce9a6247476", "problem_statement": "\n# Concurrent URL Fetcher with Retry Logic\n\nCreate a function that fetches multiple URLs concurrently with the following requirements:\n\n## Requirements\n1. The function should take:\n   - A vector of URLs\n   - Maximum number of concurrent requests\n2. Implement concurrent fetching with a limit on parallel requests\n3. For failed requests:\n   - Wait 3 seconds\n   - Retry the request\n   - Continue retrying until successful\n4. Return a Vec of results with the final status of each URL\n\n## Function Signature\n```rust\nasync fn fetch_urls(urls: Vec, max_concurrent: usize) -> Vec<Result>;\n```\n"}
{"id": "ffe50abe-298b-4356-a2c0-5c2ee827bd5f", "problem_statement": "\nUsing rust. Create a HTML parser that simplifies HTML into its basic structure. The goal is to build a tree that only cares about tag names and their parent-child relationships, ignoring attributes and content.\n\nExample:\n```html\n<div>\n    <p>Hello</p>\n    <span><i>World</i></span>\n</div>\n```\n\nShould be represented as:\n```\ndiv\n\u251c\u2500\u2500 p\n\u2514\u2500\u2500 span\n    \u2514\u2500\u2500 i\n```\n\nThen there should be a function:\n- get depth: that will take the tree and return the depth of the tree.\n- get tag_count: that will take the tree and return the number of tags in the tree.\n"}
{"id": "34fa31b7-de3c-4fd3-b6d7-06dab4853ad7", "problem_statement": "\nWrite a Rust program that processes a military hierarchy from a JSON file. Each soldier in the hierarchy is represented by a JSON object with the following structure:\njsonCopy{\n    \"id\": string,\n    \"superior_id\": string | null,\n    \"name\": string,\n    \"age\": number,\n    \"city\": string\n}\nThe input JSON file will contain an array of such soldier objects. Each soldier has a unique ID and may reference their superior's ID (if they have one). The root level soldiers (those with no superior) will have null as their superior_id.\n\nExample:\n[\n    {\n        \"id\": \"001\",\n        \"superior_id\": null,\n        \"name\": \"John Smith\",\n        \"age\": 45,\n        \"city\": \"New York\"\n    },\n    {\n        \"id\": \"002\",\n        \"superior_id\": \"001\",\n        \"name\": \"Jane Doe\",\n        \"age\": 35,\n        \"city\": \"Boston\"\n    }\n]\n---\n\nRequirements\n\nCreate a tree data structure to represent the military hierarchy\nImplement the following functions:\n\nlowest_common_ancestor(id1: &str, id2: &str) -> Option<String>\n\nFind the lowest common superior in the hierarchy between two given soldiers\nReturn None if no common ancestor exists\n\n\nget_chain_of_command(id: &str) -> Vec<String>\n\nReturn a vector of IDs representing the chain of command from the given soldier up to the top of the hierarchy\nShould include both the soldier's ID and their topmost superior's ID\nReturn an empty vector if the ID is not found.\n"}
{"id": "2f79226f-d4f8-486e-b417-37ddc29d6da0", "problem_statement": "\nWrite a Rust program to model a music playlist. The program should be able to:\n- Add a song to the playlist. By default the song should be added to the end of the playlist.\n  But the user should be able to specify the position where the song should be added.\n- Remove a song from the playlist. Songs should be removed by their position in the playlist.\n- Move a song to a different position in the playlist.\n- List all songs in the playlist.\n- Go to the next song in the playlist.\n- Go to the previous song in the playlist.\n\nEach song should have:\n- A title\n- An artist\n- A url to the song\n"}
{"id": "86a52ca7-9ada-4534-ad01-ab290bbe2cae", "problem_statement": "\nWrite a Rust program to model a concurrent music playlist system with user permissions. The program should be able to:\n\n- Add a song to the playlist (requires permission level THREE). By default the song should be added to the end of the playlist. But the user should be able to specify the position where the song should be added.\n- Remove a song from the playlist (requires permission level THREE). Songs should be removed by their position in the playlist.\n- Move a song to a different position in the playlist (requires permission level TWO).\n- List all songs in the playlist (available to all users).\n- Go to the next song in the playlist (requires permission level ONE).\n- Go to the previous song in the playlist (requires permission level ONE).\n\nEach song should have:\n- A title\n- An artist\n- A url to the song\n\nEach user should have a permission level:\n- ONE: Can only navigate songs (next/previous) and view the playlist\n- TWO: Everything in ONE + can move songs within the playlist\n- THREE: Everything in TWO + can add and remove songs\n\nAll operations should be concurrent-safe, handling multiple users accessing and modifying the playlist simultaneously. The program should implement appropriate synchronization mechanisms to prevent race conditions and ensure data consistency.\nIf a user is adding, moving or removing a song, other users should not be able to do any operation. However multiple users can view the playlist at the same time.\n\nEach method should take a 'user' parameter to verify permissions before executing the requested operation. If a user attempts an operation without sufficient permissions, the program should return an appropriate error.\n"}
{"id": "79fd1b11-fa61-4f71-bfe6-130a15e3549b", "problem_statement": "\nConcurrent URL Fetcher with Retry Logic and File Output\nCreate a function that fetches multiple URLs concurrently and writes their contents to files, with the following requirements:\nRequirements\n\nThe function should take:\n\nA vector of URLs\nMaximum number of concurrent requests\nOutput directory path for storing downloaded contents\n\n\nImplement concurrent fetching with a limit on parallel requests\nFor failed requests:\n\nWait 3 seconds\nRetry the request\nRetry a maximum of 3 times\n\nFor each successful request:\n\nAsynchronously write the contents to a file in the specified output directory\nUse the URL's final path segment or a hash of the URL as the filename\nHandle file writing errors appropriately\n\n\nReturn a Vec of results with:\n\nFinal status of each URL fetch\nPath to the written file (if successful)\nAny errors encountered during fetching or file writing\n\nOther requirements:\n\n- Implement per domain rate limiting.\n- Implement connection pooling.\n- Track this metrics:\n  - Time to first byte\n  - Time to download\n"}
{"id": "d36db659-cb5f-4b8c-88df-97f5750d2176", "problem_statement": "\nFor a list of future meetings we need to calculate the minimum number of meeting rooms required to hold all the meetings.\n\nThe input is a text file where each line correspond to a meeting. Each line contains the start time and end time of the meeting separated by a space.\nThe start and end times are in seconds since 1970-01-01 00:00:00 UTC. The start time is always before the end time. The meetings are not ordered.\n\nExample:\n```\n1614555600 1614559200\n1614555600 1614562800\n1614559200 1614562800\n```\n\nThe output should be a single integer, the minimum number of meeting rooms required.\n"}
{"id": "8a6d8693-cea9-4535-a815-4986cdd49597", "problem_statement": "\nWe need to calculate the minimum number of meeting rooms required to accommodate a list of scheduled meetings, taking into account the capacity of each meeting room.\n\nInput Details:\nMeetings: The input is a text file where each line represents a meeting. Each line contains the following information separated by spaces:\n\n- Start time: Start time of the meeting (in seconds since 1970-01-01 00:00:00 UTC).\n- End time: End time of the meeting (in seconds since 1970-01-01 00:00:00 UTC). The start time is always before the end time.\n- Meeting name: A unique identifier or name for the meeting (a string without spaces).\n- Number of people: The number of people attending the meeting (an integer).\n- The meetings are not ordered by time.\n\nMeeting Rooms: After the list of meetings, the input contains a description of available meeting rooms. Each line for a meeting room contains:\n\n- Room name: A unique identifier or name for the room (a string without spaces).\n- Capacity: The maximum number of people the room can hold (an integer).\n- The meeting rooms are also not ordered.\n\nExample Input:\n```\n1614555600 1614559200 MeetingA 10\n1614555600 1614562800 MeetingB 20\n1614559200 1614562800 MeetingC 15\nRoom1 15\nRoom2 20\nRoom3 10\n```\n\nOutput Details:\nThe output should be a single integer, representing the minimum number of meeting rooms required to hold all the meetings, ensuring that:\n\nNo two meetings in the same room overlap in time.\nEach room can accommodate the number of people attending the meeting.\nIf a meeting cannot be accommodated in any room, it should be ignored.\n"}
{"id": "fb9be66e-eaf4-47c5-b29a-cab2556b89f4", "problem_statement": "\nCalculate the minimum number of meeting rooms required to accommodate scheduled meetings, considering room capacity and maintenance periods.\nThe input is a text file. The first section lists meetings, and the second section lists meeting rooms.\n\nInput Details:\nMeetings: Each line in the input file represents a meeting with the following space-separated information:\n- Start time: Meeting start (format: YYYY-MM-DD HH:MM)\n- End time: Meeting end (format: YYYY-MM-DD HH:MM)\n- Meeting name: Unique identifier (string without spaces)\n- Number of people: Attendee count (integer)\n- Meetings may be in any order\n\nMeeting Rooms: Following the meetings, each line describes a room with:\n- Room name: Unique identifier (string without spaces)\n- Capacity: Maximum occupancy (integer)\n- Maintenance period: Daily maintenance window (HH:MM-HH:MM)\n- Rooms may be in any order\n\nExample Input:\n2023-03-15 09:00 2023-03-15 10:30 MeetingA 10\n2023-03-15 09:00 2023-03-15 11:30 MeetingB 20\n2023-03-15 10:30 2023-03-15 11:30 MeetingC 15\nRoom1 15 13:00-14:00\nRoom2 20 12:00-13:30\nRoom3 10 14:00-15:00\n\nOutput Details:\nReturn a single integer representing the minimum required meeting rooms, ensuring:\n1. No meetings in the same room overlap in time\n2. Room capacity meets or exceeds meeting attendance\n3. No meetings can be scheduled during a room's maintenance period\n4. Meetings that cannot be accommodated should be ignored\n\nNotes:\n- All times are in the same timezone\n- Meeting start time is always before end time\n- Maintenance periods occur daily\n- A room cannot be used during its maintenance period, even partially\n"}
{"id": "ec01f8a2-0175-4189-889f-13ae588cb899", "problem_statement": "\nSchedule meetings in available rooms to maximize economic value, considering room costs, meeting values, capacity constraints, and maintenance periods.\n\nInput Details:\nMeetings: Each line represents a meeting with space-separated information:\n- Start time: Meeting start (format: YYYY-MM-DD HH:MM)\n- End time: Meeting end (format: YYYY-MM-DD HH:MM)\n- Meeting name: Unique identifier (string without spaces)\n- Number of people: Attendee count (integer)\n- Value: Economic value of the meeting (integer)\n- Meetings may be in any order\n\nMeeting Rooms: Following the meetings, each line describes a room with:\n- Room name: Unique identifier (string without spaces)\n- Capacity: Maximum occupancy (integer)\n- Cost: Cost per minute of room usage (integer)\n- Maintenance period: Daily maintenance window (HH:MM-HH:MM)\n- Rooms may be in any order\n\nExample Input:\n2023-03-15 09:00 2023-03-15 10:30 MeetingA 10 1000\n2023-03-15 09:00 2023-03-15 11:30 MeetingB 20 2500\n2023-03-15 10:30 2023-03-15 11:30 MeetingC 15 800\nRoom1 15 2 13:00-14:00\nRoom2 20 3 12:00-13:30\nRoom3 10 1 14:00-15:00\n\nOutput Details:\nReturn the maximum possible net value achievable, where:\nNet Value = Sum(Meeting Values) - Sum(Room Costs)\n\nConstraints:\n1. No meetings in the same room can overlap in time\n2. Room capacity must meet or exceed meeting attendance\n3. No meetings can be scheduled during a room's maintenance period\n4. A meeting can only be scheduled in one room\n5. Room cost is calculated for the entire duration of each meeting\n\nNotes:\n- All times are in the same timezone\n- Meeting start time is always before end time\n- Maintenance periods occur daily\n- A room cannot be used during its maintenance period, even partially\n- Meeting values and room costs are in the same currency units\n"}
{"id": "724c6816-9190-4329-9cc3-0440c3b04fd0", "problem_statement": "\nTask: Implement a Rust trait system to model animal eating behaviors using associated types.\n\nCore Requirements:\n1. Define a trait called `Eater` with:\n   - An associated type `Food`\n   - A method `eat(&self, food: Food) -> String` that:\n     * Returns a descriptive message about the eating action\n     * Updates the animal's energy by adding calories from the consumed food\n\n2. Model these specific animals and their valid food types:\n   Animal Type  | Valid Foods\n   -------------|-------------\n   Dog          | Bones, Meat\n   Bird         | Seeds, Worms\n   Human        | Pizza, Salad\n   Programmer   | Pizza, Worms\n\nAdditional Implementation Notes:\n- Each animal should only be able to eat its specified food types\n- The trait system should enforce type safety at compile time\n- Each food type should have an associated caloric value\n- Invalid food combinations (e.g., Dog eating Pizza) should not compile\n\nExpected Behavior:\n- When an animal eats valid food, it should:\n  * Increase its energy level\n  * Return a descriptive message about what was eaten\n  * Handle the food consumption in a type-safe manner\n"}
{"id": "7ada1702-7114-4296-b85e-9a2e0c5fb884", "problem_statement": "\nTask: Implement a Rust trait system to model animal eating behaviors and digestion results using associated types.\n\nCore Requirements:\n1. Define a trait called `Eater` with:\n   - An associated type `Food`\n   - An associated type `DigestionResult`\n   - A method `eat(&self, food: Food) -> DigestionResult` that:\n     * Returns a `DigestionResult` with details about the eating and digestion\n     * Updates the animal's energy by adding calories from the consumed food\n\n2. Define a trait called `Food` with:\n   - A method `get_digestible_calories(&self) -> u32` that returns the caloric value of the food\n\n3. Model these specific animals and their valid food types:\n   Animal Type  | Valid Foods\n   -------------|-------------\n   Dog          | Bones, Meat\n   Bird         | Seeds, Worms\n   Human        | Pizza, Salad\n   Programmer   | Pizza, Worms\n   Worm         | Soil\n\nAdditional Implementation Notes:\n- Each animal should only be able to eat its specified food types\n- The trait system should enforce type safety at compile time\n- Each food type should have an associated caloric value\n- Invalid food combinations (e.g., Dog eating Pizza) should not compile\n- Include a Worm as an animal that implements both `Food` and `Eater`\n\nExpected Behavior:\n- When an animal eats valid food, it should:\n  * Increase its energy level based on the digestible calories of the food\n  * Return a `DigestionResult` with a descriptive message about the digestion process\n  * Handle the food consumption in a type-safe manner\n"}
{"id": "9bb5a1fc-e1f1-44f8-9538-ca8f1b7389e5", "problem_statement": "\nTask: Implement a Rust trait system to model animal eating behaviors using generics.\n\nCore Requirements:\n1. Define a trait called `Eater<T>` where T represents the food type:\n   - The trait should be generic over the food type T\n   - Include a method `eat(&self, food: T) -> String` that:\n     * Returns a descriptive message about the eating action\n     * Updates the animal's energy by adding calories from the consumed food\n\n2. Model these specific animals and their valid food types:\n   Animal Type  | Valid Foods\n   -------------|-------------\n   Dog          | Bones, Meat\n   Bird         | Seeds, Worms\n   Human        | Pizza, Salad\n   Programmer   | Pizza, Worms\n\nAdditional Implementation Notes:\n- Use generic constraints to restrict which food types each animal can eat\n- Implement the `Eater<T>` trait multiple times for each animal that can eat multiple food types\n- The generic system should enforce type safety at compile time\n- Each food type should have an associated caloric value\n- Invalid food combinations (e.g., Dog eating Pizza) should not compile\n\nExpected Behavior:\n- When an animal eats valid food, it should:\n  * Increase its energy level\n  * Return a descriptive message about what was eaten\n  * Handle the food consumption in a type-safe manner\n\nImplementation Hint:\n- You may need to implement `Eater<Bones>` and `Eater<Meat>` separately for Dog\n- Similar multiple implementations will be needed for other animals with their respective food types\n"}
{"id": "136820f1-3c42-44a6-941e-2dbc21d7ef0e", "problem_statement": "\nDefine a struct programmer with the following fields:\n- name: String\n- skill_points: f32\n\nOverload the + operator for the programmer struct. The + operator should:\n- Concatenate the first half of the name of the programmer with higher skill_points with the second half of the name of the programmer with lower skill_points.\n- The new programmer should have the harmonic mean of the skill_points of the two programmers.\n"}
{"id": "525bcddb-2865-4bd3-9d43-898c7e023bba", "problem_statement": "\nDefine a struct programmer with the following fields:\n- name: String\n- skill_points: f32\n\nOverload the + operator for the programmer struct. The + operator should:\n- Concatenate the first half of the name of the programmer with higher skill_points with the second half of the name of the programmer with lower skill_points.\n- The new programmer should have the harmonic mean of the skill_points of the two programmers.\n- If we add a programmer and a f32, the programmer's skill_points should be increased by the f32 value.\n"}
{"id": "70d951aa-be03-4890-9afe-4cf7db11c9b1", "problem_statement": "\nWe are writing a game in rust.\nOur basic trait for objects in the game is defined as follows:\n\n```rust\ntrait GameObject {\n    fn render(&self) -> String;\n    fn update(&mut self, dt: f64);\n}\n```\n\nWe want a supertrait of GameObject called \"collectible\", for objects that can be collected.\n\nWe also want a trait \"Collector\" with an associated type that should be a collectible object.\n\nWe want at least three structs that implement GameObject:\n\nSword: A weapon that can be collected.\nChest: A container that can be collected, and can collect swords.\nPlayer: A player that can collect chests.\n\nPlayer should have methods to:\n- Add a chest to the player's inventory.\n- Remove a chest from the player's inventory.\n- List all the swords.\n"}
{"id": "9beb3939-4b11-4668-8a2f-fa28ddb5eb97", "problem_statement": "\nImplement a fixed-size FIFO cache in Rust that stores key-value pairs with time-to-live (TTL) values.\nWhen the cache reaches its maximum capacity, remove the oldest entry to make space for new ones. Each entry consists of a key, value, and TTL.\n\nThe cache should not return a value if the TTL has expired.\n"}
{"id": "c6b9372b-b6f8-4d92-858f-a4be5b1f9087", "problem_statement": "\nImplement a fixed-size LRU cache in Rust that stores key-value pairs with time-to-live (TTL) values.\nWhen the cache reaches its maximum capacity, remove the least recently used entry. Each entry consists of a key, value, and TTL.\n\nThe cache should not return a value if the TTL has expired.\n"}
{"id": "01abe210-80dc-4fd9-b698-032dd5cc9ad6", "problem_statement": "\nImplement a thread-safe LRU cache in Rust with the following specifications:\n\nCore Features:\n- Fixed-size cache storing key-value pairs\n- Each entry has an associated time-to-live (TTL)\n- Evict least recently used entries when capacity is reached\n- Expired entries (past TTL) should not be returned\n\nConcurrency Requirements:\n- Support concurrent reads\n- Write operations should block\n- Thread-safe operation guaranteed\n\nMetrics Tracking:\n- Cache hits\n- Cache misses\n- Number of evictions\n- All metrics must be thread-safe\n"}
{"id": "9ed01fca-89ea-46da-bd9d-fa7dd4ff88e5", "problem_statement": "\nImplement a thread-safe cache in Rust with the following specifications:\n\nCore Features:\n- Fixed-size cache storing key-value pairs\n- Each entry has an associated time-to-live (TTL)\n- When creating the cache the user must choose eviction policy between LRU and FIFO. So the cache should support both eviction policies.\n- Expired entries (past TTL) should not be returned\n- Support bulk operations for inserting and deleting multiple entries.\n\nConcurrency Requirements:\n- Support concurrent reads\n- Write operations should block\n- Thread-safe operation guaranteed\n- Bulk operations should be atomic.\n"}
{"id": "beba4ac5-24d1-4bde-b0e1-1ccdc2fca2be", "problem_statement": "\nImplement a thread-safe cache in Rust with the following specifications:\n\nCore Features:\n- Fixed-size cache storing key-value pairs\n- Each entry has an associated time-to-live (TTL)\n- When creating the cache the user must choose eviction policy between LRU and FIFO. So the cache should support both eviction policies.\n- Expired entries (past TTL) should not be returned\n- Support bulk operations for inserting and deleting multiple entries.\n- Background thread to clean up expired entries.\n- Keep track of the number of cache hits and misses.\n\nConcurrency Requirements:\n- Support concurrent reads\n- Write operations should block\n- Thread-safe operation guaranteed\n- Bulk operations should be atomic.\n"}
{"id": "30ae8422-d34d-4ca3-b110-ec0b6aa72c45", "problem_statement": "\nWe want to implement the backend for a simple enclycopedia like service.\nWe want to support two methods:\n- get_summary: Given a title, return the summary of the article.\n- get_article: Given a title, return the full article.\n\nWe can access both the summary and the article using the following API:\n- https://en.mikipedia.org/api/{title}\n\nWe want to have a two layer LRU cache to store the summaries and articles.\nThe first layer has a capacity of \"n_full\" entries, and the second layer has a capacity of \"n_summary\" entries.\nFor the \"n_full\" most recently accessed articles, we want to store the full article. For the next \"n_summary\" most recently accessed articles, we want to store the summary.\n\nIf an article is not in the cache, we want to fetch it from the API and store it in the cache.\n\nMake the code synchronous.\n"}
{"id": "4c69bb31-2ecb-4874-9829-2f12501cd8a8", "problem_statement": "\nWe want to implement the backend for a simple enclycopedia like service.\nWe want to support two methods:\n- get_summary: Given a title, return the summary of the article.\n- get_article: Given a title, return the full article.\n\nWe can access both the summary and the article using the following API:\n- https://en.mikipedia.org/api/{title}\n\nWe want to have a two layer LRU cache to store the summaries and articles.\nThe first layer has a capacity of \"n_full\" entries, and the second layer has a capacity of \"n_summary\" entries.\nFor the \"n_full\" most recently accessed articles, we want to store the full article. For the next \"n_summary\" most recently accessed articles, we want to store the summary.\n\nIf an article is not in the cache, we want to fetch it from the API and store it in the cache.\n\nMake the code asynchronous.\n"}
{"id": "8bae7a18-692e-4bbe-b8eb-9369b09cb70e", "problem_statement": "\nDesign an asynchronous backend service for a Wikipedia-like encyclopedia with a two-layer LFU caching system in rust.\nAPI Requirements:\n\nImplement get_summary(title: str) -> str: Returns article summary\nImplement get_article(title: str) -> str: Returns full article content\nBoth methods should fetch data from https://en.mikipedia.org/api/{title} if not cached\n\nCaching Requirements:\n\nTwo-layer LFU cache architecture:\n\nFirst layer (capacity: n_full): Stores complete articles\nSecond layer (capacity: n_summary): Stores article summaries only\n\n\nArticles should move between layers based on access count\nWhen eviction is needed, remove entries with lowest access frequency\nOn frequency ties, evict the least recently accessed entry\n\nConcurrency Requirements:\n\nSupport multiple simultaneous requests to the same article\nImplement request coalescing: If multiple requests for the same article arrive simultaneously, only one API call should be made\nCache operations must be thread-safe\nAPI calls should be non-blocking using async/await\n\nPerformance target: Minimize API calls while maintaining data freshness.\n"}
{"id": "7e030eb8-c313-4492-bb20-adbf31eca9a4", "problem_statement": "\nUsing rust \"use std::sync::mpsc\" create a simple but working multi-room chat server.\n"}
{"id": "a4a04d10-7d3d-4f98-91ea-7b86d2627e57", "problem_statement": "\nUsing rust \"use std::sync::mpsc\" create a simple but working single-room chat server.\n"}
{"id": "2d6039b5-bd8d-436b-b415-e2513f661e5b", "problem_statement": "\nUsing Rust with std::sync::mpsc, create a multi-room chat server that supports:\n\n1. Core Features:\n- Multiple chat rooms with unique names.\n- Users can join/leave multiple rooms simultaneously.\n- Private messaging between users.\n- Rate limiting, maximum 5 messages per second per user.\n\n3. Technical Requirements:\n- Handle concurrent connections using tokio.\n- Maximum 100 users per room.\n"}
{"id": "56e0e937-1f8b-49b1-b72e-116b1d49b95a", "problem_statement": "\nBuild a rate-limiting proxy server that handles concurrent requests and enforces different rate limits per client IP.\n"}
{"id": "6bbd409d-594c-4bb0-91f6-d60b157e01a1", "problem_statement": "\nImplement a distributed key-value store in Rust with eventual consistency using TCP connections. The program should:\n\nSupport PUT, GET, and DELETE operations locally on each node.\nEnsure updates propagate asynchronously across nodes for eventual consistency (e.g., using a simple gossip protocol).\nHandle failed connections and duplicate updates gracefully.\nBe implemented entirely in a single Rust source file, kept concise and modular.\n"}
{"id": "43153e6c-f204-4b12-b9e5-a69f3be5b457", "problem_statement": "\nJob Scheduler Challenge\n\nDesign a job scheduler in Rust that manages one-time tasks (represented as FnOnce closures) with the following requirements:\n\nCore Requirements:\n1. Create a JobScheduler struct that accepts tasks of type FnOnce() -> Result<T, E>\n2. Each task must have:\n   - A priority level (High, Medium, Low)\n   - A scheduled execution time\n   - Optional dependencies on other tasks\n3. Tasks can only be executed once and may consume resources\n"}
{"id": "1dc0ac25-ee3c-4b9f-a76b-11e9012e8da4", "problem_statement": "\nCreate a declarative macro tree! that builds a tree structure.\n\n- tree!(value) -> Create a leaf node with the given value.\n- tree!(value, child1, child2, ...) -> Create a node with the given value and children.\n\nThe tree! macro should be able to handle any number of children.\nIt should handle any type that implements clone.\nThe resulting tree should be immutable.\n"}
{"id": "0c87f30c-f8c7-4aaa-afd6-1f5a74ed599d", "problem_statement": "\nImplement a custom Iterator adapter in Rust called stateful_filter that works like a filter but maintains state between iterations by tracking the largest item seen so far.\nThis adapter should only work with types that implement the Ord and Clone traits.\n"}
{"id": "5fb552f9-f9ae-41b7-b566-ecc89d0d76b7", "problem_statement": "\nCreate a Rust declarative macro named second_max that takes a list of integers as input and returns the second largest integer in the list.\nIf the list has fewer than two elements, the macro should return None.\n\n// Basic usage\nhtml!(div);                    // Returns: \"<div></div>\"\nhtml!(p);                      // Returns: \"<p></p>\"\n\n// With string literals\nhtml!(div => \"Hello\");         // Returns: \"<div>Hello</div>\"\nhtml!(p => \"World\");          // Returns: \"<p>World</p>\"\n\n// With variables\nlet content = \"Dynamic\";\nhtml!(div => content);        // Returns: \"<div>Dynamic</div>\"\n\n// Nested structure (optional challenge)\nhtml!(div => {\n    html!(p => \"First paragraph\"),\n    html!(p => \"Second paragraph\")\n});\n// Returns: \"<div><p>First paragraph</p><p>Second paragraph</p></div>\"\n"}
{"id": "fef29bbc-b8d7-4b39-a168-8166156b5c2d", "problem_statement": "\nWrite the Rust code for a city's public transportation system.\nWe will need to be able to:\n\n- Add a station to the network.\n\n    A station has:\n\n    - A unique station ID\n    - Name\n    - Location (coordinates)\n    - List of connected stations (Initially empty)\n    - Type (Bus stop, Metro station, Train station)\n\n\n- Remove a station from the network\n\n- Add a route connection between stations. A connection represents a direct transport link between two stations. Each connection has:\n\n    - Travel time in minutes\n    - Transportation type (Bus, Metro, Train)\n    - Service frequency (trains/buses per hour)\n\n\n- Get all directly connected stations for a given station\n- Remove a route connection\n- Given two stations, find the fastest route between them. The route should be a list of stations and the total travel time. If there is no route, return None.\n"}
{"id": "6bf1c0a7-86a4-479f-8a6c-4fc9aac3f624", "problem_statement": "\nDevelop a Rust tool to manage a hierarchical file system with directories and files, supporting key operations for manipulation and querying.\n\nKey Features:\n\n- Node Management:\n\n    - Add: Insert directories (with path, name, creation date, children, permissions) and files (with path, name, size, creation/modified dates, type, permissions).\n        Example: Add /home/user/docs as a directory or /home/user/docs/file.txt as a file.\n    - Remove: Delete nodes recursively if directories.\n        Example: Remove /home/user/docs and all its contents.\n    - Move & Copy: Change parent directories or duplicate nodes with their subtrees.\n        Example: Move /home/user/docs to /home/user/archive, or copy /home/user/docs to /home/user/backup.\n\n- Operations & Queries:\n\n    - Calculate Size: Total size of directories, including subdirectories.\n        Example: Calculate the size of /home/user/docs to include all files and subdirectories.\n    - Search: Find files by extension, name patterns (e.g., *.rs), or list files modified after a specific date.\n        _Example: Search for all .txt files in /home/user or list files modified after 2023-01-01.*\n    - Duplicate Detection: Identify duplicate files based on content or hashes.\n        Example: Detect duplicate files in /home/user/photos.\n    - Path Handling: Retrieve paths from root to any node or find common ancestors of two nodes.\n        Example: Get the path to file.txt or find the common ancestor of /home/user/docs and /home/user/photos.\n"}
{"id": "ddc3990f-7a2d-4e53-b73c-30f4895c31e8", "problem_statement": "\nWrite a concurrent web crawler that, given a starting URL, visits web pages up to a specified depth and collects all unique internal links (links that belong to the same domain as the starting URL).\nRequirements:\n\n- Accept a starting URL and maximum crawl depth as input\n- Follow only internal links (same domain as starting URL)\n- Avoid visiting the same URL twice\n- Use concurrent requests to improve performance\n"}
{"id": "9b7fe51d-d255-4e5f-8902-6ab78a7bb307", "problem_statement": "\nWrite a concurrent web crawler that, given a starting URL, visits web pages up to a specified depth and collects all unique internal links (links that belong to the same domain as the starting URL).\nRequirements:\n\n- Accept a starting URL and maximum crawl depth as input\n- Follow only internal links (same domain as starting URL)\n- Avoid visiting the same URL twice\n- Use concurrent requests to improve performance\n- Implement a rate limiter with a strategy that can be configured (e.g., fixed rate, adaptive rate).\n- Collect metrics about the crawl, such as the number of pages visited, average response time, and errors encountered.\n"}
{"id": "76f08444-91ca-426e-bf7f-707e5c408b69", "problem_statement": "\nCreate a Rust declarative macro named average that takes a list of floating-point numbers as input and returns their average as an f64. If the list is empty, the macro should return None.\n"}
{"id": "be3f5a47-82e4-4f0c-82bb-703cbc9276d3", "problem_statement": "\nExchange Rate Service\n\nCreate a Rust service that provides exchange rates for different currencies. The service should support the following operations:\n\n- Add a new exchange rate: currency1, currency2, rate (currency1 to currency2).\n- Get the exchange rate between two currencies. (This should be a bidirectional operation.\n- Convert an amount from one currency to another.\n- It should be possible to add multiple exchange rates for the same currency pair, and the service should return the most recent rate.\n- The service should be able to handle multiple concurrent requests. You can use any concurrency model you prefer.\n"}
{"id": "bbc7e7a8-9aaf-4da2-8225-8ef8be731f6a", "problem_statement": "\nExchange Rate\n\nCreate a Rust program that provides exchange rates for different currencies. It should support the following operations:\n\n- Add a new exchange rate: currency1, currency2, rate (currency1 to currency2).\n- Get the exchange rate between two currencies. (This should be a bidirectional operation.)\n- Convert an amount from one currency to another.\n"}
{"id": "dca7facc-f805-4660-a291-10ef35f8f900", "problem_statement": "\nWe have a json file with a list of students, each student has:\n - name (unique)\n - age\n - courses (list of strings)\n\nExample:\n{\n  \"students\": [\n    {\n      \"name\": \"Alice Santamaria\",\n      \"age\": 20,\n      \"courses\": [\"Math201\", \"Physics101\"]\n    },\n    {\n      \"name\": \"Bob Alvarez\",\n      \"age\": 21,\n      \"courses\": [\"Math201\", \"Chemistr303\"]\n    }\n  ]\n}\n\nWe have another json file with a list of courses, each course has:\n    - name (unique)\n    - teacher (each teacher also has an unique name)\n\nA teacher may teach multiple courses.\nExample:\n{\n  \"courses\": [\n    {\n      \"name\": \"Math201\",\n      \"teacher\": \"John Doe\"\n    },\n    {\n      \"name\": \"Physics101\",\n      \"teacher\": \"Jane Smith\"\n    }\n  ]\n}\n\nCreate a Rust program that process both files and has the following method using the processed information:\n\n- do_they_share_teacher(student_name_1: &str, student_name_2: &str) -> bool, that returns true if the students share a teacher, false otherwise.\nShould return true even if the students dont share any classes, but have a teacher in common.\n"}
{"id": "55b743f9-1ebd-4559-a6cf-1fb6eff40c2a", "problem_statement": "\nWe have a json file with a list of students, each student has:\n - name (unique)\n - age\n - courses (list of strings)\n\nExample:\n{\n  \"students\": [\n    {\n      \"name\": \"Alice Santamaria\",\n      \"age\": 20,\n      \"courses\": [\"Math201\", \"Physics101\"]\n    },\n    {\n      \"name\": \"Bob Alvarez\",\n      \"age\": 21,\n      \"courses\": [\"Math201\", \"Chemistr303\"]\n    }\n  ]\n}\n\nWe have another json file with a list of courses, each course has:\n    - name (unique)\n    - teacher (each teacher also has an unique name)\n\nA teacher may teach multiple courses.\nExample:\n{\n  \"courses\": [\n    {\n      \"name\": \"Math201\",\n      \"teacher\": \"John Doe\"\n    },\n    {\n      \"name\": \"Physics101\",\n      \"teacher\": \"Jane Smith\"\n    }\n  ]\n}\n\nCreate a Rust program that process both files and has the following method using the processed information:\n\n- do_they_share_teacher(student_name_1: &str, student_name_2: &str) -> bool, that returns true if the students share a teacher, false otherwise.\nShould return true even if the students dont share any classes, but have a teacher in common.\n\n- do_they_share_course(student_name_1: &str, student_name_2: &str) -> bool, that returns true if the students share a course, false otherwise.\n- get_shared_courses(student_name_1: &str, student_name_2: &str) -> Vec<String>, that returns a list of courses that both students share.\n- get_all_students(teachers_name: &str) -> Vec<String>, that returns a list of students that have the teacher with the given name.\n"}
{"id": "7557bbb4-c20e-4bed-9912-e807ed9dd7a3", "problem_statement": "\nA house cat can be in four states: resting, playing, hunting, and grooming.\nThere are three events that can affect the cat: bell_sound, bird_spotted, sunshine.\nIf the cat is resting or grooming, the bell_sound event will make it play.\nIf the cat is playing or resting, spotting a bird will make it hunt.\nWhenever sunshine appears, regardless of the state, the cat will start grooming.\nModel this via the rust type system. Implement a match statement for the transitions that is as short as possible.\n"}
{"id": "53f98ac8-7775-4021-b261-ff142f0de0eb", "problem_statement": "\nDesign a state machine in Rust for a programmer that can be in one of four states: working, eating, distracted, or sleeping. The programmer responds to three events: hunger, fly, and nighttime.\nThe rules are:\n\nIf the programmer is working and gets hungry, they start eating\nIf a fly appears while they're working, eating, or distracted, they become distracted\nWhen nighttime comes, regardless of their current state, they go to sleep\n\nModel this using Rust's type system and implement a match statement for the transitions that is as short as possible.\n"}
{"id": "ee9f64a5-643c-42d1-b583-a2001ce9ae01", "problem_statement": "\nCode a Rust program that prints the first 100 prime numbers to the console.\n"}
{"id": "67de23f1-5890-46c8-87fc-b54ae712646e", "problem_statement": "\nWrite a Rust program that calculates the factorial of a given number using recursion.\n"}
{"id": "eadad3f4-5e40-4e49-85e8-8a00dceec642", "problem_statement": "\n// Exercise: Library Book Tracking System\n//\n// Implement a library system where:\n// 1. Books can be checked out and returned\n// 2. Each book keeps track of its checkout history\n// 3. The library needs to update book statistics while holding an immutable reference to the book\n//\n\nUse the following structure as a starting point:\n#[derive(Debug)]\nstruct BookStats {\n    times_checked_out: u32,\n    currently_checked_out: bool,\n}\n\nImplement a Book struct with the following methods:\n\n    // TODO: Implement new() constructor that takes a title and returns a Book\n    \n    // TODO: Implement checkout() method that:\n    // - Returns Result<(), &'static str>\n    // - Returns error if book is already checked out\n    // - Updates times_checked_out and currently_checked_out if successful\n    \n    // TODO: Implement return_book() method that:\n    // - Returns Result<(), &'static str>\n    // - Returns error if book is not checked out\n    // - Updates currently_checked_out if successful\n    \n    // TODO: Implement get_checkout_count() that returns number of times book was checked out\n"}
{"id": "13336111-8997-4a77-aea3-0094f7585c5c", "problem_statement": "\nExercise: Movie Rental System\n\nImplement a movie rental system in rust where:\n1. Movies can be added to the store's inventory\n2. Customers can rent movies if they're available\n3. Movies can be returned and rental history is tracked\n4. The system prevents renting already rented movies\n"}
{"id": "02196f18-2753-4d5e-b266-046cc2c02b0c", "problem_statement": "\nExercise: Advanced Movie Rental System\n\nImplement a thread-safe, generic rental system that:\n1. Supports any rentable item type (not just movies)\n2. Uses async/await for operations\n3. Implements custom traits for rental behaviors\n4. Provides comprehensive error handling\n5. Supports rental policies and validation\n6. Uses interior mutability where appropriate\n7. Implements custom iterators for viewing rental history\n\nRequirements:\n- Use generics and trait bounds\n- Implement custom error types\n- Ensure thread safety\n- Support async operations\n- Implement custom iterators\n"}
